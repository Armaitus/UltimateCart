
sdcard.elf:     file format elf32-littlenios2
sdcard.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x002081bc

Program Header:
    LOAD off    0x00001000 vaddr 0x00208000 paddr 0x00208000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00208020 paddr 0x00208020 align 2**12
         filesz 0x0000591c memsz 0x0000591c flags r-x
    LOAD off    0x0000693c vaddr 0x0020d93c paddr 0x0020dc28 align 2**12
         filesz 0x000002ec memsz 0x000002ec flags rw-
    LOAD off    0x00006f14 vaddr 0x0020df14 paddr 0x0020df14 align 2**12
         filesz 0x00000000 memsz 0x00000150 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00208000  00208000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000019c  00208020  00208020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000053b8  002081bc  002081bc  000011bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000003c8  0020d574  0020d574  00006574  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000002ec  0020d93c  0020dc28  0000693c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000150  0020df14  0020df14  00006f14  2**2
                  ALLOC, SMALL_DATA
  6 .ext_sram_controller_0 00000000  00100000  00100000  00006c28  2**0
                  CONTENTS
  7 .memory       00000000  0020e064  0020e064  00006c28  2**0
                  CONTENTS
  8 .cart_memory  00000000  00212000  00212000  00006c28  2**0
                  CONTENTS
  9 .comment      00000039  00000000  00000000  00006c28  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00000748  00000000  00000000  00006c68  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   000081a6  00000000  00000000  000073b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00003079  00000000  00000000  0000f556  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00003ea7  00000000  00000000  000125cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000012ec  00000000  00000000  00016478  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00001f68  00000000  00000000  00017764  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    000015ef  00000000  00000000  000196cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000010  00000000  00000000  0001acbc  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 000000f0  00000000  00000000  0001acd0  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  0001d1b5  2**0
                  CONTENTS, READONLY
 20 .cpu          00000003  00000000  00000000  0001d1b8  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0001d1bb  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0001d1bc  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  0001d1bd  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  0001d1c1  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  0001d1c5  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   0000000b  00000000  00000000  0001d1c9  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    0000000b  00000000  00000000  0001d1d4  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   0000000b  00000000  00000000  0001d1df  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 00000004  00000000  00000000  0001d1ea  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 0000001b  00000000  00000000  0001d1ee  2**0
                  CONTENTS, READONLY
 31 .jdi          000033a9  00000000  00000000  0001d209  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     0005ee50  00000000  00000000  000205b2  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00208000 l    d  .entry	00000000 .entry
00208020 l    d  .exceptions	00000000 .exceptions
002081bc l    d  .text	00000000 .text
0020d574 l    d  .rodata	00000000 .rodata
0020d93c l    d  .rwdata	00000000 .rwdata
0020df14 l    d  .bss	00000000 .bss
00100000 l    d  .ext_sram_controller_0	00000000 .ext_sram_controller_0
0020e064 l    d  .memory	00000000 .memory
00212000 l    d  .cart_memory	00000000 .cart_memory
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../sdcard_bsp//obj/HAL/src/crt0.o
002081f4 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00208094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 diskio.c
00000000 l    df *ABS*	00000000 pff.c
0020df14 l     O .bss	00000004 FatFs
002082b0 l     F .text	00000058 mem_set
00208308 l     F .text	0000009c mem_cmp
002083a4 l     F .text	00000160 get_fat
00208504 l     F .text	00000080 clust2sect
00208584 l     F .text	000000c0 get_clust
00208644 l     F .text	000000c4 dir_rewind
00208708 l     F .text	0000013c dir_next2
00208844 l     F .text	00000100 dir_find
00208944 l     F .text	00000250 dir_read
00208b94 l     F .text	0000018c create_name
0020d574 l     O .rodata	00000080 cvt.1604
00208d20 l     F .text	0000021c get_fileinfo
00208f3c l     F .text	00000150 follow_path
0020908c l     F .text	0000014c check_fs
00000000 l    df *ABS*	00000000 pfs_interface.c
0020dbf0 l     O .rwdata	00000001 Stat
0020df18 l     O .bss	00000001 CardType
0020df1a l     O .bss	00000002 Timer1
0020df1c l     O .bss	00000002 Timer2
0020df20 l     O .bss	00000004 Control1
00209b0c l     F .text	0000004c SetLowSpeed
00209b58 l     F .text	0000006c SetHighSpeed
00209bc4 l     F .text	0000003c Set8BitTransfer
00209c00 l     F .text	00000038 Set32BitTransfer
00209c38 l     F .text	00000050 ReceiveU8
00209c88 l     F .text	0000012c ReceiveDatablock
00209db4 l     F .text	00000054 WaitReady
00209e08 l     F .text	00000044 ReleaseBus
00209e4c l     F .text	00000250 SendCMD
00000000 l    df *ABS*	00000000 ultimate.c
0020df4c l     O .bss	00000018 alarm
0020df24 l     O .bss	00000004 Systick
0020dbf4 l     O .rwdata	00000004 ledVal
0020a538 l     F .text	00000090 TimerFunction
00000000 l    df *ABS*	00000000 lib2-divmod.c
0020b3f8 l     F .text	00000070 udivmodsi4
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 qsort.c
0020b57c l     F .text	00000058 swapfunc
0020b5d4 l     F .text	000000a8 med3
00000000 l    df *ABS*	00000000 strcasecmp.c
00000000 l    df *ABS*	00000000 strcat.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 strrchr.c
00000000 l    df *ABS*	00000000 ctype_.c
0020d785 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_load.c
0020be18 l     F .text	00000064 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0020c110 l     F .text	00000038 alt_dev_reg
0020d93c l     O .rwdata	0000002c jtag_uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0020c400 l     F .text	00000074 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_close.c
0020c4fc l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0020c638 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0020c664 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0020caf0 l     F .text	000000e0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
0020cc48 l     F .text	00000050 alt_get_errno
0020cc98 l     F .text	000000f4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 impure.c
0020db10 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 alt_exit.c
0020befc g     F .text	00000078 alt_main
0020bb74 g     F .text	00000020 strcpy
0020df64 g     O .bss	00000100 alt_irq
0020dc28 g       *ABS*	00000000 __flash_rwdata_start
00208228 g     F .text	00000060 disk_readp
0020df28 g     O .bss	00000004 num_dir_entries
0020a8a4 g     F .text	00000100 populate_cart_file_list
00000000  w      *UND*	00000000 __errno
00208000 g     F .entry	0000000c __reset
00208020 g       *ABS*	00000000 __flash_exceptions_start
0020df48 g     O .bss	00000004 errno
0020df34 g     O .bss	00000004 alt_argv
00215bf0 g       *ABS*	00000000 _gp
0020aa50 g     F .text	00000060 recieve_atari_byte
0020b67c g     F .text	00000438 qsort
0020d990 g     O .rwdata	00000180 alt_fd_list
0020cf88 g     F .text	00000090 alt_find_dev
0020b534 g     F .text	00000028 memcpy
0020cbd0 g     F .text	00000078 alt_io_redirect
0020d574 g       *ABS*	00000000 __DTOR_END__
002081f8 g     F .text	00000030 disk_initialize
0020aab0 g     F .text	00000068 atari_reboot_with_cart
0020c288 g     F .text	000000e4 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
0020b4fc g     F .text	00000008 .hidden __udivsi3
0020a9a4 g     F .text	00000034 set_cart_cmd_byte
00212000 g       *ABS*	00000000 __alt_mem_cart_memory
0020a6f0 g     F .text	000001b4 read_directory
00209a00 g     F .text	0000010c pf_readdir
0020dc14 g     O .rwdata	00000004 alt_max_fd
0020dc20 g     O .rwdata	00000004 _global_impure_ptr
0020e064 g       *ABS*	00000000 __bss_end
0020ca00 g     F .text	000000f0 alt_iic_isr_register
0020c00c g     F .text	00000104 alt_tick
0020c9b4 g     F .text	0000004c alt_ic_irq_enabled
0020bf74 g     F .text	00000098 alt_alarm_stop
0020df44 g     O .bss	00000004 alt_irq_active
002080ec g     F .exceptions	000000d0 alt_irq_handler
0020d968 g     O .rwdata	00000028 alt_dev_null
0020bc40 g     F .text	00000068 strrchr
0020c61c g     F .text	0000001c alt_dcache_flush_all
0020dc28 g       *ABS*	00000000 __ram_rwdata_end
0020dc0c g     O .rwdata	00000008 alt_dev_list
0020d93c g       *ABS*	00000000 __ram_rodata_end
0020bb0c g     F .text	00000030 strcat
0020b504 g     F .text	00000008 .hidden __umodsi3
0020e064 g       *ABS*	00000000 end
0020d574 g       *ABS*	00000000 __CTOR_LIST__
0020f000 g       *ABS*	00000000 __alt_stack_pointer
0020c474 g     F .text	00000088 alt_avalon_timer_sc_init
0020c36c g     F .text	00000094 altera_avalon_jtag_uart_write
0020d3a8 g     F .text	00000198 __call_exitprocs
002081bc g     F .text	0000003c _start
0020df3c g     O .bss	00000004 _alt_tick_rate
0020df40 g     O .bss	00000004 _alt_nticks
0020c17c g     F .text	0000004c alt_sys_init
0020d264 g     F .text	00000144 __register_exitproc
0020bbb0 g     F .text	00000044 strncmp
0020b50c g     F .text	00000028 .hidden __mulsi3
0020d93c g       *ABS*	00000000 __ram_rwdata_start
0020a3a0 g     F .text	00000198 ffs_DiskIORead
0020d574 g       *ABS*	00000000 __ram_rodata_start
0020bbf4 g     F .text	0000004c strncpy
0020bab4 g     F .text	00000058 strcasecmp
0020c1c8 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0020d12c g     F .text	000000d4 alt_get_fd
0020a09c g     F .text	0000006c ffs_DiskIOTimerproc
0020a14c g     F .text	00000254 ffs_DiskIOInitialize
0020d234 g     F .text	00000030 memcmp
0020e064 g       *ABS*	00000000 __alt_stack_base
0020d018 g     F .text	00000114 alt_find_file
0020c6b4 g     F .text	000000a0 alt_dev_llist_insert
0020df14 g       *ABS*	00000000 __bss_start
0020b55c g     F .text	00000020 memset
0020afb0 g     F .text	00000448 main
0020df38 g     O .bss	00000004 alt_envp
0020a9d8 g     F .text	00000034 set_cart_list_flag_byte
0020c228 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0020ab18 g     F .text	00000498 load_cart
0020a628 g     F .text	000000c8 entry_compare
0020dc18 g     O .rwdata	00000004 alt_errno
00208288 g     F .text	00000028 disk_writep
0020b468 g     F .text	00000048 .hidden __divsi3
0020d574 g       *ABS*	00000000 __CTOR_END__
0020bb3c g     F .text	00000038 strcmp
002096dc g     F .text	00000258 pf_read
0020d574 g       *ABS*	00000000 __flash_rodata_start
0020d574 g       *ABS*	00000000 __DTOR_LIST__
0020c148 g     F .text	00000034 alt_irq_init
0020cee8 g     F .text	00000080 alt_release_fd
0020d200 g     F .text	00000014 atexit
00100000 g       *ABS*	00000000 __alt_mem_ext_sram_controller_0
0020dc24 g     O .rwdata	00000004 _impure_ptr
0020df30 g     O .bss	00000004 alt_argc
002095cc g     F .text	00000110 pf_open
0020c7b0 g     F .text	0000005c _do_dtors
00208020 g       .exceptions	00000000 alt_irq_entry
0020dc04 g     O .rwdata	00000008 alt_fs_list
00208020 g       *ABS*	00000000 __ram_exceptions_start
0020c828 g     F .text	00000050 alt_ic_isr_register
0020dc28 g       *ABS*	00000000 _edata
0020e064 g       *ABS*	00000000 _end
002081bc g       *ABS*	00000000 __ram_exceptions_end
0020df2c g     O .bss	00000004 dir_offset
0020c914 g     F .text	000000a0 alt_ic_irq_disable
00208000 g       *ABS*	00000000 __alt_mem_memory
0020cf68 g     F .text	00000020 altera_nios2_qsys_irq_init
00209934 g     F .text	000000cc pf_opendir
0020d214 g     F .text	00000020 exit
0020b4b0 g     F .text	0000004c .hidden __modsi3
0020dbf8 g     O .rwdata	00000004 __ctype_ptr__
0020f000 g       *ABS*	00000000 __alt_data_end
00208020 g     F .exceptions	00000000 alt_exception
0020d684 g     O .rodata	00000101 _ctype_
0020d540 g     F .text	00000034 _exit
0020a5c8 g     F .text	00000060 get_filename_ext
0020bcd8 g     F .text	00000140 alt_alarm_start
0020bb94 g     F .text	0000001c strlen
0020cd8c g     F .text	0000015c open
0020c80c g     F .text	0000001c alt_icache_flush_all
0020bca8 g     F .text	00000030 strchr
0020dc1c g     O .rwdata	00000004 alt_priority_mask
0020c878 g     F .text	0000009c alt_ic_irq_enable
0020a108 g     F .text	00000044 ffs_DiskIOInit
0020dbfc g     O .rwdata	00000008 alt_alarm_list
0020c754 g     F .text	0000005c _do_ctors
0020c54c g     F .text	000000d0 close
002091d8 g     F .text	000003f4 pf_mount
0020be7c g     F .text	00000080 alt_load
0020aa0c g     F .text	00000044 set_cart_error
00000000  w      *UND*	00000000 free



Disassembly of section .entry:

00208000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  208000:	00400834 	movhi	at,32
    ori r1, r1, %lo(_start)
  208004:	08606f14 	ori	at,at,33212
    jmp r1
  208008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

00208020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  208020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  208024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  208028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  20802c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  208030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  208034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  208038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  20803c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  208040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  208044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  208048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  20804c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  208050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  208054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  208058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  20805c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  208060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  208064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  208068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  20806c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  208070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  208074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  208078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  20807c:	10000326 	beq	r2,zero,20808c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  208080:	20000226 	beq	r4,zero,20808c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  208084:	02080ec0 	call	2080ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  208088:	00000306 	br	208098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  20808c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  208090:	e8bfff17 	ldw	r2,-4(ea)

00208094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  208094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  208098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  20809c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  2080a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  2080a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  2080a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  2080ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  2080b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  2080b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  2080b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  2080bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  2080c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  2080c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  2080c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  2080cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  2080d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  2080d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  2080d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  2080dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  2080e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  2080e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  2080e8:	ef80083a 	eret

002080ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  2080ec:	defff904 	addi	sp,sp,-28
  2080f0:	dfc00615 	stw	ra,24(sp)
  2080f4:	df000515 	stw	fp,20(sp)
  2080f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  2080fc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  208100:	0005313a 	rdctl	r2,ipending
  208104:	e0bffe15 	stw	r2,-8(fp)

  return active;
  208108:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  20810c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  208110:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  208114:	00800044 	movi	r2,1
  208118:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  20811c:	e0fffb17 	ldw	r3,-20(fp)
  208120:	e0bffc17 	ldw	r2,-16(fp)
  208124:	1884703a 	and	r2,r3,r2
  208128:	10001726 	beq	r2,zero,208188 <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  20812c:	00c00874 	movhi	r3,33
  208130:	18f7d904 	addi	r3,r3,-8348
  208134:	e0bffd17 	ldw	r2,-12(fp)
  208138:	100490fa 	slli	r2,r2,3
  20813c:	1885883a 	add	r2,r3,r2
  208140:	10800017 	ldw	r2,0(r2)
  208144:	01000874 	movhi	r4,33
  208148:	2137d904 	addi	r4,r4,-8348
  20814c:	e0fffd17 	ldw	r3,-12(fp)
  208150:	180690fa 	slli	r3,r3,3
  208154:	20c7883a 	add	r3,r4,r3
  208158:	18c00104 	addi	r3,r3,4
  20815c:	18c00017 	ldw	r3,0(r3)
  208160:	1809883a 	mov	r4,r3
  208164:	103ee83a 	callr	r2
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  208168:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  20816c:	0005313a 	rdctl	r2,ipending
  208170:	e0bfff15 	stw	r2,-4(fp)

  return active;
  208174:	e0bfff17 	ldw	r2,-4(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
  208178:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  20817c:	e0bffb17 	ldw	r2,-20(fp)
  208180:	103fe31e 	bne	r2,zero,208110 <_gp+0xffff2520>
  208184:	00000706 	br	2081a4 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  208188:	e0bffc17 	ldw	r2,-16(fp)
  20818c:	1085883a 	add	r2,r2,r2
  208190:	e0bffc15 	stw	r2,-16(fp)
      i++;
  208194:	e0bffd17 	ldw	r2,-12(fp)
  208198:	10800044 	addi	r2,r2,1
  20819c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  2081a0:	003fde06 	br	20811c <_gp+0xffff252c>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  2081a4:	0001883a 	nop
}
  2081a8:	e037883a 	mov	sp,fp
  2081ac:	dfc00117 	ldw	ra,4(sp)
  2081b0:	df000017 	ldw	fp,0(sp)
  2081b4:	dec00204 	addi	sp,sp,8
  2081b8:	f800283a 	ret

Disassembly of section .text:

002081bc <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  2081bc:	06c00834 	movhi	sp,32
    ori sp, sp, %lo(__alt_stack_pointer)
  2081c0:	defc0014 	ori	sp,sp,61440
    movhi gp, %hi(_gp)
  2081c4:	06800874 	movhi	gp,33
    ori gp, gp, %lo(_gp)
  2081c8:	d696fc14 	ori	gp,gp,23536
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  2081cc:	00800834 	movhi	r2,32
    ori r2, r2, %lo(__bss_start)
  2081d0:	10b7c514 	ori	r2,r2,57108

    movhi r3, %hi(__bss_end)
  2081d4:	00c00834 	movhi	r3,32
    ori r3, r3, %lo(__bss_end)
  2081d8:	18f81914 	ori	r3,r3,57444

    beq r2, r3, 1f
  2081dc:	10c00326 	beq	r2,r3,2081ec <_start+0x30>

0:
    stw zero, (r2)
  2081e0:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  2081e4:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  2081e8:	10fffd36 	bltu	r2,r3,2081e0 <_gp+0xffff25f0>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  2081ec:	020be7c0 	call	20be7c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  2081f0:	020befc0 	call	20befc <alt_main>

002081f4 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  2081f4:	003fff06 	br	2081f4 <_gp+0xffff2604>

002081f8 <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (void)
{
  2081f8:	defffd04 	addi	sp,sp,-12
  2081fc:	dfc00215 	stw	ra,8(sp)
  208200:	df000115 	stw	fp,4(sp)
  208204:	df000104 	addi	fp,sp,4
	DSTATUS stat;
	stat = ffs_DiskIOInitialize();
  208208:	020a14c0 	call	20a14c <ffs_DiskIOInitialize>
  20820c:	e0bfff05 	stb	r2,-4(fp)
	return stat;
  208210:	e0bfff03 	ldbu	r2,-4(fp)
}
  208214:	e037883a 	mov	sp,fp
  208218:	dfc00117 	ldw	ra,4(sp)
  20821c:	df000017 	ldw	fp,0(sp)
  208220:	dec00204 	addi	sp,sp,8
  208224:	f800283a 	ret

00208228 <disk_readp>:
	BYTE* buff,		/* Pointer to the destination object */
	DWORD sector,	/* Sector number (LBA) */
	UINT offset,	/* Offset in the sector */
	UINT count		/* Byte count (bit15:destination) */
)
{
  208228:	defff904 	addi	sp,sp,-28
  20822c:	dfc00615 	stw	ra,24(sp)
  208230:	df000515 	stw	fp,20(sp)
  208234:	df000504 	addi	fp,sp,20
  208238:	e13ffc15 	stw	r4,-16(fp)
  20823c:	e17ffd15 	stw	r5,-12(fp)
  208240:	e1bffe15 	stw	r6,-8(fp)
  208244:	e1ffff15 	stw	r7,-4(fp)
	DRESULT res;
	res = ffs_DiskIORead(buff, sector, offset, count);
  208248:	e0bffe17 	ldw	r2,-8(fp)
  20824c:	10ffffcc 	andi	r3,r2,65535
  208250:	e0bfff17 	ldw	r2,-4(fp)
  208254:	10bfffcc 	andi	r2,r2,65535
  208258:	e13ffc17 	ldw	r4,-16(fp)
  20825c:	e17ffd17 	ldw	r5,-12(fp)
  208260:	180d883a 	mov	r6,r3
  208264:	100f883a 	mov	r7,r2
  208268:	020a3a00 	call	20a3a0 <ffs_DiskIORead>
  20826c:	e0bffb15 	stw	r2,-20(fp)
	return res;
  208270:	e0bffb17 	ldw	r2,-20(fp)
}
  208274:	e037883a 	mov	sp,fp
  208278:	dfc00117 	ldw	ra,4(sp)
  20827c:	df000017 	ldw	fp,0(sp)
  208280:	dec00204 	addi	sp,sp,8
  208284:	f800283a 	ret

00208288 <disk_writep>:

DRESULT disk_writep (
	const BYTE* buff,		/* Pointer to the data to be written, NULL:Initiate/Finalize write operation */
	DWORD sc		/* Sector number (LBA) or Number of bytes to send */
)
{
  208288:	defffc04 	addi	sp,sp,-16
  20828c:	df000315 	stw	fp,12(sp)
  208290:	df000304 	addi	fp,sp,12
  208294:	e13ffe15 	stw	r4,-8(fp)
  208298:	e17fff15 	stw	r5,-4(fp)

		// Send data to the disk

	}

	return res;
  20829c:	e0bffd17 	ldw	r2,-12(fp)
}
  2082a0:	e037883a 	mov	sp,fp
  2082a4:	df000017 	ldw	fp,0(sp)
  2082a8:	dec00104 	addi	sp,sp,4
  2082ac:	f800283a 	ret

002082b0 <mem_set>:
FATFS *FatFs;	/* Pointer to the file system object (logical drive) */


/* Fill memory */
static
void mem_set (void* dst, int val, int cnt) {
  2082b0:	defffb04 	addi	sp,sp,-20
  2082b4:	df000415 	stw	fp,16(sp)
  2082b8:	df000404 	addi	fp,sp,16
  2082bc:	e13ffd15 	stw	r4,-12(fp)
  2082c0:	e17ffe15 	stw	r5,-8(fp)
  2082c4:	e1bfff15 	stw	r6,-4(fp)
	char *d = (char*)dst;
  2082c8:	e0bffd17 	ldw	r2,-12(fp)
  2082cc:	e0bffc15 	stw	r2,-16(fp)
	while (cnt--) *d++ = (char)val;
  2082d0:	00000506 	br	2082e8 <mem_set+0x38>
  2082d4:	e0bffc17 	ldw	r2,-16(fp)
  2082d8:	10c00044 	addi	r3,r2,1
  2082dc:	e0fffc15 	stw	r3,-16(fp)
  2082e0:	e0fffe17 	ldw	r3,-8(fp)
  2082e4:	10c00005 	stb	r3,0(r2)
  2082e8:	e0bfff17 	ldw	r2,-4(fp)
  2082ec:	10ffffc4 	addi	r3,r2,-1
  2082f0:	e0ffff15 	stw	r3,-4(fp)
  2082f4:	103ff71e 	bne	r2,zero,2082d4 <_gp+0xffff26e4>
}
  2082f8:	e037883a 	mov	sp,fp
  2082fc:	df000017 	ldw	fp,0(sp)
  208300:	dec00104 	addi	sp,sp,4
  208304:	f800283a 	ret

00208308 <mem_cmp>:

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, int cnt) {
  208308:	defff904 	addi	sp,sp,-28
  20830c:	df000615 	stw	fp,24(sp)
  208310:	df000604 	addi	fp,sp,24
  208314:	e13ffd15 	stw	r4,-12(fp)
  208318:	e17ffe15 	stw	r5,-8(fp)
  20831c:	e1bfff15 	stw	r6,-4(fp)
	const char *d = (const char *)dst, *s = (const char *)src;
  208320:	e0bffd17 	ldw	r2,-12(fp)
  208324:	e0bffa15 	stw	r2,-24(fp)
  208328:	e0bffe17 	ldw	r2,-8(fp)
  20832c:	e0bffb15 	stw	r2,-20(fp)
	int r = 0;
  208330:	e03ffc15 	stw	zero,-16(fp)
	while (cnt-- && (r = *d++ - *s++) == 0) ;
  208334:	0001883a 	nop
  208338:	e0bfff17 	ldw	r2,-4(fp)
  20833c:	10ffffc4 	addi	r3,r2,-1
  208340:	e0ffff15 	stw	r3,-4(fp)
  208344:	10001226 	beq	r2,zero,208390 <mem_cmp+0x88>
  208348:	e0bffa17 	ldw	r2,-24(fp)
  20834c:	10c00044 	addi	r3,r2,1
  208350:	e0fffa15 	stw	r3,-24(fp)
  208354:	10800003 	ldbu	r2,0(r2)
  208358:	10c03fcc 	andi	r3,r2,255
  20835c:	18c0201c 	xori	r3,r3,128
  208360:	18ffe004 	addi	r3,r3,-128
  208364:	e0bffb17 	ldw	r2,-20(fp)
  208368:	11000044 	addi	r4,r2,1
  20836c:	e13ffb15 	stw	r4,-20(fp)
  208370:	10800003 	ldbu	r2,0(r2)
  208374:	10803fcc 	andi	r2,r2,255
  208378:	1080201c 	xori	r2,r2,128
  20837c:	10bfe004 	addi	r2,r2,-128
  208380:	1885c83a 	sub	r2,r3,r2
  208384:	e0bffc15 	stw	r2,-16(fp)
  208388:	e0bffc17 	ldw	r2,-16(fp)
  20838c:	103fea26 	beq	r2,zero,208338 <_gp+0xffff2748>
	return r;
  208390:	e0bffc17 	ldw	r2,-16(fp)
}
  208394:	e037883a 	mov	sp,fp
  208398:	df000017 	ldw	fp,0(sp)
  20839c:	dec00104 	addi	sp,sp,4
  2083a0:	f800283a 	ret

002083a4 <get_fat>:

static
CLUST get_fat (	/* 1:IO error, Else:Cluster status */
	CLUST clst	/* Cluster# to get the link information */
)
{
  2083a4:	defffb04 	addi	sp,sp,-20
  2083a8:	dfc00415 	stw	ra,16(sp)
  2083ac:	df000315 	stw	fp,12(sp)
  2083b0:	df000304 	addi	fp,sp,12
  2083b4:	e13fff15 	stw	r4,-4(fp)
	BYTE buf[4];
	FATFS *fs = FatFs;
  2083b8:	d0a0c917 	ldw	r2,-31964(gp)
  2083bc:	e0bffd15 	stw	r2,-12(fp)

	if (clst < 2 || clst >= fs->n_fatent)	/* Range check */
  2083c0:	e0bfff17 	ldw	r2,-4(fp)
  2083c4:	108000b0 	cmpltui	r2,r2,2
  2083c8:	1000041e 	bne	r2,zero,2083dc <get_fat+0x38>
  2083cc:	e0bffd17 	ldw	r2,-12(fp)
  2083d0:	10800217 	ldw	r2,8(r2)
  2083d4:	e0ffff17 	ldw	r3,-4(fp)
  2083d8:	18800236 	bltu	r3,r2,2083e4 <get_fat+0x40>
		return 1;
  2083dc:	00800044 	movi	r2,1
  2083e0:	00004306 	br	2084f0 <get_fat+0x14c>

	switch (fs->fs_type) {
  2083e4:	e0bffd17 	ldw	r2,-12(fp)
  2083e8:	10800003 	ldbu	r2,0(r2)
  2083ec:	10803fcc 	andi	r2,r2,255
  2083f0:	10c000a0 	cmpeqi	r3,r2,2
  2083f4:	1800031e 	bne	r3,zero,208404 <get_fat+0x60>
  2083f8:	108000e0 	cmpeqi	r2,r2,3
  2083fc:	1000191e 	bne	r2,zero,208464 <get_fat+0xc0>
  208400:	00003a06 	br	2084ec <get_fat+0x148>
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
	}
#endif
#if _FS_FAT16
	case FS_FAT16 :
		if (disk_readp(buf, fs->fatbase + clst / 256, ((UINT)clst % 256) * 2, 2)) break;
  208404:	e0bffd17 	ldw	r2,-12(fp)
  208408:	10c00317 	ldw	r3,12(r2)
  20840c:	e0bfff17 	ldw	r2,-4(fp)
  208410:	1004d23a 	srli	r2,r2,8
  208414:	1887883a 	add	r3,r3,r2
  208418:	e0bfff17 	ldw	r2,-4(fp)
  20841c:	10803fcc 	andi	r2,r2,255
  208420:	1085883a 	add	r2,r2,r2
  208424:	e13ffe04 	addi	r4,fp,-8
  208428:	180b883a 	mov	r5,r3
  20842c:	100d883a 	mov	r6,r2
  208430:	01c00084 	movi	r7,2
  208434:	02082280 	call	208228 <disk_readp>
  208438:	10000126 	beq	r2,zero,208440 <get_fat+0x9c>
  20843c:	00002b06 	br	2084ec <get_fat+0x148>
		return LD_WORD(buf);
  208440:	e0bffe43 	ldbu	r2,-7(fp)
  208444:	10803fcc 	andi	r2,r2,255
  208448:	1004923a 	slli	r2,r2,8
  20844c:	1007883a 	mov	r3,r2
  208450:	e0bffe03 	ldbu	r2,-8(fp)
  208454:	10803fcc 	andi	r2,r2,255
  208458:	1884b03a 	or	r2,r3,r2
  20845c:	10bfffcc 	andi	r2,r2,65535
  208460:	00002306 	br	2084f0 <get_fat+0x14c>
#endif
#if _FS_FAT32
	case FS_FAT32 :
		if (disk_readp(buf, fs->fatbase + clst / 128, ((UINT)clst % 128) * 4, 4)) break;
  208464:	e0bffd17 	ldw	r2,-12(fp)
  208468:	10c00317 	ldw	r3,12(r2)
  20846c:	e0bfff17 	ldw	r2,-4(fp)
  208470:	1004d1fa 	srli	r2,r2,7
  208474:	1887883a 	add	r3,r3,r2
  208478:	e0bfff17 	ldw	r2,-4(fp)
  20847c:	10801fcc 	andi	r2,r2,127
  208480:	1085883a 	add	r2,r2,r2
  208484:	1085883a 	add	r2,r2,r2
  208488:	e13ffe04 	addi	r4,fp,-8
  20848c:	180b883a 	mov	r5,r3
  208490:	100d883a 	mov	r6,r2
  208494:	01c00104 	movi	r7,4
  208498:	02082280 	call	208228 <disk_readp>
  20849c:	10000126 	beq	r2,zero,2084a4 <get_fat+0x100>
  2084a0:	00001206 	br	2084ec <get_fat+0x148>
		return LD_DWORD(buf) & 0x0FFFFFFF;
  2084a4:	e0bffec3 	ldbu	r2,-5(fp)
  2084a8:	10803fcc 	andi	r2,r2,255
  2084ac:	1006963a 	slli	r3,r2,24
  2084b0:	e0bffe83 	ldbu	r2,-6(fp)
  2084b4:	10803fcc 	andi	r2,r2,255
  2084b8:	1004943a 	slli	r2,r2,16
  2084bc:	1886b03a 	or	r3,r3,r2
  2084c0:	e0bffe43 	ldbu	r2,-7(fp)
  2084c4:	10803fcc 	andi	r2,r2,255
  2084c8:	1004923a 	slli	r2,r2,8
  2084cc:	1886b03a 	or	r3,r3,r2
  2084d0:	e0bffe03 	ldbu	r2,-8(fp)
  2084d4:	10803fcc 	andi	r2,r2,255
  2084d8:	1886b03a 	or	r3,r3,r2
  2084dc:	00840034 	movhi	r2,4096
  2084e0:	10bfffc4 	addi	r2,r2,-1
  2084e4:	1884703a 	and	r2,r3,r2
  2084e8:	00000106 	br	2084f0 <get_fat+0x14c>
#endif
	}

	return 1;	/* An error occured at the disk I/O layer */
  2084ec:	00800044 	movi	r2,1
}
  2084f0:	e037883a 	mov	sp,fp
  2084f4:	dfc00117 	ldw	ra,4(sp)
  2084f8:	df000017 	ldw	fp,0(sp)
  2084fc:	dec00204 	addi	sp,sp,8
  208500:	f800283a 	ret

00208504 <clust2sect>:

static
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	CLUST clst		/* Cluster# to be converted */
)
{
  208504:	defffc04 	addi	sp,sp,-16
  208508:	dfc00315 	stw	ra,12(sp)
  20850c:	df000215 	stw	fp,8(sp)
  208510:	df000204 	addi	fp,sp,8
  208514:	e13fff15 	stw	r4,-4(fp)
	FATFS *fs = FatFs;
  208518:	d0a0c917 	ldw	r2,-31964(gp)
  20851c:	e0bffe15 	stw	r2,-8(fp)


	clst -= 2;
  208520:	e0bfff17 	ldw	r2,-4(fp)
  208524:	10bfff84 	addi	r2,r2,-2
  208528:	e0bfff15 	stw	r2,-4(fp)
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  20852c:	e0bffe17 	ldw	r2,-8(fp)
  208530:	10800217 	ldw	r2,8(r2)
  208534:	10bfff84 	addi	r2,r2,-2
  208538:	e0ffff17 	ldw	r3,-4(fp)
  20853c:	18800236 	bltu	r3,r2,208548 <clust2sect+0x44>
  208540:	0005883a 	mov	r2,zero
  208544:	00000a06 	br	208570 <clust2sect+0x6c>
	return (DWORD)clst * fs->csize + fs->database;
  208548:	e0bffe17 	ldw	r2,-8(fp)
  20854c:	10800083 	ldbu	r2,2(r2)
  208550:	10803fcc 	andi	r2,r2,255
  208554:	1009883a 	mov	r4,r2
  208558:	e17fff17 	ldw	r5,-4(fp)
  20855c:	020b50c0 	call	20b50c <__mulsi3>
  208560:	1007883a 	mov	r3,r2
  208564:	e0bffe17 	ldw	r2,-8(fp)
  208568:	10800517 	ldw	r2,20(r2)
  20856c:	1885883a 	add	r2,r3,r2
}
  208570:	e037883a 	mov	sp,fp
  208574:	dfc00117 	ldw	ra,4(sp)
  208578:	df000017 	ldw	fp,0(sp)
  20857c:	dec00204 	addi	sp,sp,8
  208580:	f800283a 	ret

00208584 <get_clust>:

static
CLUST get_clust (
	BYTE* dir		/* Pointer to directory entry */
)
{
  208584:	defffc04 	addi	sp,sp,-16
  208588:	df000315 	stw	fp,12(sp)
  20858c:	df000304 	addi	fp,sp,12
  208590:	e13fff15 	stw	r4,-4(fp)
	FATFS *fs = FatFs;
  208594:	d0a0c917 	ldw	r2,-31964(gp)
  208598:	e0bffe15 	stw	r2,-8(fp)
	CLUST clst = 0;
  20859c:	e03ffd15 	stw	zero,-12(fp)


	if (_FS_32ONLY || (_FS_FAT32 && fs->fs_type == FS_FAT32)) {
  2085a0:	e0bffe17 	ldw	r2,-8(fp)
  2085a4:	10800003 	ldbu	r2,0(r2)
  2085a8:	10803fcc 	andi	r2,r2,255
  2085ac:	108000d8 	cmpnei	r2,r2,3
  2085b0:	1000101e 	bne	r2,zero,2085f4 <get_clust+0x70>
		clst = LD_WORD(dir+DIR_FstClusHI);
  2085b4:	e0bfff17 	ldw	r2,-4(fp)
  2085b8:	10800544 	addi	r2,r2,21
  2085bc:	10800003 	ldbu	r2,0(r2)
  2085c0:	10803fcc 	andi	r2,r2,255
  2085c4:	1004923a 	slli	r2,r2,8
  2085c8:	1007883a 	mov	r3,r2
  2085cc:	e0bfff17 	ldw	r2,-4(fp)
  2085d0:	10800504 	addi	r2,r2,20
  2085d4:	10800003 	ldbu	r2,0(r2)
  2085d8:	10803fcc 	andi	r2,r2,255
  2085dc:	1884b03a 	or	r2,r3,r2
  2085e0:	10bfffcc 	andi	r2,r2,65535
  2085e4:	e0bffd15 	stw	r2,-12(fp)
		clst <<= 16;
  2085e8:	e0bffd17 	ldw	r2,-12(fp)
  2085ec:	1004943a 	slli	r2,r2,16
  2085f0:	e0bffd15 	stw	r2,-12(fp)
	}
	clst |= LD_WORD(dir+DIR_FstClusLO);
  2085f4:	e0bfff17 	ldw	r2,-4(fp)
  2085f8:	108006c4 	addi	r2,r2,27
  2085fc:	10800003 	ldbu	r2,0(r2)
  208600:	10803fcc 	andi	r2,r2,255
  208604:	1004923a 	slli	r2,r2,8
  208608:	1007883a 	mov	r3,r2
  20860c:	e0bfff17 	ldw	r2,-4(fp)
  208610:	10800684 	addi	r2,r2,26
  208614:	10800003 	ldbu	r2,0(r2)
  208618:	10803fcc 	andi	r2,r2,255
  20861c:	1884b03a 	or	r2,r3,r2
  208620:	10bfffcc 	andi	r2,r2,65535
  208624:	e0fffd17 	ldw	r3,-12(fp)
  208628:	1884b03a 	or	r2,r3,r2
  20862c:	e0bffd15 	stw	r2,-12(fp)

	return clst;
  208630:	e0bffd17 	ldw	r2,-12(fp)
}
  208634:	e037883a 	mov	sp,fp
  208638:	df000017 	ldw	fp,0(sp)
  20863c:	dec00104 	addi	sp,sp,4
  208640:	f800283a 	ret

00208644 <dir_rewind>:

static
FRESULT dir_rewind (
	DIR *dj			/* Pointer to directory object */
)
{
  208644:	defffb04 	addi	sp,sp,-20
  208648:	dfc00415 	stw	ra,16(sp)
  20864c:	df000315 	stw	fp,12(sp)
  208650:	df000304 	addi	fp,sp,12
  208654:	e13fff15 	stw	r4,-4(fp)
	CLUST clst;
	FATFS *fs = FatFs;
  208658:	d0a0c917 	ldw	r2,-31964(gp)
  20865c:	e0bffe15 	stw	r2,-8(fp)


	dj->index = 0;
  208660:	e0bfff17 	ldw	r2,-4(fp)
  208664:	1000000d 	sth	zero,0(r2)
	clst = dj->sclust;
  208668:	e0bfff17 	ldw	r2,-4(fp)
  20866c:	10800217 	ldw	r2,8(r2)
  208670:	e0bffd15 	stw	r2,-12(fp)
	if (clst == 1 || clst >= fs->n_fatent)	/* Check start cluster range */
  208674:	e0bffd17 	ldw	r2,-12(fp)
  208678:	10800060 	cmpeqi	r2,r2,1
  20867c:	1000041e 	bne	r2,zero,208690 <dir_rewind+0x4c>
  208680:	e0bffe17 	ldw	r2,-8(fp)
  208684:	10800217 	ldw	r2,8(r2)
  208688:	e0fffd17 	ldw	r3,-12(fp)
  20868c:	18800236 	bltu	r3,r2,208698 <dir_rewind+0x54>
		return FR_DISK_ERR;
  208690:	00800044 	movi	r2,1
  208694:	00001706 	br	2086f4 <dir_rewind+0xb0>
	if (_FS_FAT32 && !clst && (_FS_32ONLY || fs->fs_type == FS_FAT32))	/* Replace cluster# 0 with root cluster# if in FAT32 */
  208698:	e0bffd17 	ldw	r2,-12(fp)
  20869c:	1000081e 	bne	r2,zero,2086c0 <dir_rewind+0x7c>
  2086a0:	e0bffe17 	ldw	r2,-8(fp)
  2086a4:	10800003 	ldbu	r2,0(r2)
  2086a8:	10803fcc 	andi	r2,r2,255
  2086ac:	108000d8 	cmpnei	r2,r2,3
  2086b0:	1000031e 	bne	r2,zero,2086c0 <dir_rewind+0x7c>
		clst = (CLUST)fs->dirbase;
  2086b4:	e0bffe17 	ldw	r2,-8(fp)
  2086b8:	10800417 	ldw	r2,16(r2)
  2086bc:	e0bffd15 	stw	r2,-12(fp)
	dj->clust = clst;						/* Current cluster */
  2086c0:	e0bfff17 	ldw	r2,-4(fp)
  2086c4:	e0fffd17 	ldw	r3,-12(fp)
  2086c8:	10c00315 	stw	r3,12(r2)
	dj->sect = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase;	/* Current sector */
  2086cc:	e0bffd17 	ldw	r2,-12(fp)
  2086d0:	10000326 	beq	r2,zero,2086e0 <dir_rewind+0x9c>
  2086d4:	e13ffd17 	ldw	r4,-12(fp)
  2086d8:	02085040 	call	208504 <clust2sect>
  2086dc:	00000206 	br	2086e8 <dir_rewind+0xa4>
  2086e0:	e0bffe17 	ldw	r2,-8(fp)
  2086e4:	10800417 	ldw	r2,16(r2)
  2086e8:	e0ffff17 	ldw	r3,-4(fp)
  2086ec:	18800415 	stw	r2,16(r3)

	return FR_OK;	/* Seek succeeded */
  2086f0:	0005883a 	mov	r2,zero
}
  2086f4:	e037883a 	mov	sp,fp
  2086f8:	dfc00117 	ldw	ra,4(sp)
  2086fc:	df000017 	ldw	fp,0(sp)
  208700:	dec00204 	addi	sp,sp,8
  208704:	f800283a 	ret

00208708 <dir_next2>:

static
FRESULT dir_next2 (	/* FR_OK:Succeeded, FR_NO_FILE:End of table */
	DIR *dj			/* Pointer to directory object */
)
{
  208708:	defffa04 	addi	sp,sp,-24
  20870c:	dfc00515 	stw	ra,20(sp)
  208710:	df000415 	stw	fp,16(sp)
  208714:	df000404 	addi	fp,sp,16
  208718:	e13fff15 	stw	r4,-4(fp)
	CLUST clst;
	WORD i;
	FATFS *fs = FatFs;
  20871c:	d0a0c917 	ldw	r2,-31964(gp)
  208720:	e0bffc15 	stw	r2,-16(fp)


	i = dj->index + 1;
  208724:	e0bfff17 	ldw	r2,-4(fp)
  208728:	1080000b 	ldhu	r2,0(r2)
  20872c:	10800044 	addi	r2,r2,1
  208730:	e0bffd0d 	sth	r2,-12(fp)
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  208734:	e0bffd0b 	ldhu	r2,-12(fp)
  208738:	10000326 	beq	r2,zero,208748 <dir_next2+0x40>
  20873c:	e0bfff17 	ldw	r2,-4(fp)
  208740:	10800417 	ldw	r2,16(r2)
  208744:	1000021e 	bne	r2,zero,208750 <dir_next2+0x48>
		return FR_NO_FILE;
  208748:	008000c4 	movi	r2,3
  20874c:	00003806 	br	208830 <dir_next2+0x128>

	if (!(i % 16)) {		/* Sector changed? */
  208750:	e0bffd0b 	ldhu	r2,-12(fp)
  208754:	108003cc 	andi	r2,r2,15
  208758:	10bfffcc 	andi	r2,r2,65535
  20875c:	1000301e 	bne	r2,zero,208820 <dir_next2+0x118>
		dj->sect++;			/* Next sector */
  208760:	e0bfff17 	ldw	r2,-4(fp)
  208764:	10800417 	ldw	r2,16(r2)
  208768:	10c00044 	addi	r3,r2,1
  20876c:	e0bfff17 	ldw	r2,-4(fp)
  208770:	10c00415 	stw	r3,16(r2)

		if (dj->clust == 0) {	/* Static table */
  208774:	e0bfff17 	ldw	r2,-4(fp)
  208778:	10800317 	ldw	r2,12(r2)
  20877c:	1000071e 	bne	r2,zero,20879c <dir_next2+0x94>
			if (i >= fs->n_rootdir)	/* Report EOT when end of table */
  208780:	e0bffc17 	ldw	r2,-16(fp)
  208784:	1080010b 	ldhu	r2,4(r2)
  208788:	10bfffcc 	andi	r2,r2,65535
  20878c:	e0fffd0b 	ldhu	r3,-12(fp)
  208790:	18802336 	bltu	r3,r2,208820 <dir_next2+0x118>
				return FR_NO_FILE;
  208794:	008000c4 	movi	r2,3
  208798:	00002506 	br	208830 <dir_next2+0x128>
		}
		else {					/* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
  20879c:	e0bffd0b 	ldhu	r2,-12(fp)
  2087a0:	1004d13a 	srli	r2,r2,4
  2087a4:	10ffffcc 	andi	r3,r2,65535
  2087a8:	e0bffc17 	ldw	r2,-16(fp)
  2087ac:	10800083 	ldbu	r2,2(r2)
  2087b0:	10803fcc 	andi	r2,r2,255
  2087b4:	10bfffc4 	addi	r2,r2,-1
  2087b8:	1884703a 	and	r2,r3,r2
  2087bc:	1000181e 	bne	r2,zero,208820 <dir_next2+0x118>
				clst = get_fat(dj->clust);		/* Get next cluster */
  2087c0:	e0bfff17 	ldw	r2,-4(fp)
  2087c4:	10800317 	ldw	r2,12(r2)
  2087c8:	1009883a 	mov	r4,r2
  2087cc:	02083a40 	call	2083a4 <get_fat>
  2087d0:	e0bffe15 	stw	r2,-8(fp)
				if (clst <= 1) return FR_DISK_ERR;
  2087d4:	e0bffe17 	ldw	r2,-8(fp)
  2087d8:	108000a8 	cmpgeui	r2,r2,2
  2087dc:	1000021e 	bne	r2,zero,2087e8 <dir_next2+0xe0>
  2087e0:	00800044 	movi	r2,1
  2087e4:	00001206 	br	208830 <dir_next2+0x128>
				if (clst >= fs->n_fatent)		/* When it reached end of dynamic table */
  2087e8:	e0bffc17 	ldw	r2,-16(fp)
  2087ec:	10800217 	ldw	r2,8(r2)
  2087f0:	e0fffe17 	ldw	r3,-8(fp)
  2087f4:	18800236 	bltu	r3,r2,208800 <dir_next2+0xf8>
					return FR_NO_FILE;			/* Report EOT */
  2087f8:	008000c4 	movi	r2,3
  2087fc:	00000c06 	br	208830 <dir_next2+0x128>
				dj->clust = clst;				/* Initialize data for new cluster */
  208800:	e0bfff17 	ldw	r2,-4(fp)
  208804:	e0fffe17 	ldw	r3,-8(fp)
  208808:	10c00315 	stw	r3,12(r2)
				dj->sect = clust2sect(clst);
  20880c:	e13ffe17 	ldw	r4,-8(fp)
  208810:	02085040 	call	208504 <clust2sect>
  208814:	1007883a 	mov	r3,r2
  208818:	e0bfff17 	ldw	r2,-4(fp)
  20881c:	10c00415 	stw	r3,16(r2)
			}
		}
	}

	dj->index = i;
  208820:	e0bfff17 	ldw	r2,-4(fp)
  208824:	e0fffd0b 	ldhu	r3,-12(fp)
  208828:	10c0000d 	sth	r3,0(r2)

	return FR_OK;
  20882c:	0005883a 	mov	r2,zero
}
  208830:	e037883a 	mov	sp,fp
  208834:	dfc00117 	ldw	ra,4(sp)
  208838:	df000017 	ldw	fp,0(sp)
  20883c:	dec00204 	addi	sp,sp,8
  208840:	f800283a 	ret

00208844 <dir_find>:
static
FRESULT dir_find (
	DIR *dj,		/* Pointer to the directory object linked to the file name */
	BYTE *dir		/* 32-byte working buffer */
)
{
  208844:	defffa04 	addi	sp,sp,-24
  208848:	dfc00515 	stw	ra,20(sp)
  20884c:	df000415 	stw	fp,16(sp)
  208850:	df000404 	addi	fp,sp,16
  208854:	e13ffe15 	stw	r4,-8(fp)
  208858:	e17fff15 	stw	r5,-4(fp)
	FRESULT res;
	BYTE c;


	res = dir_rewind(dj);			/* Rewind directory object */
  20885c:	e13ffe17 	ldw	r4,-8(fp)
  208860:	02086440 	call	208644 <dir_rewind>
  208864:	e0bffc15 	stw	r2,-16(fp)
	if (res != FR_OK) return res;
  208868:	e0bffc17 	ldw	r2,-16(fp)
  20886c:	10000226 	beq	r2,zero,208878 <dir_find+0x34>
  208870:	e0bffc17 	ldw	r2,-16(fp)
  208874:	00002e06 	br	208930 <dir_find+0xec>

	do {
		res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32)	/* Read an entry */
  208878:	e0bffe17 	ldw	r2,-8(fp)
  20887c:	10c00417 	ldw	r3,16(r2)
  208880:	e0bffe17 	ldw	r2,-8(fp)
  208884:	1080000b 	ldhu	r2,0(r2)
  208888:	10bfffcc 	andi	r2,r2,65535
  20888c:	108003cc 	andi	r2,r2,15
  208890:	1004917a 	slli	r2,r2,5
  208894:	e13fff17 	ldw	r4,-4(fp)
  208898:	180b883a 	mov	r5,r3
  20889c:	100d883a 	mov	r6,r2
  2088a0:	01c00804 	movi	r7,32
  2088a4:	02082280 	call	208228 <disk_readp>
			? FR_DISK_ERR : FR_OK;
  2088a8:	1004c03a 	cmpne	r2,r2,zero

	res = dir_rewind(dj);			/* Rewind directory object */
	if (res != FR_OK) return res;

	do {
		res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32)	/* Read an entry */
  2088ac:	10803fcc 	andi	r2,r2,255
  2088b0:	e0bffc15 	stw	r2,-16(fp)
			? FR_DISK_ERR : FR_OK;
		if (res != FR_OK) break;
  2088b4:	e0bffc17 	ldw	r2,-16(fp)
  2088b8:	10000126 	beq	r2,zero,2088c0 <dir_find+0x7c>
  2088bc:	00001b06 	br	20892c <dir_find+0xe8>
		c = dir[DIR_Name];	/* First character */
  2088c0:	e0bfff17 	ldw	r2,-4(fp)
  2088c4:	10800003 	ldbu	r2,0(r2)
  2088c8:	e0bffd05 	stb	r2,-12(fp)
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  2088cc:	e0bffd03 	ldbu	r2,-12(fp)
  2088d0:	1000031e 	bne	r2,zero,2088e0 <dir_find+0x9c>
  2088d4:	008000c4 	movi	r2,3
  2088d8:	e0bffc15 	stw	r2,-16(fp)
  2088dc:	00001306 	br	20892c <dir_find+0xe8>
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
  2088e0:	e0bfff17 	ldw	r2,-4(fp)
  2088e4:	108002c4 	addi	r2,r2,11
  2088e8:	10800003 	ldbu	r2,0(r2)
  2088ec:	10803fcc 	andi	r2,r2,255
  2088f0:	1080020c 	andi	r2,r2,8
  2088f4:	1000081e 	bne	r2,zero,208918 <dir_find+0xd4>
  2088f8:	e0bffe17 	ldw	r2,-8(fp)
  2088fc:	10800117 	ldw	r2,4(r2)
  208900:	e13fff17 	ldw	r4,-4(fp)
  208904:	100b883a 	mov	r5,r2
  208908:	018002c4 	movi	r6,11
  20890c:	02083080 	call	208308 <mem_cmp>
  208910:	1000011e 	bne	r2,zero,208918 <dir_find+0xd4>
			break;
  208914:	00000506 	br	20892c <dir_find+0xe8>
		res = dir_next2(dj);					/* Next entry */
  208918:	e13ffe17 	ldw	r4,-8(fp)
  20891c:	02087080 	call	208708 <dir_next2>
  208920:	e0bffc15 	stw	r2,-16(fp)
	} while (res == FR_OK);
  208924:	e0bffc17 	ldw	r2,-16(fp)
  208928:	103fd326 	beq	r2,zero,208878 <_gp+0xffff2c88>

	return res;
  20892c:	e0bffc17 	ldw	r2,-16(fp)
}
  208930:	e037883a 	mov	sp,fp
  208934:	dfc00117 	ldw	ra,4(sp)
  208938:	df000017 	ldw	fp,0(sp)
  20893c:	dec00204 	addi	sp,sp,8
  208940:	f800283a 	ret

00208944 <dir_read>:
FRESULT dir_read (
	DIR *dj,		/* Pointer to the directory object to store read object name */
	BYTE *dir,		/* 32-byte working buffer */
	char *lfn_buffer        /* 256-byte lfn buffer */
)
{
  208944:	defff504 	addi	sp,sp,-44
  208948:	dfc00a15 	stw	ra,40(sp)
  20894c:	df000915 	stw	fp,36(sp)
  208950:	df000904 	addi	fp,sp,36
  208954:	e13ffd15 	stw	r4,-12(fp)
  208958:	e17ffe15 	stw	r5,-8(fp)
  20895c:	e1bfff15 	stw	r6,-4(fp)
	FRESULT res;
	BYTE a, c;

	int lfn = 0;
  208960:	e03ff815 	stw	zero,-32(fp)
	char *lfn_pos = &lfn_buffer[255];
  208964:	e0bfff17 	ldw	r2,-4(fp)
  208968:	10803fc4 	addi	r2,r2,255
  20896c:	e0bff915 	stw	r2,-28(fp)
	lfn_buffer[255] = '\0';
  208970:	e0bfff17 	ldw	r2,-4(fp)
  208974:	10803fc4 	addi	r2,r2,255
  208978:	10000005 	stb	zero,0(r2)

	res = FR_NO_FILE;
  20897c:	008000c4 	movi	r2,3
  208980:	e0bff715 	stw	r2,-36(fp)
	while (dj->sect) {
  208984:	00006f06 	br	208b44 <dir_read+0x200>
		res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32)	/* Read an entry */
  208988:	e0bffd17 	ldw	r2,-12(fp)
  20898c:	10c00417 	ldw	r3,16(r2)
  208990:	e0bffd17 	ldw	r2,-12(fp)
  208994:	1080000b 	ldhu	r2,0(r2)
  208998:	10bfffcc 	andi	r2,r2,65535
  20899c:	108003cc 	andi	r2,r2,15
  2089a0:	1004917a 	slli	r2,r2,5
  2089a4:	e13ffe17 	ldw	r4,-8(fp)
  2089a8:	180b883a 	mov	r5,r3
  2089ac:	100d883a 	mov	r6,r2
  2089b0:	01c00804 	movi	r7,32
  2089b4:	02082280 	call	208228 <disk_readp>
			? FR_DISK_ERR : FR_OK;
  2089b8:	1004c03a 	cmpne	r2,r2,zero
	char *lfn_pos = &lfn_buffer[255];
	lfn_buffer[255] = '\0';

	res = FR_NO_FILE;
	while (dj->sect) {
		res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32)	/* Read an entry */
  2089bc:	10803fcc 	andi	r2,r2,255
  2089c0:	e0bff715 	stw	r2,-36(fp)
			? FR_DISK_ERR : FR_OK;
		if (res != FR_OK) break;
  2089c4:	e0bff717 	ldw	r2,-36(fp)
  2089c8:	10000126 	beq	r2,zero,2089d0 <dir_read+0x8c>
  2089cc:	00006006 	br	208b50 <dir_read+0x20c>
		c = dir[DIR_Name];
  2089d0:	e0bffe17 	ldw	r2,-8(fp)
  2089d4:	10800003 	ldbu	r2,0(r2)
  2089d8:	e0bffc05 	stb	r2,-16(fp)
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  2089dc:	e0bffc03 	ldbu	r2,-16(fp)
  2089e0:	1000031e 	bne	r2,zero,2089f0 <dir_read+0xac>
  2089e4:	008000c4 	movi	r2,3
  2089e8:	e0bff715 	stw	r2,-36(fp)
  2089ec:	00005806 	br	208b50 <dir_read+0x20c>
		a = dir[DIR_Attr] & AM_MASK;
  2089f0:	e0bffe17 	ldw	r2,-8(fp)
  2089f4:	108002c4 	addi	r2,r2,11
  2089f8:	10800003 	ldbu	r2,0(r2)
  2089fc:	10800fcc 	andi	r2,r2,63
  208a00:	e0bffc45 	stb	r2,-15(fp)

	//	printf("LFN2:%x:%x:%x:%x\n",a&AM_LFN==AM_LFN,dir[0],dir[0x1a],dir[0x1c]);
		if (a&AM_LFN == AM_LFN && ((dir[0]&0xbf) < 16) && dir[0x1a]==0) // && dir[0x1c]!=0)
  208a04:	e0bffc43 	ldbu	r2,-15(fp)
  208a08:	1080004c 	andi	r2,r2,1
  208a0c:	10003d26 	beq	r2,zero,208b04 <dir_read+0x1c0>
  208a10:	e0bffe17 	ldw	r2,-8(fp)
  208a14:	10800003 	ldbu	r2,0(r2)
  208a18:	10803fcc 	andi	r2,r2,255
  208a1c:	10802fcc 	andi	r2,r2,191
  208a20:	10800408 	cmpgei	r2,r2,16
  208a24:	1000371e 	bne	r2,zero,208b04 <dir_read+0x1c0>
  208a28:	e0bffe17 	ldw	r2,-8(fp)
  208a2c:	10800684 	addi	r2,r2,26
  208a30:	10800003 	ldbu	r2,0(r2)
  208a34:	10803fcc 	andi	r2,r2,255
  208a38:	1000321e 	bne	r2,zero,208b04 <dir_read+0x1c0>
		{
			lfn_pos-=13;
  208a3c:	e0bff917 	ldw	r2,-28(fp)
  208a40:	10bffcc4 	addi	r2,r2,-13
  208a44:	e0bff915 	stw	r2,-28(fp)
			char * ptr = lfn_pos;
  208a48:	e0bff917 	ldw	r2,-28(fp)
  208a4c:	e0bffa15 	stw	r2,-24(fp)
			int i;
			for (i=1;i!=32;i+=2)
  208a50:	00800044 	movi	r2,1
  208a54:	e0bffb15 	stw	r2,-20(fp)
  208a58:	00002506 	br	208af0 <dir_read+0x1ac>
			{
				if (i==0xb) i=0xe;
  208a5c:	e0bffb17 	ldw	r2,-20(fp)
  208a60:	108002d8 	cmpnei	r2,r2,11
  208a64:	1000021e 	bne	r2,zero,208a70 <dir_read+0x12c>
  208a68:	00800384 	movi	r2,14
  208a6c:	e0bffb15 	stw	r2,-20(fp)
				if (i==0x1a) i=0x1c;
  208a70:	e0bffb17 	ldw	r2,-20(fp)
  208a74:	10800698 	cmpnei	r2,r2,26
  208a78:	1000021e 	bne	r2,zero,208a84 <dir_read+0x140>
  208a7c:	00800704 	movi	r2,28
  208a80:	e0bffb15 	stw	r2,-20(fp)
				char b1 = dir[i];
  208a84:	e0bffb17 	ldw	r2,-20(fp)
  208a88:	e0fffe17 	ldw	r3,-8(fp)
  208a8c:	1885883a 	add	r2,r3,r2
  208a90:	10800003 	ldbu	r2,0(r2)
  208a94:	e0bffc85 	stb	r2,-14(fp)
				char b2 = dir[i+1];
  208a98:	e0bffb17 	ldw	r2,-20(fp)
  208a9c:	10800044 	addi	r2,r2,1
  208aa0:	e0fffe17 	ldw	r3,-8(fp)
  208aa4:	1885883a 	add	r2,r3,r2
  208aa8:	10800003 	ldbu	r2,0(r2)
  208aac:	e0bffcc5 	stb	r2,-13(fp)
				if (b2==0) *ptr++ = b1; else *ptr++ = '_';
  208ab0:	e0bffcc7 	ldb	r2,-13(fp)
  208ab4:	1000061e 	bne	r2,zero,208ad0 <dir_read+0x18c>
  208ab8:	e0bffa17 	ldw	r2,-24(fp)
  208abc:	10c00044 	addi	r3,r2,1
  208ac0:	e0fffa15 	stw	r3,-24(fp)
  208ac4:	e0fffc83 	ldbu	r3,-14(fp)
  208ac8:	10c00005 	stb	r3,0(r2)
  208acc:	00000506 	br	208ae4 <dir_read+0x1a0>
  208ad0:	e0bffa17 	ldw	r2,-24(fp)
  208ad4:	10c00044 	addi	r3,r2,1
  208ad8:	e0fffa15 	stw	r3,-24(fp)
  208adc:	00c017c4 	movi	r3,95
  208ae0:	10c00005 	stb	r3,0(r2)
		if (a&AM_LFN == AM_LFN && ((dir[0]&0xbf) < 16) && dir[0x1a]==0) // && dir[0x1c]!=0)
		{
			lfn_pos-=13;
			char * ptr = lfn_pos;
			int i;
			for (i=1;i!=32;i+=2)
  208ae4:	e0bffb17 	ldw	r2,-20(fp)
  208ae8:	10800084 	addi	r2,r2,2
  208aec:	e0bffb15 	stw	r2,-20(fp)
  208af0:	e0bffb17 	ldw	r2,-20(fp)
  208af4:	10800818 	cmpnei	r2,r2,32
  208af8:	103fd81e 	bne	r2,zero,208a5c <_gp+0xffff2e6c>
				char b1 = dir[i];
				char b2 = dir[i+1];
				if (b2==0) *ptr++ = b1; else *ptr++ = '_';
			}
			//printf("LFN seq:%d %c%c%c%c%c%c%c%c%c%c%c%c%c \n",dir[0],dir[1],dir[3],dir[5],dir[7],dir[9],dir[14],dir[16],dir[18],dir[20],dir[22],dir[24],dir[28],dir[30]);
			lfn = 1;
  208afc:	00800044 	movi	r2,1
  208b00:	e0bff815 	stw	r2,-32(fp)
		}


		if (c != 0xE5 && c != '.' && !(a & AM_VOL))	/* Is it a valid entry? */
  208b04:	e0bffc03 	ldbu	r2,-16(fp)
  208b08:	10803960 	cmpeqi	r2,r2,229
  208b0c:	1000071e 	bne	r2,zero,208b2c <dir_read+0x1e8>
  208b10:	e0bffc03 	ldbu	r2,-16(fp)
  208b14:	10800ba0 	cmpeqi	r2,r2,46
  208b18:	1000041e 	bne	r2,zero,208b2c <dir_read+0x1e8>
  208b1c:	e0bffc43 	ldbu	r2,-15(fp)
  208b20:	1080020c 	andi	r2,r2,8
  208b24:	1000011e 	bne	r2,zero,208b2c <dir_read+0x1e8>
			break;
  208b28:	00000906 	br	208b50 <dir_read+0x20c>
		res = dir_next2(dj);			/* Next entry */
  208b2c:	e13ffd17 	ldw	r4,-12(fp)
  208b30:	02087080 	call	208708 <dir_next2>
  208b34:	e0bff715 	stw	r2,-36(fp)
		if (res != FR_OK) break;
  208b38:	e0bff717 	ldw	r2,-36(fp)
  208b3c:	10000126 	beq	r2,zero,208b44 <dir_read+0x200>
  208b40:	00000306 	br	208b50 <dir_read+0x20c>
	int lfn = 0;
	char *lfn_pos = &lfn_buffer[255];
	lfn_buffer[255] = '\0';

	res = FR_NO_FILE;
	while (dj->sect) {
  208b44:	e0bffd17 	ldw	r2,-12(fp)
  208b48:	10800417 	ldw	r2,16(r2)
  208b4c:	103f8e1e 	bne	r2,zero,208988 <_gp+0xffff2d98>
			break;
		res = dir_next2(dj);			/* Next entry */
		if (res != FR_OK) break;
	}

	lfn_buffer[0] = '\0';
  208b50:	e0bfff17 	ldw	r2,-4(fp)
  208b54:	10000005 	stb	zero,0(r2)
	if (lfn)
  208b58:	e0bff817 	ldw	r2,-32(fp)
  208b5c:	10000326 	beq	r2,zero,208b6c <dir_read+0x228>
	{
		strcpy(&lfn_buffer[0],lfn_pos);
  208b60:	e13fff17 	ldw	r4,-4(fp)
  208b64:	e17ff917 	ldw	r5,-28(fp)
  208b68:	020bb740 	call	20bb74 <strcpy>
	}

	if (res != FR_OK) dj->sect = 0;
  208b6c:	e0bff717 	ldw	r2,-36(fp)
  208b70:	10000226 	beq	r2,zero,208b7c <dir_read+0x238>
  208b74:	e0bffd17 	ldw	r2,-12(fp)
  208b78:	10000415 	stw	zero,16(r2)

	return res;
  208b7c:	e0bff717 	ldw	r2,-36(fp)
}
  208b80:	e037883a 	mov	sp,fp
  208b84:	dfc00117 	ldw	ra,4(sp)
  208b88:	df000017 	ldw	fp,0(sp)
  208b8c:	dec00204 	addi	sp,sp,8
  208b90:	f800283a 	ret

00208b94 <create_name>:
static
FRESULT create_name (
	DIR *dj,			/* Pointer to the directory object */
	const char **path	/* Pointer to pointer to the segment in the path string */
)
{
  208b94:	defff904 	addi	sp,sp,-28
  208b98:	dfc00615 	stw	ra,24(sp)
  208b9c:	df000515 	stw	fp,20(sp)
  208ba0:	df000504 	addi	fp,sp,20
  208ba4:	e13ffe15 	stw	r4,-8(fp)
  208ba8:	e17fff15 	stw	r5,-4(fp)
	static const BYTE cvt[] = _EXCVT;
#endif
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
  208bac:	e0bffe17 	ldw	r2,-8(fp)
  208bb0:	10800117 	ldw	r2,4(r2)
  208bb4:	e0bffc15 	stw	r2,-16(fp)
	mem_set(sfn, ' ', 11);
  208bb8:	e13ffc17 	ldw	r4,-16(fp)
  208bbc:	01400804 	movi	r5,32
  208bc0:	018002c4 	movi	r6,11
  208bc4:	02082b00 	call	2082b0 <mem_set>
	si = i = 0; ni = 8;
  208bc8:	e03ffbc5 	stb	zero,-17(fp)
  208bcc:	e0bffbc3 	ldbu	r2,-17(fp)
  208bd0:	e0bffb85 	stb	r2,-18(fp)
  208bd4:	00800204 	movi	r2,8
  208bd8:	e0bffb45 	stb	r2,-19(fp)
	p = *path;
  208bdc:	e0bfff17 	ldw	r2,-4(fp)
  208be0:	10800017 	ldw	r2,0(r2)
  208be4:	e0bffd15 	stw	r2,-12(fp)
	for (;;) {
		c = p[si++];
  208be8:	e0bffb83 	ldbu	r2,-18(fp)
  208bec:	10c00044 	addi	r3,r2,1
  208bf0:	e0fffb85 	stb	r3,-18(fp)
  208bf4:	10803fcc 	andi	r2,r2,255
  208bf8:	e0fffd17 	ldw	r3,-12(fp)
  208bfc:	1885883a 	add	r2,r3,r2
  208c00:	10800003 	ldbu	r2,0(r2)
  208c04:	e0bffb05 	stb	r2,-20(fp)
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
  208c08:	e0bffb03 	ldbu	r2,-20(fp)
  208c0c:	10800870 	cmpltui	r2,r2,33
  208c10:	1000331e 	bne	r2,zero,208ce0 <create_name+0x14c>
  208c14:	e0bffb03 	ldbu	r2,-20(fp)
  208c18:	10800be0 	cmpeqi	r2,r2,47
  208c1c:	1000301e 	bne	r2,zero,208ce0 <create_name+0x14c>
		if (c == '.' || i >= ni) {
  208c20:	e0bffb03 	ldbu	r2,-20(fp)
  208c24:	10800ba0 	cmpeqi	r2,r2,46
  208c28:	1000031e 	bne	r2,zero,208c38 <create_name+0xa4>
  208c2c:	e0fffbc3 	ldbu	r3,-17(fp)
  208c30:	e0bffb43 	ldbu	r2,-19(fp)
  208c34:	18800c36 	bltu	r3,r2,208c68 <create_name+0xd4>
			if (ni != 8 || c != '.') break;
  208c38:	e0bffb43 	ldbu	r2,-19(fp)
  208c3c:	10800218 	cmpnei	r2,r2,8
  208c40:	1000271e 	bne	r2,zero,208ce0 <create_name+0x14c>
  208c44:	e0bffb03 	ldbu	r2,-20(fp)
  208c48:	10800b98 	cmpnei	r2,r2,46
  208c4c:	1000241e 	bne	r2,zero,208ce0 <create_name+0x14c>
			i = 8; ni = 11;
  208c50:	00800204 	movi	r2,8
  208c54:	e0bffbc5 	stb	r2,-17(fp)
  208c58:	008002c4 	movi	r2,11
  208c5c:	e0bffb45 	stb	r2,-19(fp)
			continue;
  208c60:	0001883a 	nop
#endif
		{						/* Single byte code */
			if (_USE_LCC && IsLower(c)) c -= 0x20;	/* toupper */
			sfn[i++] = c;
		}
	}
  208c64:	003fe006 	br	208be8 <_gp+0xffff2ff8>
			i = 8; ni = 11;
			continue;
		}
#if _USE_LCC
#ifdef _EXCVT
		if (c >= 0x80)					/* To upper extended char (SBCS) */
  208c68:	e0bffb03 	ldbu	r2,-20(fp)
  208c6c:	10803fcc 	andi	r2,r2,255
  208c70:	1080201c 	xori	r2,r2,128
  208c74:	10bfe004 	addi	r2,r2,-128
  208c78:	1000070e 	bge	r2,zero,208c98 <create_name+0x104>
			c = cvt[c - 0x80];
  208c7c:	e0bffb03 	ldbu	r2,-20(fp)
  208c80:	10bfe004 	addi	r2,r2,-128
  208c84:	00c00874 	movhi	r3,33
  208c88:	18f55d04 	addi	r3,r3,-10892
  208c8c:	1885883a 	add	r2,r3,r2
  208c90:	10800003 	ldbu	r2,0(r2)
  208c94:	e0bffb05 	stb	r2,-20(fp)
			sfn[i++] = c;
			sfn[i++] = d;
		} else
#endif
		{						/* Single byte code */
			if (_USE_LCC && IsLower(c)) c -= 0x20;	/* toupper */
  208c98:	e0bffb03 	ldbu	r2,-20(fp)
  208c9c:	10801870 	cmpltui	r2,r2,97
  208ca0:	1000061e 	bne	r2,zero,208cbc <create_name+0x128>
  208ca4:	e0bffb03 	ldbu	r2,-20(fp)
  208ca8:	10801ee8 	cmpgeui	r2,r2,123
  208cac:	1000031e 	bne	r2,zero,208cbc <create_name+0x128>
  208cb0:	e0bffb03 	ldbu	r2,-20(fp)
  208cb4:	10bff804 	addi	r2,r2,-32
  208cb8:	e0bffb05 	stb	r2,-20(fp)
			sfn[i++] = c;
  208cbc:	e0bffbc3 	ldbu	r2,-17(fp)
  208cc0:	10c00044 	addi	r3,r2,1
  208cc4:	e0fffbc5 	stb	r3,-17(fp)
  208cc8:	10803fcc 	andi	r2,r2,255
  208ccc:	e0fffc17 	ldw	r3,-16(fp)
  208cd0:	1885883a 	add	r2,r3,r2
  208cd4:	e0fffb03 	ldbu	r3,-20(fp)
  208cd8:	10c00005 	stb	r3,0(r2)
		}
	}
  208cdc:	003fc206 	br	208be8 <_gp+0xffff2ff8>
	*path = &p[si];						/* Rerurn pointer to the next segment */
  208ce0:	e0bffb83 	ldbu	r2,-18(fp)
  208ce4:	e0fffd17 	ldw	r3,-12(fp)
  208ce8:	1887883a 	add	r3,r3,r2
  208cec:	e0bfff17 	ldw	r2,-4(fp)
  208cf0:	10c00015 	stw	r3,0(r2)

	sfn[11] = (c <= ' ') ? 1 : 0;		/* Set last segment flag if end of path */
  208cf4:	e0bffc17 	ldw	r2,-16(fp)
  208cf8:	108002c4 	addi	r2,r2,11
  208cfc:	e0fffb03 	ldbu	r3,-20(fp)
  208d00:	18c00870 	cmpltui	r3,r3,33
  208d04:	10c00005 	stb	r3,0(r2)

	return FR_OK;
  208d08:	0005883a 	mov	r2,zero
}
  208d0c:	e037883a 	mov	sp,fp
  208d10:	dfc00117 	ldw	ra,4(sp)
  208d14:	df000017 	ldw	fp,0(sp)
  208d18:	dec00204 	addi	sp,sp,8
  208d1c:	f800283a 	ret

00208d20 <get_fileinfo>:
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	BYTE *dir,			/* 32-byte working buffer */
	FILINFO *fno	 	/* Pointer to store the file information */
)
{
  208d20:	defffa04 	addi	sp,sp,-24
  208d24:	df000515 	stw	fp,20(sp)
  208d28:	df000504 	addi	fp,sp,20
  208d2c:	e13ffd15 	stw	r4,-12(fp)
  208d30:	e17ffe15 	stw	r5,-8(fp)
  208d34:	e1bfff15 	stw	r6,-4(fp)
	BYTE i, c;
	char *p;


	p = fno->fname;
  208d38:	e0bfff17 	ldw	r2,-4(fp)
  208d3c:	10800244 	addi	r2,r2,9
  208d40:	e0bffc15 	stw	r2,-16(fp)
	if (dj->sect) {
  208d44:	e0bffd17 	ldw	r2,-12(fp)
  208d48:	10800417 	ldw	r2,16(r2)
  208d4c:	10007526 	beq	r2,zero,208f24 <get_fileinfo+0x204>
		for (i = 0; i < 8; i++) {	/* Copy file name body */
  208d50:	e03ffb05 	stb	zero,-20(fp)
  208d54:	00001606 	br	208db0 <get_fileinfo+0x90>
			c = dir[i];
  208d58:	e0bffb03 	ldbu	r2,-20(fp)
  208d5c:	e0fffe17 	ldw	r3,-8(fp)
  208d60:	1885883a 	add	r2,r3,r2
  208d64:	10800003 	ldbu	r2,0(r2)
  208d68:	e0bffb45 	stb	r2,-19(fp)
			if (c == ' ') break;
  208d6c:	e0bffb43 	ldbu	r2,-19(fp)
  208d70:	10800818 	cmpnei	r2,r2,32
  208d74:	1000011e 	bne	r2,zero,208d7c <get_fileinfo+0x5c>
  208d78:	00001006 	br	208dbc <get_fileinfo+0x9c>
			if (c == 0x05) c = 0xE5;
  208d7c:	e0bffb43 	ldbu	r2,-19(fp)
  208d80:	10800158 	cmpnei	r2,r2,5
  208d84:	1000021e 	bne	r2,zero,208d90 <get_fileinfo+0x70>
  208d88:	00bff944 	movi	r2,-27
  208d8c:	e0bffb45 	stb	r2,-19(fp)
			*p++ = c;
  208d90:	e0bffc17 	ldw	r2,-16(fp)
  208d94:	10c00044 	addi	r3,r2,1
  208d98:	e0fffc15 	stw	r3,-16(fp)
  208d9c:	e0fffb43 	ldbu	r3,-19(fp)
  208da0:	10c00005 	stb	r3,0(r2)
	char *p;


	p = fno->fname;
	if (dj->sect) {
		for (i = 0; i < 8; i++) {	/* Copy file name body */
  208da4:	e0bffb03 	ldbu	r2,-20(fp)
  208da8:	10800044 	addi	r2,r2,1
  208dac:	e0bffb05 	stb	r2,-20(fp)
  208db0:	e0bffb03 	ldbu	r2,-20(fp)
  208db4:	10800230 	cmpltui	r2,r2,8
  208db8:	103fe71e 	bne	r2,zero,208d58 <_gp+0xffff3168>
			c = dir[i];
			if (c == ' ') break;
			if (c == 0x05) c = 0xE5;
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy file name extension */
  208dbc:	e0bffe17 	ldw	r2,-8(fp)
  208dc0:	10800204 	addi	r2,r2,8
  208dc4:	10800003 	ldbu	r2,0(r2)
  208dc8:	10803fcc 	andi	r2,r2,255
  208dcc:	10800820 	cmpeqi	r2,r2,32
  208dd0:	10001c1e 	bne	r2,zero,208e44 <get_fileinfo+0x124>
			*p++ = '.';
  208dd4:	e0bffc17 	ldw	r2,-16(fp)
  208dd8:	10c00044 	addi	r3,r2,1
  208ddc:	e0fffc15 	stw	r3,-16(fp)
  208de0:	00c00b84 	movi	r3,46
  208de4:	10c00005 	stb	r3,0(r2)
			for (i = 8; i < 11; i++) {
  208de8:	00800204 	movi	r2,8
  208dec:	e0bffb05 	stb	r2,-20(fp)
  208df0:	00001106 	br	208e38 <get_fileinfo+0x118>
				c = dir[i];
  208df4:	e0bffb03 	ldbu	r2,-20(fp)
  208df8:	e0fffe17 	ldw	r3,-8(fp)
  208dfc:	1885883a 	add	r2,r3,r2
  208e00:	10800003 	ldbu	r2,0(r2)
  208e04:	e0bffb45 	stb	r2,-19(fp)
				if (c == ' ') break;
  208e08:	e0bffb43 	ldbu	r2,-19(fp)
  208e0c:	10800818 	cmpnei	r2,r2,32
  208e10:	1000011e 	bne	r2,zero,208e18 <get_fileinfo+0xf8>
  208e14:	00000b06 	br	208e44 <get_fileinfo+0x124>
				*p++ = c;
  208e18:	e0bffc17 	ldw	r2,-16(fp)
  208e1c:	10c00044 	addi	r3,r2,1
  208e20:	e0fffc15 	stw	r3,-16(fp)
  208e24:	e0fffb43 	ldbu	r3,-19(fp)
  208e28:	10c00005 	stb	r3,0(r2)
			if (c == 0x05) c = 0xE5;
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy file name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
  208e2c:	e0bffb03 	ldbu	r2,-20(fp)
  208e30:	10800044 	addi	r2,r2,1
  208e34:	e0bffb05 	stb	r2,-20(fp)
  208e38:	e0bffb03 	ldbu	r2,-20(fp)
  208e3c:	108002f0 	cmpltui	r2,r2,11
  208e40:	103fec1e 	bne	r2,zero,208df4 <_gp+0xffff3204>
				c = dir[i];
				if (c == ' ') break;
				*p++ = c;
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
  208e44:	e0bffe17 	ldw	r2,-8(fp)
  208e48:	10c002c3 	ldbu	r3,11(r2)
  208e4c:	e0bfff17 	ldw	r2,-4(fp)
  208e50:	10c00205 	stb	r3,8(r2)
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
  208e54:	e0bffe17 	ldw	r2,-8(fp)
  208e58:	108007c4 	addi	r2,r2,31
  208e5c:	10800003 	ldbu	r2,0(r2)
  208e60:	10803fcc 	andi	r2,r2,255
  208e64:	1006963a 	slli	r3,r2,24
  208e68:	e0bffe17 	ldw	r2,-8(fp)
  208e6c:	10800784 	addi	r2,r2,30
  208e70:	10800003 	ldbu	r2,0(r2)
  208e74:	10803fcc 	andi	r2,r2,255
  208e78:	1004943a 	slli	r2,r2,16
  208e7c:	1886b03a 	or	r3,r3,r2
  208e80:	e0bffe17 	ldw	r2,-8(fp)
  208e84:	10800744 	addi	r2,r2,29
  208e88:	10800003 	ldbu	r2,0(r2)
  208e8c:	10803fcc 	andi	r2,r2,255
  208e90:	1004923a 	slli	r2,r2,8
  208e94:	1886b03a 	or	r3,r3,r2
  208e98:	e0bffe17 	ldw	r2,-8(fp)
  208e9c:	10800704 	addi	r2,r2,28
  208ea0:	10800003 	ldbu	r2,0(r2)
  208ea4:	10803fcc 	andi	r2,r2,255
  208ea8:	1886b03a 	or	r3,r3,r2
  208eac:	e0bfff17 	ldw	r2,-4(fp)
  208eb0:	10c00015 	stw	r3,0(r2)
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
  208eb4:	e0bffe17 	ldw	r2,-8(fp)
  208eb8:	10800644 	addi	r2,r2,25
  208ebc:	10800003 	ldbu	r2,0(r2)
  208ec0:	10803fcc 	andi	r2,r2,255
  208ec4:	1004923a 	slli	r2,r2,8
  208ec8:	1007883a 	mov	r3,r2
  208ecc:	e0bffe17 	ldw	r2,-8(fp)
  208ed0:	10800604 	addi	r2,r2,24
  208ed4:	10800003 	ldbu	r2,0(r2)
  208ed8:	10803fcc 	andi	r2,r2,255
  208edc:	1884b03a 	or	r2,r3,r2
  208ee0:	1007883a 	mov	r3,r2
  208ee4:	e0bfff17 	ldw	r2,-4(fp)
  208ee8:	10c0010d 	sth	r3,4(r2)
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
  208eec:	e0bffe17 	ldw	r2,-8(fp)
  208ef0:	108005c4 	addi	r2,r2,23
  208ef4:	10800003 	ldbu	r2,0(r2)
  208ef8:	10803fcc 	andi	r2,r2,255
  208efc:	1004923a 	slli	r2,r2,8
  208f00:	1007883a 	mov	r3,r2
  208f04:	e0bffe17 	ldw	r2,-8(fp)
  208f08:	10800584 	addi	r2,r2,22
  208f0c:	10800003 	ldbu	r2,0(r2)
  208f10:	10803fcc 	andi	r2,r2,255
  208f14:	1884b03a 	or	r2,r3,r2
  208f18:	1007883a 	mov	r3,r2
  208f1c:	e0bfff17 	ldw	r2,-4(fp)
  208f20:	10c0018d 	sth	r3,6(r2)
	}
	*p = 0;
  208f24:	e0bffc17 	ldw	r2,-16(fp)
  208f28:	10000005 	stb	zero,0(r2)
}
  208f2c:	e037883a 	mov	sp,fp
  208f30:	df000017 	ldw	fp,0(sp)
  208f34:	dec00104 	addi	sp,sp,4
  208f38:	f800283a 	ret

00208f3c <follow_path>:
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	BYTE *dir,			/* 32-byte working buffer */
	const char *path	/* Full-path string to find a file or directory */
)
{
  208f3c:	defffa04 	addi	sp,sp,-24
  208f40:	dfc00515 	stw	ra,20(sp)
  208f44:	df000415 	stw	fp,16(sp)
  208f48:	df000404 	addi	fp,sp,16
  208f4c:	e13ffd15 	stw	r4,-12(fp)
  208f50:	e17ffe15 	stw	r5,-8(fp)
  208f54:	e1bfff15 	stw	r6,-4(fp)
	FRESULT res;


	while (*path == ' ') path++;		/* Strip leading spaces */
  208f58:	00000306 	br	208f68 <follow_path+0x2c>
  208f5c:	e0bfff17 	ldw	r2,-4(fp)
  208f60:	10800044 	addi	r2,r2,1
  208f64:	e0bfff15 	stw	r2,-4(fp)
  208f68:	e0bfff17 	ldw	r2,-4(fp)
  208f6c:	10800003 	ldbu	r2,0(r2)
  208f70:	10803fcc 	andi	r2,r2,255
  208f74:	1080201c 	xori	r2,r2,128
  208f78:	10bfe004 	addi	r2,r2,-128
  208f7c:	10800820 	cmpeqi	r2,r2,32
  208f80:	103ff61e 	bne	r2,zero,208f5c <_gp+0xffff336c>
	if (*path == '/') path++;			/* Strip heading separator if exist */
  208f84:	e0bfff17 	ldw	r2,-4(fp)
  208f88:	10800003 	ldbu	r2,0(r2)
  208f8c:	10803fcc 	andi	r2,r2,255
  208f90:	1080201c 	xori	r2,r2,128
  208f94:	10bfe004 	addi	r2,r2,-128
  208f98:	10800bd8 	cmpnei	r2,r2,47
  208f9c:	1000031e 	bne	r2,zero,208fac <follow_path+0x70>
  208fa0:	e0bfff17 	ldw	r2,-4(fp)
  208fa4:	10800044 	addi	r2,r2,1
  208fa8:	e0bfff15 	stw	r2,-4(fp)
	dj->sclust = 0;						/* Set start directory (always root dir) */
  208fac:	e0bffd17 	ldw	r2,-12(fp)
  208fb0:	10000215 	stw	zero,8(r2)

	if ((BYTE)*path < ' ') {			/* Null path means the root directory */
  208fb4:	e0bfff17 	ldw	r2,-4(fp)
  208fb8:	10800003 	ldbu	r2,0(r2)
  208fbc:	10803fcc 	andi	r2,r2,255
  208fc0:	10800828 	cmpgeui	r2,r2,32
  208fc4:	1000061e 	bne	r2,zero,208fe0 <follow_path+0xa4>
		res = dir_rewind(dj);
  208fc8:	e13ffd17 	ldw	r4,-12(fp)
  208fcc:	02086440 	call	208644 <dir_rewind>
  208fd0:	e0bffc15 	stw	r2,-16(fp)
		dir[0] = 0;
  208fd4:	e0bffe17 	ldw	r2,-8(fp)
  208fd8:	10000005 	stb	zero,0(r2)
  208fdc:	00002506 	br	209074 <follow_path+0x138>

	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
  208fe0:	e0bfff04 	addi	r2,fp,-4
  208fe4:	e13ffd17 	ldw	r4,-12(fp)
  208fe8:	100b883a 	mov	r5,r2
  208fec:	0208b940 	call	208b94 <create_name>
  208ff0:	e0bffc15 	stw	r2,-16(fp)
			if (res != FR_OK) break;
  208ff4:	e0bffc17 	ldw	r2,-16(fp)
  208ff8:	10000126 	beq	r2,zero,209000 <follow_path+0xc4>
  208ffc:	00001d06 	br	209074 <follow_path+0x138>
			res = dir_find(dj, dir);		/* Find it */
  209000:	e13ffd17 	ldw	r4,-12(fp)
  209004:	e17ffe17 	ldw	r5,-8(fp)
  209008:	02088440 	call	208844 <dir_find>
  20900c:	e0bffc15 	stw	r2,-16(fp)
			if (res != FR_OK) break;		/* Could not find the object */
  209010:	e0bffc17 	ldw	r2,-16(fp)
  209014:	10000126 	beq	r2,zero,20901c <follow_path+0xe0>
  209018:	00001606 	br	209074 <follow_path+0x138>
			if (dj->fn[11]) break;			/* Last segment match. Function completed. */
  20901c:	e0bffd17 	ldw	r2,-12(fp)
  209020:	10800117 	ldw	r2,4(r2)
  209024:	108002c4 	addi	r2,r2,11
  209028:	10800003 	ldbu	r2,0(r2)
  20902c:	10803fcc 	andi	r2,r2,255
  209030:	10000126 	beq	r2,zero,209038 <follow_path+0xfc>
  209034:	00000f06 	br	209074 <follow_path+0x138>
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
  209038:	e0bffe17 	ldw	r2,-8(fp)
  20903c:	108002c4 	addi	r2,r2,11
  209040:	10800003 	ldbu	r2,0(r2)
  209044:	10803fcc 	andi	r2,r2,255
  209048:	1080040c 	andi	r2,r2,16
  20904c:	1000031e 	bne	r2,zero,20905c <follow_path+0x120>
				res = FR_NO_FILE; break;
  209050:	008000c4 	movi	r2,3
  209054:	e0bffc15 	stw	r2,-16(fp)
  209058:	00000606 	br	209074 <follow_path+0x138>
			}
			dj->sclust = get_clust(dir);	/* Follow next */
  20905c:	e13ffe17 	ldw	r4,-8(fp)
  209060:	02085840 	call	208584 <get_clust>
  209064:	1007883a 	mov	r3,r2
  209068:	e0bffd17 	ldw	r2,-12(fp)
  20906c:	10c00215 	stw	r3,8(r2)
		}
  209070:	003fdb06 	br	208fe0 <_gp+0xffff33f0>
	}

	return res;
  209074:	e0bffc17 	ldw	r2,-16(fp)
}
  209078:	e037883a 	mov	sp,fp
  20907c:	dfc00117 	ldw	ra,4(sp)
  209080:	df000017 	ldw	fp,0(sp)
  209084:	dec00204 	addi	sp,sp,8
  209088:	f800283a 	ret

0020908c <check_fs>:
static
BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
	BYTE *buf,	/* Working buffer */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
  20908c:	defffc04 	addi	sp,sp,-16
  209090:	dfc00315 	stw	ra,12(sp)
  209094:	df000215 	stw	fp,8(sp)
  209098:	df000204 	addi	fp,sp,8
  20909c:	e13ffe15 	stw	r4,-8(fp)
  2090a0:	e17fff15 	stw	r5,-4(fp)
	if (disk_readp(buf, sect, 510, 2))		/* Read the boot record */
  2090a4:	e13ffe17 	ldw	r4,-8(fp)
  2090a8:	e17fff17 	ldw	r5,-4(fp)
  2090ac:	01807f84 	movi	r6,510
  2090b0:	01c00084 	movi	r7,2
  2090b4:	02082280 	call	208228 <disk_readp>
  2090b8:	10000226 	beq	r2,zero,2090c4 <check_fs+0x38>
		return 3;
  2090bc:	008000c4 	movi	r2,3
  2090c0:	00004006 	br	2091c4 <check_fs+0x138>
	if (LD_WORD(buf) != 0xAA55)				/* Check record signature */
  2090c4:	e0bffe17 	ldw	r2,-8(fp)
  2090c8:	10800044 	addi	r2,r2,1
  2090cc:	10800003 	ldbu	r2,0(r2)
  2090d0:	10803fcc 	andi	r2,r2,255
  2090d4:	1004923a 	slli	r2,r2,8
  2090d8:	1007883a 	mov	r3,r2
  2090dc:	e0bffe17 	ldw	r2,-8(fp)
  2090e0:	10800003 	ldbu	r2,0(r2)
  2090e4:	10803fcc 	andi	r2,r2,255
  2090e8:	1884b03a 	or	r2,r3,r2
  2090ec:	10bfffcc 	andi	r2,r2,65535
  2090f0:	10a0001c 	xori	r2,r2,32768
  2090f4:	10a00004 	addi	r2,r2,-32768
  2090f8:	10aa9560 	cmpeqi	r2,r2,-21931
  2090fc:	1000021e 	bne	r2,zero,209108 <check_fs+0x7c>
		return 2;
  209100:	00800084 	movi	r2,2
  209104:	00002f06 	br	2091c4 <check_fs+0x138>

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT12/16 */
  209108:	e13ffe17 	ldw	r4,-8(fp)
  20910c:	e17fff17 	ldw	r5,-4(fp)
  209110:	01800d84 	movi	r6,54
  209114:	01c00084 	movi	r7,2
  209118:	02082280 	call	208228 <disk_readp>
  20911c:	1000111e 	bne	r2,zero,209164 <check_fs+0xd8>
  209120:	e0bffe17 	ldw	r2,-8(fp)
  209124:	10800044 	addi	r2,r2,1
  209128:	10800003 	ldbu	r2,0(r2)
  20912c:	10803fcc 	andi	r2,r2,255
  209130:	1004923a 	slli	r2,r2,8
  209134:	1007883a 	mov	r3,r2
  209138:	e0bffe17 	ldw	r2,-8(fp)
  20913c:	10800003 	ldbu	r2,0(r2)
  209140:	10803fcc 	andi	r2,r2,255
  209144:	1884b03a 	or	r2,r3,r2
  209148:	10bfffcc 	andi	r2,r2,65535
  20914c:	10a0001c 	xori	r2,r2,32768
  209150:	10a00004 	addi	r2,r2,-32768
  209154:	10905198 	cmpnei	r2,r2,16710
  209158:	1000021e 	bne	r2,zero,209164 <check_fs+0xd8>
		return 0;
  20915c:	0005883a 	mov	r2,zero
  209160:	00001806 	br	2091c4 <check_fs+0x138>
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT32 */
  209164:	e13ffe17 	ldw	r4,-8(fp)
  209168:	e17fff17 	ldw	r5,-4(fp)
  20916c:	01801484 	movi	r6,82
  209170:	01c00084 	movi	r7,2
  209174:	02082280 	call	208228 <disk_readp>
  209178:	1000111e 	bne	r2,zero,2091c0 <check_fs+0x134>
  20917c:	e0bffe17 	ldw	r2,-8(fp)
  209180:	10800044 	addi	r2,r2,1
  209184:	10800003 	ldbu	r2,0(r2)
  209188:	10803fcc 	andi	r2,r2,255
  20918c:	1004923a 	slli	r2,r2,8
  209190:	1007883a 	mov	r3,r2
  209194:	e0bffe17 	ldw	r2,-8(fp)
  209198:	10800003 	ldbu	r2,0(r2)
  20919c:	10803fcc 	andi	r2,r2,255
  2091a0:	1884b03a 	or	r2,r3,r2
  2091a4:	10bfffcc 	andi	r2,r2,65535
  2091a8:	10a0001c 	xori	r2,r2,32768
  2091ac:	10a00004 	addi	r2,r2,-32768
  2091b0:	10905198 	cmpnei	r2,r2,16710
  2091b4:	1000021e 	bne	r2,zero,2091c0 <check_fs+0x134>
		return 0;
  2091b8:	0005883a 	mov	r2,zero
  2091bc:	00000106 	br	2091c4 <check_fs+0x138>
	return 1;
  2091c0:	00800044 	movi	r2,1
}
  2091c4:	e037883a 	mov	sp,fp
  2091c8:	dfc00117 	ldw	ra,4(sp)
  2091cc:	df000017 	ldw	fp,0(sp)
  2091d0:	dec00204 	addi	sp,sp,8
  2091d4:	f800283a 	ret

002091d8 <pf_mount>:
/*-----------------------------------------------------------------------*/

FRESULT pf_mount (
	FATFS *fs		/* Pointer to new file system object */
)
{
  2091d8:	deffef04 	addi	sp,sp,-68
  2091dc:	dfc01015 	stw	ra,64(sp)
  2091e0:	df000f15 	stw	fp,60(sp)
  2091e4:	df000f04 	addi	fp,sp,60
  2091e8:	e13fff15 	stw	r4,-4(fp)
	BYTE fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;


	FatFs = 0;
  2091ec:	d020c915 	stw	zero,-31964(gp)

	if (disk_initialize() & STA_NOINIT)	/* Check if the drive is ready or not */
  2091f0:	02081f80 	call	2081f8 <disk_initialize>
  2091f4:	10803fcc 	andi	r2,r2,255
  2091f8:	1080004c 	andi	r2,r2,1
  2091fc:	10000226 	beq	r2,zero,209208 <pf_mount+0x30>
		return FR_NOT_READY;
  209200:	00800084 	movi	r2,2
  209204:	0000ec06 	br	2095b8 <pf_mount+0x3e0>

	/* Search FAT partition on the drive */
	bsect = 0;
  209208:	e03ff215 	stw	zero,-56(fp)
	fmt = check_fs(buf, bsect);			/* Check sector 0 as an SFD format */
  20920c:	e0bff604 	addi	r2,fp,-40
  209210:	1009883a 	mov	r4,r2
  209214:	e17ff217 	ldw	r5,-56(fp)
  209218:	020908c0 	call	20908c <check_fs>
  20921c:	e0bff105 	stb	r2,-60(fp)
	if (fmt == 1) {						/* Not an FAT boot record, it may be FDISK format */
  209220:	e0bff103 	ldbu	r2,-60(fp)
  209224:	10800058 	cmpnei	r2,r2,1
  209228:	1000211e 	bne	r2,zero,2092b0 <pf_mount+0xd8>
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) {	/* 1st partition entry */
  20922c:	e0bff604 	addi	r2,fp,-40
  209230:	1009883a 	mov	r4,r2
  209234:	e17ff217 	ldw	r5,-56(fp)
  209238:	01806f84 	movi	r6,446
  20923c:	01c00404 	movi	r7,16
  209240:	02082280 	call	208228 <disk_readp>
  209244:	10000326 	beq	r2,zero,209254 <pf_mount+0x7c>
			fmt = 3;
  209248:	008000c4 	movi	r2,3
  20924c:	e0bff105 	stb	r2,-60(fp)
  209250:	00001706 	br	2092b0 <pf_mount+0xd8>
		} else {
			if (buf[4]) {					/* Is the partition existing? */
  209254:	e0bff703 	ldbu	r2,-36(fp)
  209258:	10803fcc 	andi	r2,r2,255
  20925c:	10001426 	beq	r2,zero,2092b0 <pf_mount+0xd8>
				bsect = LD_DWORD(&buf[8]);	/* Partition offset in LBA */
  209260:	e0bff8c3 	ldbu	r2,-29(fp)
  209264:	10803fcc 	andi	r2,r2,255
  209268:	1006963a 	slli	r3,r2,24
  20926c:	e0bff883 	ldbu	r2,-30(fp)
  209270:	10803fcc 	andi	r2,r2,255
  209274:	1004943a 	slli	r2,r2,16
  209278:	1886b03a 	or	r3,r3,r2
  20927c:	e0bff843 	ldbu	r2,-31(fp)
  209280:	10803fcc 	andi	r2,r2,255
  209284:	1004923a 	slli	r2,r2,8
  209288:	1886b03a 	or	r3,r3,r2
  20928c:	e0bff803 	ldbu	r2,-32(fp)
  209290:	10803fcc 	andi	r2,r2,255
  209294:	1884b03a 	or	r2,r3,r2
  209298:	e0bff215 	stw	r2,-56(fp)
				fmt = check_fs(buf, bsect);	/* Check the partition */
  20929c:	e0bff604 	addi	r2,fp,-40
  2092a0:	1009883a 	mov	r4,r2
  2092a4:	e17ff217 	ldw	r5,-56(fp)
  2092a8:	020908c0 	call	20908c <check_fs>
  2092ac:	e0bff105 	stb	r2,-60(fp)
			}
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  2092b0:	e0bff103 	ldbu	r2,-60(fp)
  2092b4:	108000d8 	cmpnei	r2,r2,3
  2092b8:	1000021e 	bne	r2,zero,2092c4 <pf_mount+0xec>
  2092bc:	00800044 	movi	r2,1
  2092c0:	0000bd06 	br	2095b8 <pf_mount+0x3e0>
	if (fmt) return FR_NO_FILESYSTEM;	/* No valid FAT patition is found */
  2092c4:	e0bff103 	ldbu	r2,-60(fp)
  2092c8:	10000226 	beq	r2,zero,2092d4 <pf_mount+0xfc>
  2092cc:	00800184 	movi	r2,6
  2092d0:	0000b906 	br	2095b8 <pf_mount+0x3e0>

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof (buf))) return FR_DISK_ERR;
  2092d4:	e0bff604 	addi	r2,fp,-40
  2092d8:	1009883a 	mov	r4,r2
  2092dc:	e17ff217 	ldw	r5,-56(fp)
  2092e0:	01800344 	movi	r6,13
  2092e4:	01c00904 	movi	r7,36
  2092e8:	02082280 	call	208228 <disk_readp>
  2092ec:	10000226 	beq	r2,zero,2092f8 <pf_mount+0x120>
  2092f0:	00800044 	movi	r2,1
  2092f4:	0000b006 	br	2095b8 <pf_mount+0x3e0>

	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
  2092f8:	e0bff883 	ldbu	r2,-30(fp)
  2092fc:	10803fcc 	andi	r2,r2,255
  209300:	1004923a 	slli	r2,r2,8
  209304:	1007883a 	mov	r3,r2
  209308:	e0bff843 	ldbu	r2,-31(fp)
  20930c:	10803fcc 	andi	r2,r2,255
  209310:	1884b03a 	or	r2,r3,r2
  209314:	10bfffcc 	andi	r2,r2,65535
  209318:	e0bff315 	stw	r2,-52(fp)
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);
  20931c:	e0bff317 	ldw	r2,-52(fp)
  209320:	10000f1e 	bne	r2,zero,209360 <pf_mount+0x188>
  209324:	e0bffc83 	ldbu	r2,-14(fp)
  209328:	10803fcc 	andi	r2,r2,255
  20932c:	1006963a 	slli	r3,r2,24
  209330:	e0bffc43 	ldbu	r2,-15(fp)
  209334:	10803fcc 	andi	r2,r2,255
  209338:	1004943a 	slli	r2,r2,16
  20933c:	1886b03a 	or	r3,r3,r2
  209340:	e0bffc03 	ldbu	r2,-16(fp)
  209344:	10803fcc 	andi	r2,r2,255
  209348:	1004923a 	slli	r2,r2,8
  20934c:	1886b03a 	or	r3,r3,r2
  209350:	e0bffbc3 	ldbu	r2,-17(fp)
  209354:	10803fcc 	andi	r2,r2,255
  209358:	1884b03a 	or	r2,r3,r2
  20935c:	e0bff315 	stw	r2,-52(fp)

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
  209360:	e0bff6c3 	ldbu	r2,-37(fp)
  209364:	10803fcc 	andi	r2,r2,255
  209368:	e13ff317 	ldw	r4,-52(fp)
  20936c:	100b883a 	mov	r5,r2
  209370:	020b50c0 	call	20b50c <__mulsi3>
  209374:	e0bff315 	stw	r2,-52(fp)
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
  209378:	e0bff683 	ldbu	r2,-38(fp)
  20937c:	10803fcc 	andi	r2,r2,255
  209380:	1004923a 	slli	r2,r2,8
  209384:	1007883a 	mov	r3,r2
  209388:	e0bff643 	ldbu	r2,-39(fp)
  20938c:	10803fcc 	andi	r2,r2,255
  209390:	1884b03a 	or	r2,r3,r2
  209394:	10ffffcc 	andi	r3,r2,65535
  209398:	e0bff217 	ldw	r2,-56(fp)
  20939c:	1887883a 	add	r3,r3,r2
  2093a0:	e0bfff17 	ldw	r2,-4(fp)
  2093a4:	10c00315 	stw	r3,12(r2)
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
  2093a8:	e0fff603 	ldbu	r3,-40(fp)
  2093ac:	e0bfff17 	ldw	r2,-4(fp)
  2093b0:	10c00085 	stb	r3,2(r2)
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
  2093b4:	e0bff743 	ldbu	r2,-35(fp)
  2093b8:	10803fcc 	andi	r2,r2,255
  2093bc:	1004923a 	slli	r2,r2,8
  2093c0:	1007883a 	mov	r3,r2
  2093c4:	e0bff703 	ldbu	r2,-36(fp)
  2093c8:	10803fcc 	andi	r2,r2,255
  2093cc:	1884b03a 	or	r2,r3,r2
  2093d0:	1007883a 	mov	r3,r2
  2093d4:	e0bfff17 	ldw	r2,-4(fp)
  2093d8:	10c0010d 	sth	r3,4(r2)
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
  2093dc:	e0bff7c3 	ldbu	r2,-33(fp)
  2093e0:	10803fcc 	andi	r2,r2,255
  2093e4:	1004923a 	slli	r2,r2,8
  2093e8:	1007883a 	mov	r3,r2
  2093ec:	e0bff783 	ldbu	r2,-34(fp)
  2093f0:	10803fcc 	andi	r2,r2,255
  2093f4:	1884b03a 	or	r2,r3,r2
  2093f8:	10bfffcc 	andi	r2,r2,65535
  2093fc:	e0bff415 	stw	r2,-48(fp)
	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
  209400:	e0bff417 	ldw	r2,-48(fp)
  209404:	10000f1e 	bne	r2,zero,209444 <pf_mount+0x26c>
  209408:	e0bffb83 	ldbu	r2,-18(fp)
  20940c:	10803fcc 	andi	r2,r2,255
  209410:	1006963a 	slli	r3,r2,24
  209414:	e0bffb43 	ldbu	r2,-19(fp)
  209418:	10803fcc 	andi	r2,r2,255
  20941c:	1004943a 	slli	r2,r2,16
  209420:	1886b03a 	or	r3,r3,r2
  209424:	e0bffb03 	ldbu	r2,-20(fp)
  209428:	10803fcc 	andi	r2,r2,255
  20942c:	1004923a 	slli	r2,r2,8
  209430:	1886b03a 	or	r3,r3,r2
  209434:	e0bffac3 	ldbu	r2,-21(fp)
  209438:	10803fcc 	andi	r2,r2,255
  20943c:	1884b03a 	or	r2,r3,r2
  209440:	e0bff415 	stw	r2,-48(fp)
	mclst = (tsect						/* Last cluster# + 1 */
		- LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
  209444:	e0bff683 	ldbu	r2,-38(fp)
  209448:	10803fcc 	andi	r2,r2,255
  20944c:	1004923a 	slli	r2,r2,8
  209450:	1007883a 	mov	r3,r2
  209454:	e0bff643 	ldbu	r2,-39(fp)
  209458:	10803fcc 	andi	r2,r2,255
  20945c:	1884b03a 	or	r2,r3,r2
  209460:	10bfffcc 	andi	r2,r2,65535
  209464:	e0fff417 	ldw	r3,-48(fp)
  209468:	1887c83a 	sub	r3,r3,r2
  20946c:	e0bff317 	ldw	r2,-52(fp)
  209470:	1887c83a 	sub	r3,r3,r2
  209474:	e0bfff17 	ldw	r2,-4(fp)
  209478:	1080010b 	ldhu	r2,4(r2)
  20947c:	10bfffcc 	andi	r2,r2,65535
  209480:	1004d13a 	srli	r2,r2,4
  209484:	10bfffcc 	andi	r2,r2,65535
  209488:	1887c83a 	sub	r3,r3,r2
		) / fs->csize + 2;
  20948c:	e0bfff17 	ldw	r2,-4(fp)
  209490:	10800083 	ldbu	r2,2(r2)
  209494:	10803fcc 	andi	r2,r2,255
  209498:	1809883a 	mov	r4,r3
  20949c:	100b883a 	mov	r5,r2
  2094a0:	020b4fc0 	call	20b4fc <__udivsi3>
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
	mclst = (tsect						/* Last cluster# + 1 */
  2094a4:	10800084 	addi	r2,r2,2
  2094a8:	e0bff515 	stw	r2,-44(fp)
		- LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
		) / fs->csize + 2;
	fs->n_fatent = (CLUST)mclst;
  2094ac:	e0bfff17 	ldw	r2,-4(fp)
  2094b0:	e0fff517 	ldw	r3,-44(fp)
  2094b4:	10c00215 	stw	r3,8(r2)

	fmt = 0;							/* Determine the FAT sub type */
  2094b8:	e03ff105 	stb	zero,-60(fp)
	if (_FS_FAT12 && mclst < 0xFF7)
		fmt = FS_FAT12;
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
  2094bc:	e0bff517 	ldw	r2,-44(fp)
  2094c0:	1083fe30 	cmpltui	r2,r2,4088
  2094c4:	1000051e 	bne	r2,zero,2094dc <pf_mount+0x304>
  2094c8:	e0bff517 	ldw	r2,-44(fp)
  2094cc:	10bffde8 	cmpgeui	r2,r2,65527
  2094d0:	1000021e 	bne	r2,zero,2094dc <pf_mount+0x304>
		fmt = FS_FAT16;
  2094d4:	00800084 	movi	r2,2
  2094d8:	e0bff105 	stb	r2,-60(fp)
	if (_FS_FAT32 && mclst >= 0xFFF7)
  2094dc:	e0bff517 	ldw	r2,-44(fp)
  2094e0:	10bffdf0 	cmpltui	r2,r2,65527
  2094e4:	1000021e 	bne	r2,zero,2094f0 <pf_mount+0x318>
		fmt = FS_FAT32;
  2094e8:	008000c4 	movi	r2,3
  2094ec:	e0bff105 	stb	r2,-60(fp)
	if (!fmt) return FR_NO_FILESYSTEM;
  2094f0:	e0bff103 	ldbu	r2,-60(fp)
  2094f4:	1000021e 	bne	r2,zero,209500 <pf_mount+0x328>
  2094f8:	00800184 	movi	r2,6
  2094fc:	00002e06 	br	2095b8 <pf_mount+0x3e0>
	fs->fs_type = fmt;
  209500:	e0bfff17 	ldw	r2,-4(fp)
  209504:	e0fff103 	ldbu	r3,-60(fp)
  209508:	10c00005 	stb	r3,0(r2)

	if (_FS_32ONLY || (_FS_FAT32 && fmt == FS_FAT32))
  20950c:	e0bff103 	ldbu	r2,-60(fp)
  209510:	108000d8 	cmpnei	r2,r2,3
  209514:	1000111e 	bne	r2,zero,20955c <pf_mount+0x384>
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
  209518:	e0bffe83 	ldbu	r2,-6(fp)
  20951c:	10803fcc 	andi	r2,r2,255
  209520:	1006963a 	slli	r3,r2,24
  209524:	e0bffe43 	ldbu	r2,-7(fp)
  209528:	10803fcc 	andi	r2,r2,255
  20952c:	1004943a 	slli	r2,r2,16
  209530:	1886b03a 	or	r3,r3,r2
  209534:	e0bffe03 	ldbu	r2,-8(fp)
  209538:	10803fcc 	andi	r2,r2,255
  20953c:	1004923a 	slli	r2,r2,8
  209540:	1886b03a 	or	r3,r3,r2
  209544:	e0bffdc3 	ldbu	r2,-9(fp)
  209548:	10803fcc 	andi	r2,r2,255
  20954c:	1886b03a 	or	r3,r3,r2
  209550:	e0bfff17 	ldw	r2,-4(fp)
  209554:	10c00415 	stw	r3,16(r2)
  209558:	00000606 	br	209574 <pf_mount+0x39c>
	else
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
  20955c:	e0bfff17 	ldw	r2,-4(fp)
  209560:	10c00317 	ldw	r3,12(r2)
  209564:	e0bff317 	ldw	r2,-52(fp)
  209568:	1887883a 	add	r3,r3,r2
  20956c:	e0bfff17 	ldw	r2,-4(fp)
  209570:	10c00415 	stw	r3,16(r2)
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16;	/* Data start sector (lba) */
  209574:	e0bfff17 	ldw	r2,-4(fp)
  209578:	10c00317 	ldw	r3,12(r2)
  20957c:	e0bff317 	ldw	r2,-52(fp)
  209580:	1887883a 	add	r3,r3,r2
  209584:	e0bfff17 	ldw	r2,-4(fp)
  209588:	1080010b 	ldhu	r2,4(r2)
  20958c:	10bfffcc 	andi	r2,r2,65535
  209590:	1004d13a 	srli	r2,r2,4
  209594:	10bfffcc 	andi	r2,r2,65535
  209598:	1887883a 	add	r3,r3,r2
  20959c:	e0bfff17 	ldw	r2,-4(fp)
  2095a0:	10c00515 	stw	r3,20(r2)

	fs->flag = 0;
  2095a4:	e0bfff17 	ldw	r2,-4(fp)
  2095a8:	10000045 	stb	zero,1(r2)
	FatFs = fs;
  2095ac:	e0bfff17 	ldw	r2,-4(fp)
  2095b0:	d0a0c915 	stw	r2,-31964(gp)

	return FR_OK;
  2095b4:	0005883a 	mov	r2,zero
}
  2095b8:	e037883a 	mov	sp,fp
  2095bc:	dfc00117 	ldw	ra,4(sp)
  2095c0:	df000017 	ldw	fp,0(sp)
  2095c4:	dec00204 	addi	sp,sp,8
  2095c8:	f800283a 	ret

002095cc <pf_open>:
/*-----------------------------------------------------------------------*/

FRESULT pf_open (
	const char *path	/* Pointer to the file name */
)
{
  2095cc:	deffeb04 	addi	sp,sp,-84
  2095d0:	dfc01415 	stw	ra,80(sp)
  2095d4:	df001315 	stw	fp,76(sp)
  2095d8:	df001304 	addi	fp,sp,76
  2095dc:	e13fff15 	stw	r4,-4(fp)
	FRESULT res;
	DIR dj;
	BYTE sp[12], dir[32];
	FATFS *fs = FatFs;
  2095e0:	d0a0c917 	ldw	r2,-31964(gp)
  2095e4:	e0bfed15 	stw	r2,-76(fp)


	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
  2095e8:	e0bfed17 	ldw	r2,-76(fp)
  2095ec:	1000021e 	bne	r2,zero,2095f8 <pf_open+0x2c>
  2095f0:	00800144 	movi	r2,5
  2095f4:	00003406 	br	2096c8 <pf_open+0xfc>

	fs->flag = 0;
  2095f8:	e0bfed17 	ldw	r2,-76(fp)
  2095fc:	10000045 	stb	zero,1(r2)
	dj.fn = sp;
  209600:	e0bff404 	addi	r2,fp,-48
  209604:	e0bff015 	stw	r2,-64(fp)
	res = follow_path(&dj, dir, path);	/* Follow the file path */
  209608:	e0ffef04 	addi	r3,fp,-68
  20960c:	e0bff704 	addi	r2,fp,-36
  209610:	1809883a 	mov	r4,r3
  209614:	100b883a 	mov	r5,r2
  209618:	e1bfff17 	ldw	r6,-4(fp)
  20961c:	0208f3c0 	call	208f3c <follow_path>
  209620:	e0bfee15 	stw	r2,-72(fp)
	if (res != FR_OK) return res;		/* Follow failed */
  209624:	e0bfee17 	ldw	r2,-72(fp)
  209628:	10000226 	beq	r2,zero,209634 <pf_open+0x68>
  20962c:	e0bfee17 	ldw	r2,-72(fp)
  209630:	00002506 	br	2096c8 <pf_open+0xfc>
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
  209634:	e0bff703 	ldbu	r2,-36(fp)
  209638:	10803fcc 	andi	r2,r2,255
  20963c:	10000426 	beq	r2,zero,209650 <pf_open+0x84>
  209640:	e0bff9c3 	ldbu	r2,-25(fp)
  209644:	10803fcc 	andi	r2,r2,255
  209648:	1080040c 	andi	r2,r2,16
  20964c:	10000226 	beq	r2,zero,209658 <pf_open+0x8c>
		return FR_NO_FILE;
  209650:	008000c4 	movi	r2,3
  209654:	00001c06 	br	2096c8 <pf_open+0xfc>

	fs->org_clust = get_clust(dir);		/* File start cluster */
  209658:	e0bff704 	addi	r2,fp,-36
  20965c:	1009883a 	mov	r4,r2
  209660:	02085840 	call	208584 <get_clust>
  209664:	1007883a 	mov	r3,r2
  209668:	e0bfed17 	ldw	r2,-76(fp)
  20966c:	10c00815 	stw	r3,32(r2)
	fs->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  209670:	e0bffec3 	ldbu	r2,-5(fp)
  209674:	10803fcc 	andi	r2,r2,255
  209678:	1006963a 	slli	r3,r2,24
  20967c:	e0bffe83 	ldbu	r2,-6(fp)
  209680:	10803fcc 	andi	r2,r2,255
  209684:	1004943a 	slli	r2,r2,16
  209688:	1886b03a 	or	r3,r3,r2
  20968c:	e0bffe43 	ldbu	r2,-7(fp)
  209690:	10803fcc 	andi	r2,r2,255
  209694:	1004923a 	slli	r2,r2,8
  209698:	1886b03a 	or	r3,r3,r2
  20969c:	e0bffe03 	ldbu	r2,-8(fp)
  2096a0:	10803fcc 	andi	r2,r2,255
  2096a4:	1886b03a 	or	r3,r3,r2
  2096a8:	e0bfed17 	ldw	r2,-76(fp)
  2096ac:	10c00715 	stw	r3,28(r2)
	fs->fptr = 0;						/* File pointer */
  2096b0:	e0bfed17 	ldw	r2,-76(fp)
  2096b4:	10000615 	stw	zero,24(r2)
	fs->flag = FA_OPENED;
  2096b8:	e0bfed17 	ldw	r2,-76(fp)
  2096bc:	00c00044 	movi	r3,1
  2096c0:	10c00045 	stb	r3,1(r2)

	return FR_OK;
  2096c4:	0005883a 	mov	r2,zero
}
  2096c8:	e037883a 	mov	sp,fp
  2096cc:	dfc00117 	ldw	ra,4(sp)
  2096d0:	df000017 	ldw	fp,0(sp)
  2096d4:	dec00204 	addi	sp,sp,8
  2096d8:	f800283a 	ret

002096dc <pf_read>:
FRESULT pf_read (
	void* buff,		/* Pointer to the read buffer (NULL:Forward data to the stream)*/
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
  2096dc:	defff304 	addi	sp,sp,-52
  2096e0:	dfc00c15 	stw	ra,48(sp)
  2096e4:	df000b15 	stw	fp,44(sp)
  2096e8:	df000b04 	addi	fp,sp,44
  2096ec:	e13ffd15 	stw	r4,-12(fp)
  2096f0:	e17ffe15 	stw	r5,-8(fp)
  2096f4:	e1bfff15 	stw	r6,-4(fp)
	DRESULT dr;
	CLUST clst;
	DWORD sect, remain;
	UINT rcnt;
	BYTE cs, *rbuff = (BYTE *)buff;
  2096f8:	e0bffd17 	ldw	r2,-12(fp)
  2096fc:	e0bff715 	stw	r2,-36(fp)
	FATFS *fs = FatFs;
  209700:	d0a0c917 	ldw	r2,-31964(gp)
  209704:	e0bff815 	stw	r2,-32(fp)


	*br = 0;
  209708:	e0bfff17 	ldw	r2,-4(fp)
  20970c:	10000015 	stw	zero,0(r2)
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
  209710:	e0bff817 	ldw	r2,-32(fp)
  209714:	1000021e 	bne	r2,zero,209720 <pf_read+0x44>
  209718:	00800144 	movi	r2,5
  20971c:	00008006 	br	209920 <pf_read+0x244>
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
  209720:	e0bff817 	ldw	r2,-32(fp)
  209724:	10800043 	ldbu	r2,1(r2)
  209728:	10803fcc 	andi	r2,r2,255
  20972c:	1080004c 	andi	r2,r2,1
  209730:	1000021e 	bne	r2,zero,20973c <pf_read+0x60>
		return FR_NOT_OPENED;
  209734:	00800104 	movi	r2,4
  209738:	00007906 	br	209920 <pf_read+0x244>

	remain = fs->fsize - fs->fptr;
  20973c:	e0bff817 	ldw	r2,-32(fp)
  209740:	10c00717 	ldw	r3,28(r2)
  209744:	e0bff817 	ldw	r2,-32(fp)
  209748:	10800617 	ldw	r2,24(r2)
  20974c:	1885c83a 	sub	r2,r3,r2
  209750:	e0bff915 	stw	r2,-28(fp)
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
  209754:	e0bffe17 	ldw	r2,-8(fp)
  209758:	e0fff917 	ldw	r3,-28(fp)
  20975c:	1880032e 	bgeu	r3,r2,20976c <pf_read+0x90>
  209760:	e0bff917 	ldw	r2,-28(fp)
  209764:	e0bffe15 	stw	r2,-8(fp)

	while (btr)	{									/* Repeat until all data transferred */
  209768:	00006a06 	br	209914 <pf_read+0x238>
  20976c:	00006906 	br	209914 <pf_read+0x238>
		if ((fs->fptr % 512) == 0) {				/* On the sector boundary? */
  209770:	e0bff817 	ldw	r2,-32(fp)
  209774:	10800617 	ldw	r2,24(r2)
  209778:	10807fcc 	andi	r2,r2,511
  20977c:	1000311e 	bne	r2,zero,209844 <pf_read+0x168>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1));	/* Sector offset in the cluster */
  209780:	e0bff817 	ldw	r2,-32(fp)
  209784:	10800617 	ldw	r2,24(r2)
  209788:	1004d27a 	srli	r2,r2,9
  20978c:	1007883a 	mov	r3,r2
  209790:	e0bff817 	ldw	r2,-32(fp)
  209794:	10800083 	ldbu	r2,2(r2)
  209798:	10bfffc4 	addi	r2,r2,-1
  20979c:	1884703a 	and	r2,r3,r2
  2097a0:	e0bffa05 	stb	r2,-24(fp)
			if (!cs) {								/* On the cluster boundary? */
  2097a4:	e0bffa03 	ldbu	r2,-24(fp)
  2097a8:	1000161e 	bne	r2,zero,209804 <pf_read+0x128>
				if (fs->fptr == 0)					/* On the top of the file? */
  2097ac:	e0bff817 	ldw	r2,-32(fp)
  2097b0:	10800617 	ldw	r2,24(r2)
  2097b4:	1000041e 	bne	r2,zero,2097c8 <pf_read+0xec>
					clst = fs->org_clust;
  2097b8:	e0bff817 	ldw	r2,-32(fp)
  2097bc:	10800817 	ldw	r2,32(r2)
  2097c0:	e0bff515 	stw	r2,-44(fp)
  2097c4:	00000506 	br	2097dc <pf_read+0x100>
				else
					clst = get_fat(fs->curr_clust);
  2097c8:	e0bff817 	ldw	r2,-32(fp)
  2097cc:	10800917 	ldw	r2,36(r2)
  2097d0:	1009883a 	mov	r4,r2
  2097d4:	02083a40 	call	2083a4 <get_fat>
  2097d8:	e0bff515 	stw	r2,-44(fp)
				if (clst <= 1) ABORT(FR_DISK_ERR);
  2097dc:	e0bff517 	ldw	r2,-44(fp)
  2097e0:	108000a8 	cmpgeui	r2,r2,2
  2097e4:	1000041e 	bne	r2,zero,2097f8 <pf_read+0x11c>
  2097e8:	e0bff817 	ldw	r2,-32(fp)
  2097ec:	10000045 	stb	zero,1(r2)
  2097f0:	00800044 	movi	r2,1
  2097f4:	00004a06 	br	209920 <pf_read+0x244>
				fs->curr_clust = clst;				/* Update current cluster */
  2097f8:	e0bff817 	ldw	r2,-32(fp)
  2097fc:	e0fff517 	ldw	r3,-44(fp)
  209800:	10c00915 	stw	r3,36(r2)
			}
			sect = clust2sect(fs->curr_clust);		/* Get current sector */
  209804:	e0bff817 	ldw	r2,-32(fp)
  209808:	10800917 	ldw	r2,36(r2)
  20980c:	1009883a 	mov	r4,r2
  209810:	02085040 	call	208504 <clust2sect>
  209814:	e0bffb15 	stw	r2,-20(fp)
			if (!sect) ABORT(FR_DISK_ERR);
  209818:	e0bffb17 	ldw	r2,-20(fp)
  20981c:	1000041e 	bne	r2,zero,209830 <pf_read+0x154>
  209820:	e0bff817 	ldw	r2,-32(fp)
  209824:	10000045 	stb	zero,1(r2)
  209828:	00800044 	movi	r2,1
  20982c:	00003c06 	br	209920 <pf_read+0x244>
			fs->dsect = sect + cs;
  209830:	e0fffa03 	ldbu	r3,-24(fp)
  209834:	e0bffb17 	ldw	r2,-20(fp)
  209838:	1887883a 	add	r3,r3,r2
  20983c:	e0bff817 	ldw	r2,-32(fp)
  209840:	10c00a15 	stw	r3,40(r2)
		}
		rcnt = 512 - (UINT)fs->fptr % 512;			/* Get partial sector data from sector buffer */
  209844:	e0bff817 	ldw	r2,-32(fp)
  209848:	10800617 	ldw	r2,24(r2)
  20984c:	10807fcc 	andi	r2,r2,511
  209850:	00c08004 	movi	r3,512
  209854:	1885c83a 	sub	r2,r3,r2
  209858:	e0bff615 	stw	r2,-40(fp)
		if (rcnt > btr) rcnt = btr;
  20985c:	e0bff617 	ldw	r2,-40(fp)
  209860:	e0fffe17 	ldw	r3,-8(fp)
  209864:	1880022e 	bgeu	r3,r2,209870 <pf_read+0x194>
  209868:	e0bffe17 	ldw	r2,-8(fp)
  20986c:	e0bff615 	stw	r2,-40(fp)
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
  209870:	e0bffd17 	ldw	r2,-12(fp)
  209874:	10000226 	beq	r2,zero,209880 <pf_read+0x1a4>
  209878:	e0bff717 	ldw	r2,-36(fp)
  20987c:	00000106 	br	209884 <pf_read+0x1a8>
  209880:	0005883a 	mov	r2,zero
  209884:	e0fff817 	ldw	r3,-32(fp)
  209888:	19400a17 	ldw	r5,40(r3)
  20988c:	e0fff817 	ldw	r3,-32(fp)
  209890:	18c00617 	ldw	r3,24(r3)
  209894:	18c07fcc 	andi	r3,r3,511
  209898:	1009883a 	mov	r4,r2
  20989c:	180d883a 	mov	r6,r3
  2098a0:	e1fff617 	ldw	r7,-40(fp)
  2098a4:	02082280 	call	208228 <disk_readp>
  2098a8:	e0bffc15 	stw	r2,-16(fp)
		if (dr) ABORT(FR_DISK_ERR);
  2098ac:	e0bffc17 	ldw	r2,-16(fp)
  2098b0:	10000426 	beq	r2,zero,2098c4 <pf_read+0x1e8>
  2098b4:	e0bff817 	ldw	r2,-32(fp)
  2098b8:	10000045 	stb	zero,1(r2)
  2098bc:	00800044 	movi	r2,1
  2098c0:	00001706 	br	209920 <pf_read+0x244>
		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
  2098c4:	e0bff817 	ldw	r2,-32(fp)
  2098c8:	10c00617 	ldw	r3,24(r2)
  2098cc:	e0bff617 	ldw	r2,-40(fp)
  2098d0:	1887883a 	add	r3,r3,r2
  2098d4:	e0bff817 	ldw	r2,-32(fp)
  2098d8:	10c00615 	stw	r3,24(r2)
  2098dc:	e0fff717 	ldw	r3,-36(fp)
  2098e0:	e0bff617 	ldw	r2,-40(fp)
  2098e4:	1885883a 	add	r2,r3,r2
  2098e8:	e0bff715 	stw	r2,-36(fp)
		btr -= rcnt; *br += rcnt;
  2098ec:	e0fffe17 	ldw	r3,-8(fp)
  2098f0:	e0bff617 	ldw	r2,-40(fp)
  2098f4:	1885c83a 	sub	r2,r3,r2
  2098f8:	e0bffe15 	stw	r2,-8(fp)
  2098fc:	e0bfff17 	ldw	r2,-4(fp)
  209900:	10c00017 	ldw	r3,0(r2)
  209904:	e0bff617 	ldw	r2,-40(fp)
  209908:	1887883a 	add	r3,r3,r2
  20990c:	e0bfff17 	ldw	r2,-4(fp)
  209910:	10c00015 	stw	r3,0(r2)
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	while (btr)	{									/* Repeat until all data transferred */
  209914:	e0bffe17 	ldw	r2,-8(fp)
  209918:	103f951e 	bne	r2,zero,209770 <_gp+0xffff3b80>
		if (dr) ABORT(FR_DISK_ERR);
		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
		btr -= rcnt; *br += rcnt;
	}

	return FR_OK;
  20991c:	0005883a 	mov	r2,zero
}
  209920:	e037883a 	mov	sp,fp
  209924:	dfc00117 	ldw	ra,4(sp)
  209928:	df000017 	ldw	fp,0(sp)
  20992c:	dec00204 	addi	sp,sp,8
  209930:	f800283a 	ret

00209934 <pf_opendir>:

FRESULT pf_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const char *path	/* Pointer to the directory path */
)
{
  209934:	deffef04 	addi	sp,sp,-68
  209938:	dfc01015 	stw	ra,64(sp)
  20993c:	df000f15 	stw	fp,60(sp)
  209940:	df000f04 	addi	fp,sp,60
  209944:	e13ffe15 	stw	r4,-8(fp)
  209948:	e17fff15 	stw	r5,-4(fp)
	FRESULT res;
	BYTE sp[12], dir[32];
	FATFS *fs = FatFs;
  20994c:	d0a0c917 	ldw	r2,-31964(gp)
  209950:	e0bff215 	stw	r2,-56(fp)


	if (!fs) {				/* Check file system */
  209954:	e0bff217 	ldw	r2,-56(fp)
  209958:	1000031e 	bne	r2,zero,209968 <pf_opendir+0x34>
		res = FR_NOT_ENABLED;
  20995c:	00800144 	movi	r2,5
  209960:	e0bff115 	stw	r2,-60(fp)
  209964:	00002006 	br	2099e8 <pf_opendir+0xb4>
	} else {
		dj->fn = sp;
  209968:	e0bffe17 	ldw	r2,-8(fp)
  20996c:	e0fff304 	addi	r3,fp,-52
  209970:	10c00115 	stw	r3,4(r2)
		res = follow_path(dj, dir, path);		/* Follow the path to the directory */
  209974:	e0bff604 	addi	r2,fp,-40
  209978:	e13ffe17 	ldw	r4,-8(fp)
  20997c:	100b883a 	mov	r5,r2
  209980:	e1bfff17 	ldw	r6,-4(fp)
  209984:	0208f3c0 	call	208f3c <follow_path>
  209988:	e0bff115 	stw	r2,-60(fp)
		if (res == FR_OK) {						/* Follow completed */
  20998c:	e0bff117 	ldw	r2,-60(fp)
  209990:	1000151e 	bne	r2,zero,2099e8 <pf_opendir+0xb4>
			if (dir[0]) {						/* It is not the root dir */
  209994:	e0bff603 	ldbu	r2,-40(fp)
  209998:	10803fcc 	andi	r2,r2,255
  20999c:	10000d26 	beq	r2,zero,2099d4 <pf_opendir+0xa0>
				if (dir[DIR_Attr] & AM_DIR)		/* The object is a directory */
  2099a0:	e0bff8c3 	ldbu	r2,-29(fp)
  2099a4:	10803fcc 	andi	r2,r2,255
  2099a8:	1080040c 	andi	r2,r2,16
  2099ac:	10000726 	beq	r2,zero,2099cc <pf_opendir+0x98>
					dj->sclust = get_clust(dir);
  2099b0:	e0bff604 	addi	r2,fp,-40
  2099b4:	1009883a 	mov	r4,r2
  2099b8:	02085840 	call	208584 <get_clust>
  2099bc:	1007883a 	mov	r3,r2
  2099c0:	e0bffe17 	ldw	r2,-8(fp)
  2099c4:	10c00215 	stw	r3,8(r2)
  2099c8:	00000206 	br	2099d4 <pf_opendir+0xa0>
				else							/* The object is not a directory */
					res = FR_NO_FILE;
  2099cc:	008000c4 	movi	r2,3
  2099d0:	e0bff115 	stw	r2,-60(fp)
			}
			if (res == FR_OK)
  2099d4:	e0bff117 	ldw	r2,-60(fp)
  2099d8:	1000031e 	bne	r2,zero,2099e8 <pf_opendir+0xb4>
				res = dir_rewind(dj);			/* Rewind dir */
  2099dc:	e13ffe17 	ldw	r4,-8(fp)
  2099e0:	02086440 	call	208644 <dir_rewind>
  2099e4:	e0bff115 	stw	r2,-60(fp)
		}
	}

	return res;
  2099e8:	e0bff117 	ldw	r2,-60(fp)
}
  2099ec:	e037883a 	mov	sp,fp
  2099f0:	dfc00117 	ldw	ra,4(sp)
  2099f4:	df000017 	ldw	fp,0(sp)
  2099f8:	dec00204 	addi	sp,sp,8
  2099fc:	f800283a 	ret

00209a00 <pf_readdir>:

FRESULT pf_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
  209a00:	deffef04 	addi	sp,sp,-68
  209a04:	dfc01015 	stw	ra,64(sp)
  209a08:	df000f15 	stw	fp,60(sp)
  209a0c:	df000f04 	addi	fp,sp,60
  209a10:	e13ffe15 	stw	r4,-8(fp)
  209a14:	e17fff15 	stw	r5,-4(fp)
	FRESULT res;
	BYTE sp[12], dir[32];
	FATFS *fs = FatFs;
  209a18:	d0a0c917 	ldw	r2,-31964(gp)
  209a1c:	e0bff215 	stw	r2,-56(fp)


	if (!fs) {				/* Check file system */
  209a20:	e0bff217 	ldw	r2,-56(fp)
  209a24:	1000031e 	bne	r2,zero,209a34 <pf_readdir+0x34>
		res = FR_NOT_ENABLED;
  209a28:	00800144 	movi	r2,5
  209a2c:	e0bff115 	stw	r2,-60(fp)
  209a30:	00002306 	br	209ac0 <pf_readdir+0xc0>
	} else {
		dj->fn = sp;
  209a34:	e0bffe17 	ldw	r2,-8(fp)
  209a38:	e0fff304 	addi	r3,fp,-52
  209a3c:	10c00115 	stw	r3,4(r2)
		if (!fno) {
  209a40:	e0bfff17 	ldw	r2,-4(fp)
  209a44:	1000041e 	bne	r2,zero,209a58 <pf_readdir+0x58>
			res = dir_rewind(dj);
  209a48:	e13ffe17 	ldw	r4,-8(fp)
  209a4c:	02086440 	call	208644 <dir_rewind>
  209a50:	e0bff115 	stw	r2,-60(fp)
  209a54:	00001a06 	br	209ac0 <pf_readdir+0xc0>
		} else {
			res = dir_read(dj, dir, &fno->lfname[0]);
  209a58:	e0bfff17 	ldw	r2,-4(fp)
  209a5c:	10800584 	addi	r2,r2,22
  209a60:	e0fff604 	addi	r3,fp,-40
  209a64:	e13ffe17 	ldw	r4,-8(fp)
  209a68:	180b883a 	mov	r5,r3
  209a6c:	100d883a 	mov	r6,r2
  209a70:	02089440 	call	208944 <dir_read>
  209a74:	e0bff115 	stw	r2,-60(fp)
			if (res == FR_NO_FILE) res = FR_OK;
  209a78:	e0bff117 	ldw	r2,-60(fp)
  209a7c:	108000d8 	cmpnei	r2,r2,3
  209a80:	1000011e 	bne	r2,zero,209a88 <pf_readdir+0x88>
  209a84:	e03ff115 	stw	zero,-60(fp)
			if (res == FR_OK) {				/* A valid entry is found */
  209a88:	e0bff117 	ldw	r2,-60(fp)
  209a8c:	10000c1e 	bne	r2,zero,209ac0 <pf_readdir+0xc0>
				get_fileinfo(dj, dir, fno);	/* Get the object information */
  209a90:	e0bff604 	addi	r2,fp,-40
  209a94:	e13ffe17 	ldw	r4,-8(fp)
  209a98:	100b883a 	mov	r5,r2
  209a9c:	e1bfff17 	ldw	r6,-4(fp)
  209aa0:	0208d200 	call	208d20 <get_fileinfo>
				res = dir_next2(dj);			/* Increment index for next */
  209aa4:	e13ffe17 	ldw	r4,-8(fp)
  209aa8:	02087080 	call	208708 <dir_next2>
  209aac:	e0bff115 	stw	r2,-60(fp)
				if (res == FR_NO_FILE) res = FR_OK;
  209ab0:	e0bff117 	ldw	r2,-60(fp)
  209ab4:	108000d8 	cmpnei	r2,r2,3
  209ab8:	1000011e 	bne	r2,zero,209ac0 <pf_readdir+0xc0>
  209abc:	e03ff115 	stw	zero,-60(fp)
			}
		}
	}

	if (fno->lfname[0] == '\0') strcpy(&fno->lfname[0],&fno->fname[0]);
  209ac0:	e0bfff17 	ldw	r2,-4(fp)
  209ac4:	10800583 	ldbu	r2,22(r2)
  209ac8:	10803fcc 	andi	r2,r2,255
  209acc:	1080201c 	xori	r2,r2,128
  209ad0:	10bfe004 	addi	r2,r2,-128
  209ad4:	1000071e 	bne	r2,zero,209af4 <pf_readdir+0xf4>
  209ad8:	e0bfff17 	ldw	r2,-4(fp)
  209adc:	10c00584 	addi	r3,r2,22
  209ae0:	e0bfff17 	ldw	r2,-4(fp)
  209ae4:	10800244 	addi	r2,r2,9
  209ae8:	1809883a 	mov	r4,r3
  209aec:	100b883a 	mov	r5,r2
  209af0:	020bb740 	call	20bb74 <strcpy>
	//printf("%s %s(%d)\n",&fno->fname[0], &fno->lfname[0],strlen(&fno->lfname[0]));
	return res;
  209af4:	e0bff117 	ldw	r2,-60(fp)
}
  209af8:	e037883a 	mov	sp,fp
  209afc:	dfc00117 	ldw	ra,4(sp)
  209b00:	df000017 	ldw	fp,0(sp)
  209b04:	dec00204 	addi	sp,sp,8
  209b08:	f800283a 	ret

00209b0c <SetLowSpeed>:
/*  In    : none                                                           */
/*  Out   : none                                                           */
/*  Return: none                                                           */
/***************************************************************************/
static void SetLowSpeed(void)
{
  209b0c:	deffff04 	addi	sp,sp,-4
  209b10:	df000015 	stw	fp,0(sp)
  209b14:	d839883a 	mov	fp,sp
   Control1 &= ~0xFF00;
  209b18:	d0e0cc17 	ldw	r3,-31952(gp)
  209b1c:	00bffff4 	movhi	r2,65535
  209b20:	10803fc4 	addi	r2,r2,255
  209b24:	1884703a 	and	r2,r3,r2
  209b28:	d0a0cc15 	stw	r2,-31952(gp)
   Control1 |= (124 << 8); // 124 for 50Mhz CPU (was 249)
  209b2c:	d0a0cc17 	ldw	r2,-31952(gp)
  209b30:	109f0014 	ori	r2,r2,31744
  209b34:	d0a0cc15 	stw	r2,-31952(gp)
   SPI_CTRL  = Control1;
  209b38:	00a00874 	movhi	r2,32801
  209b3c:	10940204 	addi	r2,r2,20488
  209b40:	d0e0cc17 	ldw	r3,-31952(gp)
  209b44:	10c00015 	stw	r3,0(r2)
} /* SetLowSpeed */
  209b48:	e037883a 	mov	sp,fp
  209b4c:	df000017 	ldw	fp,0(sp)
  209b50:	dec00104 	addi	sp,sp,4
  209b54:	f800283a 	ret

00209b58 <SetHighSpeed>:
/*  In    : none                                                           */
/*  Out   : none                                                           */
/*  Return: none                                                           */
/***************************************************************************/
static void SetHighSpeed(void)
{
  209b58:	deffff04 	addi	sp,sp,-4
  209b5c:	df000015 	stw	fp,0(sp)
  209b60:	d839883a 	mov	fp,sp
   Control1 &= ~0xFF00;
  209b64:	d0e0cc17 	ldw	r3,-31952(gp)
  209b68:	00bffff4 	movhi	r2,65535
  209b6c:	10803fc4 	addi	r2,r2,255
  209b70:	1884703a 	and	r2,r3,r2
  209b74:	d0a0cc15 	stw	r2,-31952(gp)

   if (0 == (CardType & 0x01))
  209b78:	d0a0ca03 	ldbu	r2,-31960(gp)
  209b7c:	10803fcc 	andi	r2,r2,255
  209b80:	1080004c 	andi	r2,r2,1
  209b84:	1000041e 	bne	r2,zero,209b98 <SetHighSpeed+0x40>
   {
      /* SD card 25 MHz */
	  Control1 |= (1 << 8); // should be 0 for 50Mhz CPU, but doesn't work on SanDisk ultra
  209b88:	d0a0cc17 	ldw	r2,-31952(gp)
  209b8c:	10804014 	ori	r2,r2,256
  209b90:	d0a0cc15 	stw	r2,-31952(gp)
  209b94:	00000306 	br	209ba4 <SetHighSpeed+0x4c>
   }
   else
   {
      /* MMC card 16 MHz */
      Control1 |= (2 << 8);
  209b98:	d0a0cc17 	ldw	r2,-31952(gp)
  209b9c:	10808014 	ori	r2,r2,512
  209ba0:	d0a0cc15 	stw	r2,-31952(gp)
   }
   SPI_CTRL  = Control1;
  209ba4:	00a00874 	movhi	r2,32801
  209ba8:	10940204 	addi	r2,r2,20488
  209bac:	d0e0cc17 	ldw	r3,-31952(gp)
  209bb0:	10c00015 	stw	r3,0(r2)
} /* SetHighSpeed */
  209bb4:	e037883a 	mov	sp,fp
  209bb8:	df000017 	ldw	fp,0(sp)
  209bbc:	dec00104 	addi	sp,sp,4
  209bc0:	f800283a 	ret

00209bc4 <Set8BitTransfer>:
/*  In    : none                                                           */
/*  Out   : none                                                           */
/*  Return: none                                                           */
/***************************************************************************/
static void Set8BitTransfer(void)
{
  209bc4:	deffff04 	addi	sp,sp,-4
  209bc8:	df000015 	stw	fp,0(sp)
  209bcc:	d839883a 	mov	fp,sp
   Control1 &= ~CTRL_BIT32;
  209bd0:	d0e0cc17 	ldw	r3,-31952(gp)
  209bd4:	00bfff44 	movi	r2,-3
  209bd8:	1884703a 	and	r2,r3,r2
  209bdc:	d0a0cc15 	stw	r2,-31952(gp)
   SPI_CTRL  = Control1;
  209be0:	00a00874 	movhi	r2,32801
  209be4:	10940204 	addi	r2,r2,20488
  209be8:	d0e0cc17 	ldw	r3,-31952(gp)
  209bec:	10c00015 	stw	r3,0(r2)
} /* Set8BitTransfer */
  209bf0:	e037883a 	mov	sp,fp
  209bf4:	df000017 	ldw	fp,0(sp)
  209bf8:	dec00104 	addi	sp,sp,4
  209bfc:	f800283a 	ret

00209c00 <Set32BitTransfer>:
/*  In    : none                                                           */
/*  Out   : none                                                           */
/*  Return: none                                                           */
/***************************************************************************/
static void Set32BitTransfer(void)
{
  209c00:	deffff04 	addi	sp,sp,-4
  209c04:	df000015 	stw	fp,0(sp)
  209c08:	d839883a 	mov	fp,sp
   Control1 |= CTRL_BIT32;
  209c0c:	d0a0cc17 	ldw	r2,-31952(gp)
  209c10:	10800094 	ori	r2,r2,2
  209c14:	d0a0cc15 	stw	r2,-31952(gp)
   SPI_CTRL  = Control1;
  209c18:	00a00874 	movhi	r2,32801
  209c1c:	10940204 	addi	r2,r2,20488
  209c20:	d0e0cc17 	ldw	r3,-31952(gp)
  209c24:	10c00015 	stw	r3,0(r2)
} /* Set32BitTransfer */
  209c28:	e037883a 	mov	sp,fp
  209c2c:	df000017 	ldw	fp,0(sp)
  209c30:	dec00104 	addi	sp,sp,4
  209c34:	f800283a 	ret

00209c38 <ReceiveU8>:
/*  In    : none                                                           */
/*  Out   : none                                                           */
/*  Return: Data                                                           */
/***************************************************************************/
static FFS_U8 ReceiveU8 (void)
{
  209c38:	deffff04 	addi	sp,sp,-4
  209c3c:	df000015 	stw	fp,0(sp)
  209c40:	d839883a 	mov	fp,sp
   SPI_TXR = (uint32_t) 0xff;
  209c44:	00a00874 	movhi	r2,32801
  209c48:	10940004 	addi	r2,r2,20480
  209c4c:	00c03fc4 	movi	r3,255
  209c50:	10c00015 	stw	r3,0(r2)

   /* wait for char */
   while (!(SPI_SR & SPI_SR_DONE)) ;
  209c54:	0001883a 	nop
  209c58:	00a00874 	movhi	r2,32801
  209c5c:	10940304 	addi	r2,r2,20492
  209c60:	10800017 	ldw	r2,0(r2)
  209c64:	1080004c 	andi	r2,r2,1
  209c68:	103ffb26 	beq	r2,zero,209c58 <_gp+0xffff4068>

   return(SPI_RXR);
  209c6c:	00a00874 	movhi	r2,32801
  209c70:	10940104 	addi	r2,r2,20484
  209c74:	10800017 	ldw	r2,0(r2)
} /* ReceiveU8 */
  209c78:	e037883a 	mov	sp,fp
  209c7c:	df000017 	ldw	fp,0(sp)
  209c80:	dec00104 	addi	sp,sp,4
  209c84:	f800283a 	ret

00209c88 <ReceiveDatablock>:
/*  In    : buff, btr                                                      */
/*  Out   : none                                                           */
/*  Return: In case of an error return FALSE                               */
/***************************************************************************/
static int ReceiveDatablock(FFS_U8 * buff, uint32_t btr)
{
  209c88:	defff904 	addi	sp,sp,-28
  209c8c:	dfc00615 	stw	ra,24(sp)
  209c90:	df000515 	stw	fp,20(sp)
  209c94:	df000504 	addi	fp,sp,20
  209c98:	e13ffe15 	stw	r4,-8(fp)
  209c9c:	e17fff15 	stw	r5,-4(fp)
   FFS_U8 token, cnt;
   FFS_U32 *buff32 = (FFS_U32*)buff;
  209ca0:	e0bffe17 	ldw	r2,-8(fp)
  209ca4:	e0bffc15 	stw	r2,-16(fp)

   Timer1 = 10;
  209ca8:	00800284 	movi	r2,10
  209cac:	d0a0ca8d 	sth	r2,-31958(gp)
   do /* Wait for data packet in timeout of 100ms */
   {
      token = ReceiveU8();
  209cb0:	0209c380 	call	209c38 <ReceiveU8>
  209cb4:	e0bffd05 	stb	r2,-12(fp)
   }
   while ((token == 0xFF) && Timer1);
  209cb8:	e0bffd03 	ldbu	r2,-12(fp)
  209cbc:	10803fd8 	cmpnei	r2,r2,255
  209cc0:	1000031e 	bne	r2,zero,209cd0 <ReceiveDatablock+0x48>
  209cc4:	d0a0ca8b 	ldhu	r2,-31958(gp)
  209cc8:	10bfffcc 	andi	r2,r2,65535
  209ccc:	103ff81e 	bne	r2,zero,209cb0 <_gp+0xffff40c0>

   if (token != 0xFE)
  209cd0:	e0bffd03 	ldbu	r2,-12(fp)
  209cd4:	10803fa0 	cmpeqi	r2,r2,254
  209cd8:	1000021e 	bne	r2,zero,209ce4 <ReceiveDatablock+0x5c>
      return(FFS_FALSE);  /* If not valid data token, return with error */
  209cdc:	0005883a 	mov	r2,zero
  209ce0:	00002f06 	br	209da0 <ReceiveDatablock+0x118>

   /* Receive the data block into buffer */
   Set32BitTransfer();
  209ce4:	0209c000 	call	209c00 <Set32BitTransfer>

   /* Divide by 8 */
   cnt = btr >> 3;
  209ce8:	e0bfff17 	ldw	r2,-4(fp)
  209cec:	1004d0fa 	srli	r2,r2,3
  209cf0:	e0bffb05 	stb	r2,-20(fp)

   do /* Receive the data block into buffer */
   {
      RECEIVE_FAST(buff32);
  209cf4:	00a00874 	movhi	r2,32801
  209cf8:	10940004 	addi	r2,r2,20480
  209cfc:	00ffffc4 	movi	r3,-1
  209d00:	10c00015 	stw	r3,0(r2)
  209d04:	0001883a 	nop
  209d08:	00a00874 	movhi	r2,32801
  209d0c:	10940304 	addi	r2,r2,20492
  209d10:	10800017 	ldw	r2,0(r2)
  209d14:	1080004c 	andi	r2,r2,1
  209d18:	103ffb26 	beq	r2,zero,209d08 <_gp+0xffff4118>
  209d1c:	e0bffc17 	ldw	r2,-16(fp)
  209d20:	10c00104 	addi	r3,r2,4
  209d24:	e0fffc15 	stw	r3,-16(fp)
  209d28:	00e00874 	movhi	r3,32801
  209d2c:	18d40104 	addi	r3,r3,20484
  209d30:	18c00017 	ldw	r3,0(r3)
  209d34:	10c00015 	stw	r3,0(r2)
      RECEIVE_FAST(buff32);
  209d38:	00a00874 	movhi	r2,32801
  209d3c:	10940004 	addi	r2,r2,20480
  209d40:	00ffffc4 	movi	r3,-1
  209d44:	10c00015 	stw	r3,0(r2)
  209d48:	0001883a 	nop
  209d4c:	00a00874 	movhi	r2,32801
  209d50:	10940304 	addi	r2,r2,20492
  209d54:	10800017 	ldw	r2,0(r2)
  209d58:	1080004c 	andi	r2,r2,1
  209d5c:	103ffb26 	beq	r2,zero,209d4c <_gp+0xffff415c>
  209d60:	e0bffc17 	ldw	r2,-16(fp)
  209d64:	10c00104 	addi	r3,r2,4
  209d68:	e0fffc15 	stw	r3,-16(fp)
  209d6c:	00e00874 	movhi	r3,32801
  209d70:	18d40104 	addi	r3,r3,20484
  209d74:	18c00017 	ldw	r3,0(r3)
  209d78:	10c00015 	stw	r3,0(r2)
   }
   while (--cnt);
  209d7c:	e0bffb03 	ldbu	r2,-20(fp)
  209d80:	10bfffc4 	addi	r2,r2,-1
  209d84:	e0bffb05 	stb	r2,-20(fp)
  209d88:	e0bffb03 	ldbu	r2,-20(fp)
  209d8c:	103fd91e 	bne	r2,zero,209cf4 <_gp+0xffff4104>

   Set8BitTransfer();
  209d90:	0209bc40 	call	209bc4 <Set8BitTransfer>
   ReceiveU8();   /* Discard CRC */
  209d94:	0209c380 	call	209c38 <ReceiveU8>
   ReceiveU8();   /* Discard CRC */
  209d98:	0209c380 	call	209c38 <ReceiveU8>

   return(FFS_TRUE);  /* Return with success */
  209d9c:	00800044 	movi	r2,1
} /* ReceiveDatablock */
  209da0:	e037883a 	mov	sp,fp
  209da4:	dfc00117 	ldw	ra,4(sp)
  209da8:	df000017 	ldw	fp,0(sp)
  209dac:	dec00204 	addi	sp,sp,8
  209db0:	f800283a 	ret

00209db4 <WaitReady>:

/*-----------------------------------------------------------------------*/
/* Wait for card ready                                                   */
/*-----------------------------------------------------------------------*/
static FFS_U8 WaitReady(void)
{
  209db4:	defffd04 	addi	sp,sp,-12
  209db8:	dfc00215 	stw	ra,8(sp)
  209dbc:	df000115 	stw	fp,4(sp)
  209dc0:	df000104 	addi	fp,sp,4
   FFS_U8 res;

   Timer2 = (WAIT_READY_TIME_MAX_MS / 10);
  209dc4:	00800c84 	movi	r2,50
  209dc8:	d0a0cb0d 	sth	r2,-31956(gp)
   ReceiveU8();
  209dcc:	0209c380 	call	209c38 <ReceiveU8>
   do
   {
      res = ReceiveU8();
  209dd0:	0209c380 	call	209c38 <ReceiveU8>
  209dd4:	e0bfff05 	stb	r2,-4(fp)
   }
   while ((res != 0xFF) && Timer2);
  209dd8:	e0bfff03 	ldbu	r2,-4(fp)
  209ddc:	10803fe0 	cmpeqi	r2,r2,255
  209de0:	1000031e 	bne	r2,zero,209df0 <WaitReady+0x3c>
  209de4:	d0a0cb0b 	ldhu	r2,-31956(gp)
  209de8:	10bfffcc 	andi	r2,r2,65535
  209dec:	103ff81e 	bne	r2,zero,209dd0 <_gp+0xffff41e0>

   return(res);
  209df0:	e0bfff03 	ldbu	r2,-4(fp)
} /* WaitReady */
  209df4:	e037883a 	mov	sp,fp
  209df8:	dfc00117 	ldw	ra,4(sp)
  209dfc:	df000017 	ldw	fp,0(sp)
  209e00:	dec00204 	addi	sp,sp,8
  209e04:	f800283a 	ret

00209e08 <ReleaseBus>:

/*-----------------------------------------------------------------------*/
/* Deselect the card and release SPI bus                                 */
/*-----------------------------------------------------------------------*/
static void ReleaseBus(void)
{
  209e08:	defffe04 	addi	sp,sp,-8
  209e0c:	dfc00115 	stw	ra,4(sp)
  209e10:	df000015 	stw	fp,0(sp)
  209e14:	d839883a 	mov	fp,sp
    * master device must send a byte after deasserted CS signal.
    *
    * More information can be found here:
    * http://elm-chan.org/docs/mmc/mmc_e.html
    */
   DESELECT();
  209e18:	d0a0cc17 	ldw	r2,-31952(gp)
  209e1c:	10800054 	ori	r2,r2,1
  209e20:	d0a0cc15 	stw	r2,-31952(gp)
  209e24:	00a00874 	movhi	r2,32801
  209e28:	10940204 	addi	r2,r2,20488
  209e2c:	d0e0cc17 	ldw	r3,-31952(gp)
  209e30:	10c00015 	stw	r3,0(r2)
   ReceiveU8();
  209e34:	0209c380 	call	209c38 <ReceiveU8>
} /* ReleaseBus */
  209e38:	e037883a 	mov	sp,fp
  209e3c:	dfc00117 	ldw	ra,4(sp)
  209e40:	df000017 	ldw	fp,0(sp)
  209e44:	dec00204 	addi	sp,sp,8
  209e48:	f800283a 	ret

00209e4c <SendCMD>:
/*-----------------------------------------------------------------------*/
/* Send a command packet to MMC                                          */
/*-----------------------------------------------------------------------*/
static FFS_U8 SendCMD(FFS_U8 cmd,   /* Command byte */
                       FFS_U32 arg)  /* Argument */
{
  209e4c:	defffb04 	addi	sp,sp,-20
  209e50:	dfc00415 	stw	ra,16(sp)
  209e54:	df000315 	stw	fp,12(sp)
  209e58:	df000304 	addi	fp,sp,12
  209e5c:	2005883a 	mov	r2,r4
  209e60:	e17fff15 	stw	r5,-4(fp)
  209e64:	e0bffe05 	stb	r2,-8(fp)
   FFS_U8 n, res;

   if (cmd & 0x80)   /* ACMD<n> is the command sequense of CMD55-CMD<n> */
  209e68:	e0bffe03 	ldbu	r2,-8(fp)
  209e6c:	10803fcc 	andi	r2,r2,255
  209e70:	1080201c 	xori	r2,r2,128
  209e74:	10bfe004 	addi	r2,r2,-128
  209e78:	10000c0e 	bge	r2,zero,209eac <SendCMD+0x60>
   {
      cmd &= 0x7F;
  209e7c:	e0bffe03 	ldbu	r2,-8(fp)
  209e80:	10801fcc 	andi	r2,r2,127
  209e84:	e0bffe05 	stb	r2,-8(fp)
      res = SendCMD(CMD55, 0);
  209e88:	01001dc4 	movi	r4,119
  209e8c:	000b883a 	mov	r5,zero
  209e90:	0209e4c0 	call	209e4c <SendCMD>
  209e94:	e0bffd45 	stb	r2,-11(fp)
      if (res > 1)
  209e98:	e0bffd43 	ldbu	r2,-11(fp)
  209e9c:	108000b0 	cmpltui	r2,r2,2
  209ea0:	1000021e 	bne	r2,zero,209eac <SendCMD+0x60>
         return res;
  209ea4:	e0bffd43 	ldbu	r2,-11(fp)
  209ea8:	00007706 	br	20a088 <SendCMD+0x23c>
   }

   /* Select the card and wait for ready */
   DESELECT();
  209eac:	d0a0cc17 	ldw	r2,-31952(gp)
  209eb0:	10800054 	ori	r2,r2,1
  209eb4:	d0a0cc15 	stw	r2,-31952(gp)
  209eb8:	00a00874 	movhi	r2,32801
  209ebc:	10940204 	addi	r2,r2,20488
  209ec0:	d0e0cc17 	ldw	r3,-31952(gp)
  209ec4:	10c00015 	stw	r3,0(r2)
   SELECT();
  209ec8:	d0e0cc17 	ldw	r3,-31952(gp)
  209ecc:	00bfff84 	movi	r2,-2
  209ed0:	1884703a 	and	r2,r3,r2
  209ed4:	d0a0cc15 	stw	r2,-31952(gp)
  209ed8:	00a00874 	movhi	r2,32801
  209edc:	10940204 	addi	r2,r2,20488
  209ee0:	d0e0cc17 	ldw	r3,-31952(gp)
  209ee4:	10c00015 	stw	r3,0(r2)

   if (WaitReady() != 0xFF)
  209ee8:	0209db40 	call	209db4 <WaitReady>
  209eec:	10803fcc 	andi	r2,r2,255
  209ef0:	10803fe0 	cmpeqi	r2,r2,255
  209ef4:	1000021e 	bne	r2,zero,209f00 <SendCMD+0xb4>
      return 0xFF;
  209ef8:	00bfffc4 	movi	r2,-1
  209efc:	00006206 	br	20a088 <SendCMD+0x23c>

   /* Send command packet */
   TRANSMIT_U8(cmd); /* Start + Command index */
  209f00:	00a00874 	movhi	r2,32801
  209f04:	10940004 	addi	r2,r2,20480
  209f08:	e0fffe03 	ldbu	r3,-8(fp)
  209f0c:	10c00015 	stw	r3,0(r2)
  209f10:	0001883a 	nop
  209f14:	00a00874 	movhi	r2,32801
  209f18:	10940304 	addi	r2,r2,20492
  209f1c:	10800017 	ldw	r2,0(r2)
  209f20:	1080004c 	andi	r2,r2,1
  209f24:	103ffb26 	beq	r2,zero,209f14 <_gp+0xffff4324>
   TRANSMIT_U8((FFS_U8) (arg >> 24));  /* Argument[31..24] */
  209f28:	00a00874 	movhi	r2,32801
  209f2c:	10940004 	addi	r2,r2,20480
  209f30:	e0ffff17 	ldw	r3,-4(fp)
  209f34:	1806d63a 	srli	r3,r3,24
  209f38:	18c03fcc 	andi	r3,r3,255
  209f3c:	10c00015 	stw	r3,0(r2)
  209f40:	0001883a 	nop
  209f44:	00a00874 	movhi	r2,32801
  209f48:	10940304 	addi	r2,r2,20492
  209f4c:	10800017 	ldw	r2,0(r2)
  209f50:	1080004c 	andi	r2,r2,1
  209f54:	103ffb26 	beq	r2,zero,209f44 <_gp+0xffff4354>
   TRANSMIT_U8((FFS_U8) (arg >> 16));  /* Argument[23..16] */
  209f58:	00a00874 	movhi	r2,32801
  209f5c:	10940004 	addi	r2,r2,20480
  209f60:	e0ffff17 	ldw	r3,-4(fp)
  209f64:	1806d43a 	srli	r3,r3,16
  209f68:	18c03fcc 	andi	r3,r3,255
  209f6c:	10c00015 	stw	r3,0(r2)
  209f70:	0001883a 	nop
  209f74:	00a00874 	movhi	r2,32801
  209f78:	10940304 	addi	r2,r2,20492
  209f7c:	10800017 	ldw	r2,0(r2)
  209f80:	1080004c 	andi	r2,r2,1
  209f84:	103ffb26 	beq	r2,zero,209f74 <_gp+0xffff4384>
   TRANSMIT_U8((FFS_U8) (arg >> 8));   /* Argument[15..8] */
  209f88:	00a00874 	movhi	r2,32801
  209f8c:	10940004 	addi	r2,r2,20480
  209f90:	e0ffff17 	ldw	r3,-4(fp)
  209f94:	1806d23a 	srli	r3,r3,8
  209f98:	18c03fcc 	andi	r3,r3,255
  209f9c:	10c00015 	stw	r3,0(r2)
  209fa0:	0001883a 	nop
  209fa4:	00a00874 	movhi	r2,32801
  209fa8:	10940304 	addi	r2,r2,20492
  209fac:	10800017 	ldw	r2,0(r2)
  209fb0:	1080004c 	andi	r2,r2,1
  209fb4:	103ffb26 	beq	r2,zero,209fa4 <_gp+0xffff43b4>
   TRANSMIT_U8((FFS_U8) arg); /* Argument[7..0] */
  209fb8:	00a00874 	movhi	r2,32801
  209fbc:	10940004 	addi	r2,r2,20480
  209fc0:	e0ffff17 	ldw	r3,-4(fp)
  209fc4:	18c03fcc 	andi	r3,r3,255
  209fc8:	10c00015 	stw	r3,0(r2)
  209fcc:	0001883a 	nop
  209fd0:	00a00874 	movhi	r2,32801
  209fd4:	10940304 	addi	r2,r2,20492
  209fd8:	10800017 	ldw	r2,0(r2)
  209fdc:	1080004c 	andi	r2,r2,1
  209fe0:	103ffb26 	beq	r2,zero,209fd0 <_gp+0xffff43e0>

   n = 0x01;   /* Dummy CRC + Stop */
  209fe4:	00800044 	movi	r2,1
  209fe8:	e0bffd05 	stb	r2,-12(fp)
   if (cmd == CMD0)
  209fec:	e0bffe03 	ldbu	r2,-8(fp)
  209ff0:	10801018 	cmpnei	r2,r2,64
  209ff4:	1000021e 	bne	r2,zero,20a000 <SendCMD+0x1b4>
      n = 0x95;   /* Valid CRC for CMD0(0) */
  209ff8:	00bfe544 	movi	r2,-107
  209ffc:	e0bffd05 	stb	r2,-12(fp)
   if (cmd == CMD8)
  20a000:	e0bffe03 	ldbu	r2,-8(fp)
  20a004:	10801218 	cmpnei	r2,r2,72
  20a008:	1000021e 	bne	r2,zero,20a014 <SendCMD+0x1c8>
      n = 0x87;   /* Valid CRC for CMD8(0x1AA) */
  20a00c:	00bfe1c4 	movi	r2,-121
  20a010:	e0bffd05 	stb	r2,-12(fp)
   TRANSMIT_U8(n);
  20a014:	00a00874 	movhi	r2,32801
  20a018:	10940004 	addi	r2,r2,20480
  20a01c:	e0fffd03 	ldbu	r3,-12(fp)
  20a020:	10c00015 	stw	r3,0(r2)
  20a024:	0001883a 	nop
  20a028:	00a00874 	movhi	r2,32801
  20a02c:	10940304 	addi	r2,r2,20492
  20a030:	10800017 	ldw	r2,0(r2)
  20a034:	1080004c 	andi	r2,r2,1
  20a038:	103ffb26 	beq	r2,zero,20a028 <_gp+0xffff4438>

   /* Receive command response */
   if (cmd == CMD12)
  20a03c:	e0bffe03 	ldbu	r2,-8(fp)
  20a040:	10801318 	cmpnei	r2,r2,76
  20a044:	1000011e 	bne	r2,zero,20a04c <SendCMD+0x200>
      ReceiveU8();   /* Skip a stuff byte when stop reading */
  20a048:	0209c380 	call	209c38 <ReceiveU8>

   n = 10;  /* Wait for a valid response in timeout of 10 attempts */
  20a04c:	00800284 	movi	r2,10
  20a050:	e0bffd05 	stb	r2,-12(fp)
   do
   {
      res = ReceiveU8();
  20a054:	0209c380 	call	209c38 <ReceiveU8>
  20a058:	e0bffd45 	stb	r2,-11(fp)
   }
   while ((res & 0x80) && --n);
  20a05c:	e0bffd43 	ldbu	r2,-11(fp)
  20a060:	10803fcc 	andi	r2,r2,255
  20a064:	1080201c 	xori	r2,r2,128
  20a068:	10bfe004 	addi	r2,r2,-128
  20a06c:	1000050e 	bge	r2,zero,20a084 <SendCMD+0x238>
  20a070:	e0bffd03 	ldbu	r2,-12(fp)
  20a074:	10bfffc4 	addi	r2,r2,-1
  20a078:	e0bffd05 	stb	r2,-12(fp)
  20a07c:	e0bffd03 	ldbu	r2,-12(fp)
  20a080:	103ff41e 	bne	r2,zero,20a054 <_gp+0xffff4464>

   return(res); /* Return with the response value */
  20a084:	e0bffd43 	ldbu	r2,-11(fp)
} /* SendCMD */
  20a088:	e037883a 	mov	sp,fp
  20a08c:	dfc00117 	ldw	ra,4(sp)
  20a090:	df000017 	ldw	fp,0(sp)
  20a094:	dec00204 	addi	sp,sp,8
  20a098:	f800283a 	ret

0020a09c <ffs_DiskIOTimerproc>:


void ffs_DiskIOTimerproc()
{
  20a09c:	defffe04 	addi	sp,sp,-8
  20a0a0:	df000115 	stw	fp,4(sp)
  20a0a4:	df000104 	addi	fp,sp,4
   FFS_U32 n;

   /* 100Hz decrement timer */
   n = Timer1;
  20a0a8:	d0a0ca8b 	ldhu	r2,-31958(gp)
  20a0ac:	10bfffcc 	andi	r2,r2,65535
  20a0b0:	e0bfff15 	stw	r2,-4(fp)
   if (n)
  20a0b4:	e0bfff17 	ldw	r2,-4(fp)
  20a0b8:	10000526 	beq	r2,zero,20a0d0 <ffs_DiskIOTimerproc+0x34>
      Timer1 = (FFS_U16)-- n;
  20a0bc:	e0bfff17 	ldw	r2,-4(fp)
  20a0c0:	10bfffc4 	addi	r2,r2,-1
  20a0c4:	e0bfff15 	stw	r2,-4(fp)
  20a0c8:	e0bfff17 	ldw	r2,-4(fp)
  20a0cc:	d0a0ca8d 	sth	r2,-31958(gp)
   n = Timer2;
  20a0d0:	d0a0cb0b 	ldhu	r2,-31956(gp)
  20a0d4:	10bfffcc 	andi	r2,r2,65535
  20a0d8:	e0bfff15 	stw	r2,-4(fp)
   if (n)
  20a0dc:	e0bfff17 	ldw	r2,-4(fp)
  20a0e0:	10000526 	beq	r2,zero,20a0f8 <ffs_DiskIOTimerproc+0x5c>
      Timer2 = (FFS_U16)-- n;
  20a0e4:	e0bfff17 	ldw	r2,-4(fp)
  20a0e8:	10bfffc4 	addi	r2,r2,-1
  20a0ec:	e0bfff15 	stw	r2,-4(fp)
  20a0f0:	e0bfff17 	ldw	r2,-4(fp)
  20a0f4:	d0a0cb0d 	sth	r2,-31956(gp)
}
  20a0f8:	e037883a 	mov	sp,fp
  20a0fc:	df000017 	ldw	fp,0(sp)
  20a100:	dec00104 	addi	sp,sp,4
  20a104:	f800283a 	ret

0020a108 <ffs_DiskIOInit>:

void ffs_DiskIOInit()
{
  20a108:	defffe04 	addi	sp,sp,-8
  20a10c:	dfc00115 	stw	ra,4(sp)
  20a110:	df000015 	stw	fp,0(sp)
  20a114:	d839883a 	mov	fp,sp
	   /*
	    * Deselct before to prevent glitch
	    */
	   DESELECT();
  20a118:	d0a0cc17 	ldw	r2,-31952(gp)
  20a11c:	10800054 	ori	r2,r2,1
  20a120:	d0a0cc15 	stw	r2,-31952(gp)
  20a124:	00a00874 	movhi	r2,32801
  20a128:	10940204 	addi	r2,r2,20488
  20a12c:	d0e0cc17 	ldw	r3,-31952(gp)
  20a130:	10c00015 	stw	r3,0(r2)

	   /* Slow during init */
	   SetLowSpeed();
  20a134:	0209b0c0 	call	209b0c <SetLowSpeed>
}
  20a138:	e037883a 	mov	sp,fp
  20a13c:	dfc00117 	ldw	ra,4(sp)
  20a140:	df000017 	ldw	fp,0(sp)
  20a144:	dec00204 	addi	sp,sp,8
  20a148:	f800283a 	ret

0020a14c <ffs_DiskIOInitialize>:

DSTATUS ffs_DiskIOInitialize()
{
  20a14c:	defffb04 	addi	sp,sp,-20
  20a150:	dfc00415 	stw	ra,16(sp)
  20a154:	df000315 	stw	fp,12(sp)
  20a158:	dc000215 	stw	r16,8(sp)
  20a15c:	df000304 	addi	fp,sp,12
   FFS_U8 n, ty, cmd, ocr[4];

   if (Stat & STA_NODISK)  /* No card in the socket */
  20a160:	d0a00003 	ldbu	r2,-32768(gp)
  20a164:	10803fcc 	andi	r2,r2,255
  20a168:	1080008c 	andi	r2,r2,2
  20a16c:	10000226 	beq	r2,zero,20a178 <ffs_DiskIOInitialize+0x2c>
        return Stat;
  20a170:	d0a00003 	ldbu	r2,-32768(gp)
  20a174:	00008406 	br	20a388 <ffs_DiskIOInitialize+0x23c>

     /* low speed during init */
     SetLowSpeed();
  20a178:	0209b0c0 	call	209b0c <SetLowSpeed>

     POWER_ON(); /* Force socket power ON */
     for (n = 10; n; n--)
  20a17c:	00800284 	movi	r2,10
  20a180:	e0bffd05 	stb	r2,-12(fp)
  20a184:	00000406 	br	20a198 <ffs_DiskIOInitialize+0x4c>
        ReceiveU8();   /* 80 dummy clocks */
  20a188:	0209c380 	call	209c38 <ReceiveU8>

     /* low speed during init */
     SetLowSpeed();

     POWER_ON(); /* Force socket power ON */
     for (n = 10; n; n--)
  20a18c:	e0bffd03 	ldbu	r2,-12(fp)
  20a190:	10bfffc4 	addi	r2,r2,-1
  20a194:	e0bffd05 	stb	r2,-12(fp)
  20a198:	e0bffd03 	ldbu	r2,-12(fp)
  20a19c:	103ffa1e 	bne	r2,zero,20a188 <_gp+0xffff4598>
        ReceiveU8();   /* 80 dummy clocks */

     ty = 0;
  20a1a0:	e03ffd45 	stb	zero,-11(fp)
     if (SendCMD(CMD0, 0) == 1)
  20a1a4:	01001004 	movi	r4,64
  20a1a8:	000b883a 	mov	r5,zero
  20a1ac:	0209e4c0 	call	209e4c <SendCMD>
  20a1b0:	10803fcc 	andi	r2,r2,255
  20a1b4:	10800058 	cmpnei	r2,r2,1
  20a1b8:	1000681e 	bne	r2,zero,20a35c <ffs_DiskIOInitialize+0x210>
     {  /* Enter Idle state */
        Timer1 = 100;  /* Initialization timeout of 1000 msec */
  20a1bc:	00801904 	movi	r2,100
  20a1c0:	d0a0ca8d 	sth	r2,-31958(gp)
        if (SendCMD(CMD8, 0x1AA) == 1)
  20a1c4:	01001204 	movi	r4,72
  20a1c8:	01406a84 	movi	r5,426
  20a1cc:	0209e4c0 	call	209e4c <SendCMD>
  20a1d0:	10803fcc 	andi	r2,r2,255
  20a1d4:	10800058 	cmpnei	r2,r2,1
  20a1d8:	10003e1e 	bne	r2,zero,20a2d4 <ffs_DiskIOInitialize+0x188>
        {  /* SDC ver 2.00 */
           for (n = 0; n < 4; n++)
  20a1dc:	e03ffd05 	stb	zero,-12(fp)
  20a1e0:	00000906 	br	20a208 <ffs_DiskIOInitialize+0xbc>
              ocr[n] = ReceiveU8();
  20a1e4:	e43ffd03 	ldbu	r16,-12(fp)
  20a1e8:	0209c380 	call	209c38 <ReceiveU8>
  20a1ec:	1007883a 	mov	r3,r2
  20a1f0:	e0bffdc4 	addi	r2,fp,-9
  20a1f4:	1405883a 	add	r2,r2,r16
  20a1f8:	10c00005 	stb	r3,0(r2)
     if (SendCMD(CMD0, 0) == 1)
     {  /* Enter Idle state */
        Timer1 = 100;  /* Initialization timeout of 1000 msec */
        if (SendCMD(CMD8, 0x1AA) == 1)
        {  /* SDC ver 2.00 */
           for (n = 0; n < 4; n++)
  20a1fc:	e0bffd03 	ldbu	r2,-12(fp)
  20a200:	10800044 	addi	r2,r2,1
  20a204:	e0bffd05 	stb	r2,-12(fp)
  20a208:	e0bffd03 	ldbu	r2,-12(fp)
  20a20c:	10800130 	cmpltui	r2,r2,4
  20a210:	103ff41e 	bne	r2,zero,20a1e4 <_gp+0xffff45f4>
              ocr[n] = ReceiveU8();
           if (ocr[2] == 0x01 && ocr[3] == 0xAA)
  20a214:	e0bffe43 	ldbu	r2,-7(fp)
  20a218:	10803fcc 	andi	r2,r2,255
  20a21c:	10800058 	cmpnei	r2,r2,1
  20a220:	10004e1e 	bne	r2,zero,20a35c <ffs_DiskIOInitialize+0x210>
  20a224:	e0bffe83 	ldbu	r2,-6(fp)
  20a228:	10803fcc 	andi	r2,r2,255
  20a22c:	10802a98 	cmpnei	r2,r2,170
  20a230:	10004a1e 	bne	r2,zero,20a35c <ffs_DiskIOInitialize+0x210>
           {  /* The card can work at vdd range of 2.7-3.6V */
              while (Timer1 && SendCMD(ACMD41, 1UL << 30)) ;  /* ACMD41 with HCS bit */
  20a234:	0001883a 	nop
  20a238:	d0a0ca8b 	ldhu	r2,-31958(gp)
  20a23c:	10bfffcc 	andi	r2,r2,65535
  20a240:	10000526 	beq	r2,zero,20a258 <ffs_DiskIOInitialize+0x10c>
  20a244:	01003a44 	movi	r4,233
  20a248:	01500034 	movhi	r5,16384
  20a24c:	0209e4c0 	call	209e4c <SendCMD>
  20a250:	10803fcc 	andi	r2,r2,255
  20a254:	103ff81e 	bne	r2,zero,20a238 <_gp+0xffff4648>
              if (Timer1 && SendCMD(CMD58, 0) == 0)
  20a258:	d0a0ca8b 	ldhu	r2,-31958(gp)
  20a25c:	10bfffcc 	andi	r2,r2,65535
  20a260:	10003e26 	beq	r2,zero,20a35c <ffs_DiskIOInitialize+0x210>
  20a264:	01001e84 	movi	r4,122
  20a268:	000b883a 	mov	r5,zero
  20a26c:	0209e4c0 	call	209e4c <SendCMD>
  20a270:	10803fcc 	andi	r2,r2,255
  20a274:	1000391e 	bne	r2,zero,20a35c <ffs_DiskIOInitialize+0x210>
              {  /* Check CCS bit */
                 for (n = 0; n < 4; n++)
  20a278:	e03ffd05 	stb	zero,-12(fp)
  20a27c:	00000906 	br	20a2a4 <ffs_DiskIOInitialize+0x158>
                    ocr[n] = ReceiveU8();
  20a280:	e43ffd03 	ldbu	r16,-12(fp)
  20a284:	0209c380 	call	209c38 <ReceiveU8>
  20a288:	1007883a 	mov	r3,r2
  20a28c:	e0bffdc4 	addi	r2,fp,-9
  20a290:	1405883a 	add	r2,r2,r16
  20a294:	10c00005 	stb	r3,0(r2)
           if (ocr[2] == 0x01 && ocr[3] == 0xAA)
           {  /* The card can work at vdd range of 2.7-3.6V */
              while (Timer1 && SendCMD(ACMD41, 1UL << 30)) ;  /* ACMD41 with HCS bit */
              if (Timer1 && SendCMD(CMD58, 0) == 0)
              {  /* Check CCS bit */
                 for (n = 0; n < 4; n++)
  20a298:	e0bffd03 	ldbu	r2,-12(fp)
  20a29c:	10800044 	addi	r2,r2,1
  20a2a0:	e0bffd05 	stb	r2,-12(fp)
  20a2a4:	e0bffd03 	ldbu	r2,-12(fp)
  20a2a8:	10800130 	cmpltui	r2,r2,4
  20a2ac:	103ff41e 	bne	r2,zero,20a280 <_gp+0xffff4690>
                    ocr[n] = ReceiveU8();
                 ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* Card id SDv2 */
  20a2b0:	e0bffdc3 	ldbu	r2,-9(fp)
  20a2b4:	10803fcc 	andi	r2,r2,255
  20a2b8:	1080100c 	andi	r2,r2,64
  20a2bc:	10000226 	beq	r2,zero,20a2c8 <ffs_DiskIOInitialize+0x17c>
  20a2c0:	00800304 	movi	r2,12
  20a2c4:	00000106 	br	20a2cc <ffs_DiskIOInitialize+0x180>
  20a2c8:	00800104 	movi	r2,4
  20a2cc:	e0bffd45 	stb	r2,-11(fp)
  20a2d0:	00002206 	br	20a35c <ffs_DiskIOInitialize+0x210>
              }
           }
        }
        else
        {  /* SDC ver 1.XX or MMC */
           if (SendCMD(ACMD41, 0) <= 1)
  20a2d4:	01003a44 	movi	r4,233
  20a2d8:	000b883a 	mov	r5,zero
  20a2dc:	0209e4c0 	call	209e4c <SendCMD>
  20a2e0:	10803fcc 	andi	r2,r2,255
  20a2e4:	108000a8 	cmpgeui	r2,r2,2
  20a2e8:	1000051e 	bne	r2,zero,20a300 <ffs_DiskIOInitialize+0x1b4>
           {
              ty  = CT_SD1;
  20a2ec:	00800084 	movi	r2,2
  20a2f0:	e0bffd45 	stb	r2,-11(fp)
              cmd = ACMD41;  /* SDC ver 1.XX */
  20a2f4:	00bffa44 	movi	r2,-23
  20a2f8:	e0bffd85 	stb	r2,-10(fp)
           else
           {
              ty  = CT_MMC;
              cmd = CMD1; /* MMC */
           }
           while (Timer1 && SendCMD(cmd, 0)) ; /* Wait for leaving idle state */
  20a2fc:	00000406 	br	20a310 <ffs_DiskIOInitialize+0x1c4>
              ty  = CT_SD1;
              cmd = ACMD41;  /* SDC ver 1.XX */
           }
           else
           {
              ty  = CT_MMC;
  20a300:	00800044 	movi	r2,1
  20a304:	e0bffd45 	stb	r2,-11(fp)
              cmd = CMD1; /* MMC */
  20a308:	00801044 	movi	r2,65
  20a30c:	e0bffd85 	stb	r2,-10(fp)
           }
           while (Timer1 && SendCMD(cmd, 0)) ; /* Wait for leaving idle state */
  20a310:	0001883a 	nop
  20a314:	d0a0ca8b 	ldhu	r2,-31958(gp)
  20a318:	10bfffcc 	andi	r2,r2,65535
  20a31c:	10000626 	beq	r2,zero,20a338 <ffs_DiskIOInitialize+0x1ec>
  20a320:	e0bffd83 	ldbu	r2,-10(fp)
  20a324:	1009883a 	mov	r4,r2
  20a328:	000b883a 	mov	r5,zero
  20a32c:	0209e4c0 	call	209e4c <SendCMD>
  20a330:	10803fcc 	andi	r2,r2,255
  20a334:	103ff71e 	bne	r2,zero,20a314 <_gp+0xffff4724>
           if (!Timer1 || SendCMD(CMD16, 512) != 0)  /* Select R/W block length */
  20a338:	d0a0ca8b 	ldhu	r2,-31958(gp)
  20a33c:	10bfffcc 	andi	r2,r2,65535
  20a340:	10000526 	beq	r2,zero,20a358 <ffs_DiskIOInitialize+0x20c>
  20a344:	01001404 	movi	r4,80
  20a348:	01408004 	movi	r5,512
  20a34c:	0209e4c0 	call	209e4c <SendCMD>
  20a350:	10803fcc 	andi	r2,r2,255
  20a354:	10000126 	beq	r2,zero,20a35c <ffs_DiskIOInitialize+0x210>
              ty = 0;
  20a358:	e03ffd45 	stb	zero,-11(fp)
        }
     }
     CardType = ty;
  20a35c:	e0bffd43 	ldbu	r2,-11(fp)
  20a360:	d0a0ca05 	stb	r2,-31960(gp)
     ReleaseBus();
  20a364:	0209e080 	call	209e08 <ReleaseBus>

     if (ty)
  20a368:	e0bffd43 	ldbu	r2,-11(fp)
  20a36c:	10000526 	beq	r2,zero,20a384 <ffs_DiskIOInitialize+0x238>
     {  /* Initialization succeded */
        Stat &= ~STA_NOINIT; /* Clear STA_NOINIT */
  20a370:	d0e00003 	ldbu	r3,-32768(gp)
  20a374:	00bfff84 	movi	r2,-2
  20a378:	1884703a 	and	r2,r3,r2
  20a37c:	d0a00005 	stb	r2,-32768(gp)

        SetHighSpeed();
  20a380:	0209b580 	call	209b58 <SetHighSpeed>
     else
     {  /* Initialization failed */
        POWER_OFF();
     }

     return(Stat);
  20a384:	d0a00003 	ldbu	r2,-32768(gp)
} /* ffs_DiskIOInitialize */
  20a388:	e6ffff04 	addi	sp,fp,-4
  20a38c:	dfc00217 	ldw	ra,8(sp)
  20a390:	df000117 	ldw	fp,4(sp)
  20a394:	dc000017 	ldw	r16,0(sp)
  20a398:	dec00304 	addi	sp,sp,12
  20a39c:	f800283a 	ret

0020a3a0 <ffs_DiskIORead>:

DRESULT ffs_DiskIORead(FFS_U8 * buff, FFS_U32 sector, FFS_U16 offset, FFS_U16 count)
{
  20a3a0:	defff704 	addi	sp,sp,-36
  20a3a4:	dfc00815 	stw	ra,32(sp)
  20a3a8:	df000715 	stw	fp,28(sp)
  20a3ac:	dc000615 	stw	r16,24(sp)
  20a3b0:	df000704 	addi	fp,sp,28
  20a3b4:	e13ffb15 	stw	r4,-20(fp)
  20a3b8:	e17ffc15 	stw	r5,-16(fp)
  20a3bc:	3007883a 	mov	r3,r6
  20a3c0:	3805883a 	mov	r2,r7
  20a3c4:	e0fffd0d 	sth	r3,-12(fp)
  20a3c8:	e0bffe0d 	sth	r2,-8(fp)
//	printf("o=%d c=%d\n", offset, count);
   if (!count)
  20a3cc:	e0bffe0b 	ldhu	r2,-8(fp)
  20a3d0:	1000021e 	bne	r2,zero,20a3dc <ffs_DiskIORead+0x3c>
      return RES_PARERR;
  20a3d4:	008000c4 	movi	r2,3
  20a3d8:	00005106 	br	20a520 <ffs_DiskIORead+0x180>
   if (Stat & STA_NOINIT)
  20a3dc:	d0a00003 	ldbu	r2,-32768(gp)
  20a3e0:	10803fcc 	andi	r2,r2,255
  20a3e4:	1080004c 	andi	r2,r2,1
  20a3e8:	10000226 	beq	r2,zero,20a3f4 <ffs_DiskIORead+0x54>
      return RES_NOTRDY;
  20a3ec:	00800084 	movi	r2,2
  20a3f0:	00004b06 	br	20a520 <ffs_DiskIORead+0x180>

   FFS_U8 rc;
   DRESULT res = RES_ERROR;
  20a3f4:	00800044 	movi	r2,1
  20a3f8:	e0bff915 	stw	r2,-28(fp)

   if (!(CardType & CT_BLOCK))
  20a3fc:	d0a0ca03 	ldbu	r2,-31960(gp)
  20a400:	10803fcc 	andi	r2,r2,255
  20a404:	1080020c 	andi	r2,r2,8
  20a408:	1000031e 	bne	r2,zero,20a418 <ffs_DiskIORead+0x78>
      sector *= 512; /* Convert LBA to byte address if needed */
  20a40c:	e0bffc17 	ldw	r2,-16(fp)
  20a410:	1004927a 	slli	r2,r2,9
  20a414:	e0bffc15 	stw	r2,-16(fp)

   if (SendCMD(CMD17, sector) == 0) { /* READ_SINGLE_BLOCK */
  20a418:	01001444 	movi	r4,81
  20a41c:	e17ffc17 	ldw	r5,-16(fp)
  20a420:	0209e4c0 	call	209e4c <SendCMD>
  20a424:	10803fcc 	andi	r2,r2,255
  20a428:	10003b1e 	bne	r2,zero,20a518 <ffs_DiskIORead+0x178>
	   if (offset == 0 && count==512) {
  20a42c:	e0bffd0b 	ldhu	r2,-12(fp)
  20a430:	10000a1e 	bne	r2,zero,20a45c <ffs_DiskIORead+0xbc>
  20a434:	e0bffe0b 	ldhu	r2,-8(fp)
  20a438:	10808018 	cmpnei	r2,r2,512
  20a43c:	1000071e 	bne	r2,zero,20a45c <ffs_DiskIORead+0xbc>
		   // fast path
		   if (ReceiveDatablock(buff, 512))
  20a440:	e13ffb17 	ldw	r4,-20(fp)
  20a444:	01408004 	movi	r5,512
  20a448:	0209c880 	call	209c88 <ReceiveDatablock>
  20a44c:	10000226 	beq	r2,zero,20a458 <ffs_DiskIORead+0xb8>
			   res = RES_OK;
  20a450:	e03ff915 	stw	zero,-28(fp)
      sector *= 512; /* Convert LBA to byte address if needed */

   if (SendCMD(CMD17, sector) == 0) { /* READ_SINGLE_BLOCK */
	   if (offset == 0 && count==512) {
		   // fast path
		   if (ReceiveDatablock(buff, 512))
  20a454:	00003006 	br	20a518 <ffs_DiskIORead+0x178>
  20a458:	00002f06 	br	20a518 <ffs_DiskIORead+0x178>
			   res = RES_OK;
	   }
	   else
	   {	// original path
		   FFS_U16 bc = 40000;
  20a45c:	00a71004 	movi	r2,-25536
  20a460:	e0bffa0d 	sth	r2,-24(fp)
		   do { /* Wait for data packet */
			   rc = ReceiveU8();
  20a464:	0209c380 	call	209c38 <ReceiveU8>
  20a468:	e0bffa85 	stb	r2,-22(fp)
		   } while (rc == 0xFF && --bc);
  20a46c:	e0bffa83 	ldbu	r2,-22(fp)
  20a470:	10803fd8 	cmpnei	r2,r2,255
  20a474:	1000051e 	bne	r2,zero,20a48c <ffs_DiskIORead+0xec>
  20a478:	e0bffa0b 	ldhu	r2,-24(fp)
  20a47c:	10bfffc4 	addi	r2,r2,-1
  20a480:	e0bffa0d 	sth	r2,-24(fp)
  20a484:	e0bffa0b 	ldhu	r2,-24(fp)
  20a488:	103ff61e 	bne	r2,zero,20a464 <_gp+0xffff4874>

		   if (rc == 0xFE) { /* A data packet arrived */
  20a48c:	e0bffa83 	ldbu	r2,-22(fp)
  20a490:	10803f98 	cmpnei	r2,r2,254
  20a494:	10001f1e 	bne	r2,zero,20a514 <ffs_DiskIORead+0x174>
			   bc = 514 - offset - count;
  20a498:	e0bffd0b 	ldhu	r2,-12(fp)
  20a49c:	0085c83a 	sub	r2,zero,r2
  20a4a0:	1007883a 	mov	r3,r2
  20a4a4:	e0bffe0b 	ldhu	r2,-8(fp)
  20a4a8:	1885c83a 	sub	r2,r3,r2
  20a4ac:	10808084 	addi	r2,r2,514
  20a4b0:	e0bffa0d 	sth	r2,-24(fp)

			   /* Skip leading bytes */
			   if (offset) {
  20a4b4:	e0bffd0b 	ldhu	r2,-12(fp)
  20a4b8:	10000626 	beq	r2,zero,20a4d4 <ffs_DiskIORead+0x134>
				   do
					   ReceiveU8();
  20a4bc:	0209c380 	call	209c38 <ReceiveU8>
				   while (--offset);
  20a4c0:	e0bffd0b 	ldhu	r2,-12(fp)
  20a4c4:	10bfffc4 	addi	r2,r2,-1
  20a4c8:	e0bffd0d 	sth	r2,-12(fp)
  20a4cc:	e0bffd0b 	ldhu	r2,-12(fp)
  20a4d0:	103ffa1e 	bne	r2,zero,20a4bc <_gp+0xffff48cc>
			   }

			   /* Receive a part of the sector */
			   do {
				   *buff++ = ReceiveU8();
  20a4d4:	e43ffb17 	ldw	r16,-20(fp)
  20a4d8:	80800044 	addi	r2,r16,1
  20a4dc:	e0bffb15 	stw	r2,-20(fp)
  20a4e0:	0209c380 	call	209c38 <ReceiveU8>
  20a4e4:	80800005 	stb	r2,0(r16)
			   } while (--count);
  20a4e8:	e0bffe0b 	ldhu	r2,-8(fp)
  20a4ec:	10bfffc4 	addi	r2,r2,-1
  20a4f0:	e0bffe0d 	sth	r2,-8(fp)
  20a4f4:	e0bffe0b 	ldhu	r2,-8(fp)
  20a4f8:	103ff61e 	bne	r2,zero,20a4d4 <_gp+0xffff48e4>

			   /* Skip trailing bytes and CRC */
			   do
				   ReceiveU8();
  20a4fc:	0209c380 	call	209c38 <ReceiveU8>
			   while (--bc);
  20a500:	e0bffa0b 	ldhu	r2,-24(fp)
  20a504:	10bfffc4 	addi	r2,r2,-1
  20a508:	e0bffa0d 	sth	r2,-24(fp)
  20a50c:	e0bffa0b 	ldhu	r2,-24(fp)
  20a510:	103ffa1e 	bne	r2,zero,20a4fc <_gp+0xffff490c>
		   }
           res = RES_OK;
  20a514:	e03ff915 	stw	zero,-28(fp)
       }
   }

   ReleaseBus();
  20a518:	0209e080 	call	209e08 <ReleaseBus>

   return res;
  20a51c:	e0bff917 	ldw	r2,-28(fp)
} /* ffs_DiskIORead */
  20a520:	e6ffff04 	addi	sp,fp,-4
  20a524:	dfc00217 	ldw	ra,8(sp)
  20a528:	df000117 	ldw	fp,4(sp)
  20a52c:	dc000017 	ldw	r16,0(sp)
  20a530:	dec00304 	addi	sp,sp,12
  20a534:	f800283a 	ret

0020a538 <TimerFunction>:
#define ATARI_CMD_NEXT_PAGE	128
#define ATARI_CMD_UP_DIR	129
#define ATARI_CMD_RESET		130

static alt_u32 TimerFunction (void *context)
{
  20a538:	defffd04 	addi	sp,sp,-12
  20a53c:	dfc00215 	stw	ra,8(sp)
  20a540:	df000115 	stw	fp,4(sp)
  20a544:	df000104 	addi	fp,sp,4
  20a548:	e13fff15 	stw	r4,-4(fp)
	(void) context;
	Systick++;
  20a54c:	d0a0cd17 	ldw	r2,-31948(gp)
  20a550:	10800044 	addi	r2,r2,1
  20a554:	d0a0cd15 	stw	r2,-31948(gp)

	if (Systick % 10 == 0)
  20a558:	d0a0cd17 	ldw	r2,-31948(gp)
  20a55c:	1009883a 	mov	r4,r2
  20a560:	01400284 	movi	r5,10
  20a564:	020b5040 	call	20b504 <__umodsi3>
  20a568:	1000011e 	bne	r2,zero,20a570 <TimerFunction+0x38>
		ffs_DiskIOTimerproc();  /* Drive timer procedure of low level disk I/O module */
  20a56c:	020a09c0 	call	20a09c <ffs_DiskIOTimerproc>

	if (Systick % 200 < 10)
  20a570:	d0a0cd17 	ldw	r2,-31948(gp)
  20a574:	1009883a 	mov	r4,r2
  20a578:	01403204 	movi	r5,200
  20a57c:	020b5040 	call	20b504 <__umodsi3>
  20a580:	108002a8 	cmpgeui	r2,r2,10
  20a584:	1000051e 	bne	r2,zero,20a59c <TimerFunction+0x64>
		IOWR(LED_BASE, 0, ledVal);
  20a588:	d0e00117 	ldw	r3,-32764(gp)
  20a58c:	00800874 	movhi	r2,33
  20a590:	10941c04 	addi	r2,r2,20592
  20a594:	10c00035 	stwio	r3,0(r2)
  20a598:	00000506 	br	20a5b0 <TimerFunction+0x78>
	else
		IOWR(LED_BASE, 0, ledVal | 1);
  20a59c:	d0a00117 	ldw	r2,-32764(gp)
  20a5a0:	10c00054 	ori	r3,r2,1
  20a5a4:	00800874 	movhi	r2,33
  20a5a8:	10941c04 	addi	r2,r2,20592
  20a5ac:	10c00035 	stwio	r3,0(r2)

	return (1);
  20a5b0:	00800044 	movi	r2,1
}
  20a5b4:	e037883a 	mov	sp,fp
  20a5b8:	dfc00117 	ldw	ra,4(sp)
  20a5bc:	df000017 	ldw	fp,0(sp)
  20a5c0:	dec00204 	addi	sp,sp,8
  20a5c4:	f800283a 	ret

0020a5c8 <get_filename_ext>:

char *get_filename_ext(char *filename) {
  20a5c8:	defffc04 	addi	sp,sp,-16
  20a5cc:	dfc00315 	stw	ra,12(sp)
  20a5d0:	df000215 	stw	fp,8(sp)
  20a5d4:	df000204 	addi	fp,sp,8
  20a5d8:	e13fff15 	stw	r4,-4(fp)
    char *dot = strrchr(filename, '.');
  20a5dc:	e13fff17 	ldw	r4,-4(fp)
  20a5e0:	01400b84 	movi	r5,46
  20a5e4:	020bc400 	call	20bc40 <strrchr>
  20a5e8:	e0bffe15 	stw	r2,-8(fp)
    if(!dot || dot == filename) return "";
  20a5ec:	e0bffe17 	ldw	r2,-8(fp)
  20a5f0:	10000326 	beq	r2,zero,20a600 <get_filename_ext+0x38>
  20a5f4:	e0fffe17 	ldw	r3,-8(fp)
  20a5f8:	e0bfff17 	ldw	r2,-4(fp)
  20a5fc:	1880031e 	bne	r3,r2,20a60c <get_filename_ext+0x44>
  20a600:	00800874 	movhi	r2,33
  20a604:	10b57d04 	addi	r2,r2,-10764
  20a608:	00000206 	br	20a614 <get_filename_ext+0x4c>
    return dot + 1;
  20a60c:	e0bffe17 	ldw	r2,-8(fp)
  20a610:	10800044 	addi	r2,r2,1
}
  20a614:	e037883a 	mov	sp,fp
  20a618:	dfc00117 	ldw	ra,4(sp)
  20a61c:	df000017 	ldw	fp,0(sp)
  20a620:	dec00204 	addi	sp,sp,8
  20a624:	f800283a 	ret

0020a628 <entry_compare>:

int num_dir_entries = 0;	// how many entries in the current directory
int dir_offset = 0;			// start index of the chunk of files being displayed by atari

int entry_compare(const void* p1, const void* p2)
{
  20a628:	defffa04 	addi	sp,sp,-24
  20a62c:	dfc00515 	stw	ra,20(sp)
  20a630:	df000415 	stw	fp,16(sp)
  20a634:	df000404 	addi	fp,sp,16
  20a638:	e13ffe15 	stw	r4,-8(fp)
  20a63c:	e17fff15 	stw	r5,-4(fp)
	DIR_ENTRY* e1 = (DIR_ENTRY*)p1;
  20a640:	e0bffe17 	ldw	r2,-8(fp)
  20a644:	e0bffc15 	stw	r2,-16(fp)
	DIR_ENTRY* e2 = (DIR_ENTRY*)p2;
  20a648:	e0bfff17 	ldw	r2,-4(fp)
  20a64c:	e0bffd15 	stw	r2,-12(fp)
	if (e1->isDir && !e2->isDir) return -1;
  20a650:	e0bffc17 	ldw	r2,-16(fp)
  20a654:	10800003 	ldbu	r2,0(r2)
  20a658:	10803fcc 	andi	r2,r2,255
  20a65c:	1080201c 	xori	r2,r2,128
  20a660:	10bfe004 	addi	r2,r2,-128
  20a664:	10000826 	beq	r2,zero,20a688 <entry_compare+0x60>
  20a668:	e0bffd17 	ldw	r2,-12(fp)
  20a66c:	10800003 	ldbu	r2,0(r2)
  20a670:	10803fcc 	andi	r2,r2,255
  20a674:	1080201c 	xori	r2,r2,128
  20a678:	10bfe004 	addi	r2,r2,-128
  20a67c:	1000021e 	bne	r2,zero,20a688 <entry_compare+0x60>
  20a680:	00bfffc4 	movi	r2,-1
  20a684:	00001506 	br	20a6dc <entry_compare+0xb4>
	else if (!e1->isDir && e2->isDir) return 1;
  20a688:	e0bffc17 	ldw	r2,-16(fp)
  20a68c:	10800003 	ldbu	r2,0(r2)
  20a690:	10803fcc 	andi	r2,r2,255
  20a694:	1080201c 	xori	r2,r2,128
  20a698:	10bfe004 	addi	r2,r2,-128
  20a69c:	1000081e 	bne	r2,zero,20a6c0 <entry_compare+0x98>
  20a6a0:	e0bffd17 	ldw	r2,-12(fp)
  20a6a4:	10800003 	ldbu	r2,0(r2)
  20a6a8:	10803fcc 	andi	r2,r2,255
  20a6ac:	1080201c 	xori	r2,r2,128
  20a6b0:	10bfe004 	addi	r2,r2,-128
  20a6b4:	10000226 	beq	r2,zero,20a6c0 <entry_compare+0x98>
  20a6b8:	00800044 	movi	r2,1
  20a6bc:	00000706 	br	20a6dc <entry_compare+0xb4>
	else return stricmp(e1->long_filename, e2->long_filename);
  20a6c0:	e0bffc17 	ldw	r2,-16(fp)
  20a6c4:	10c00384 	addi	r3,r2,14
  20a6c8:	e0bffd17 	ldw	r2,-12(fp)
  20a6cc:	10800384 	addi	r2,r2,14
  20a6d0:	1809883a 	mov	r4,r3
  20a6d4:	100b883a 	mov	r5,r2
  20a6d8:	020bab40 	call	20bab4 <strcasecmp>
}
  20a6dc:	e037883a 	mov	sp,fp
  20a6e0:	dfc00117 	ldw	ra,4(sp)
  20a6e4:	df000017 	ldw	fp,0(sp)
  20a6e8:	dec00204 	addi	sp,sp,8
  20a6ec:	f800283a 	ret

0020a6f0 <read_directory>:

FRESULT read_directory(char* path)
{
  20a6f0:	deffa204 	addi	sp,sp,-376
  20a6f4:	dfc05d15 	stw	ra,372(sp)
  20a6f8:	df005c15 	stw	fp,368(sp)
  20a6fc:	df005c04 	addi	fp,sp,368
  20a700:	e13fff15 	stw	r4,-4(fp)
    FRESULT res;
    FILINFO fno;
    DIR dir;
    DIR_ENTRY entry;

    num_dir_entries = 0;
  20a704:	d020ce15 	stw	zero,-31944(gp)
    dir_offset = 0;
  20a708:	d020cf15 	stw	zero,-31940(gp)
    DIR_ENTRY *dst = (DIR_ENTRY *)EXT_SRAM_CONTROLLER_0_BASE;
  20a70c:	00800434 	movhi	r2,16
  20a710:	e0bfa615 	stw	r2,-360(fp)

	//printf("PATH = %s\n", path);

    res = pf_opendir(&dir, path);
  20a714:	e0bfee04 	addi	r2,fp,-72
  20a718:	1009883a 	mov	r4,r2
  20a71c:	e17fff17 	ldw	r5,-4(fp)
  20a720:	02099340 	call	209934 <pf_opendir>
  20a724:	e0bfa415 	stw	r2,-368(fp)
    if (res == FR_OK)
  20a728:	e0bfa417 	ldw	r2,-368(fp)
  20a72c:	1000571e 	bne	r2,zero,20a88c <read_directory+0x19c>
    {
        while (1) {
        	res = pf_readdir(&dir, &fno);
  20a730:	e0ffee04 	addi	r3,fp,-72
  20a734:	e0bfa804 	addi	r2,fp,-352
  20a738:	1809883a 	mov	r4,r3
  20a73c:	100b883a 	mov	r5,r2
  20a740:	0209a000 	call	209a00 <pf_readdir>
  20a744:	e0bfa415 	stw	r2,-368(fp)
            if (res != FR_OK || fno.fname[0] == 0)
  20a748:	e0bfa417 	ldw	r2,-368(fp)
  20a74c:	1000481e 	bne	r2,zero,20a870 <read_directory+0x180>
  20a750:	e0bfaa43 	ldbu	r2,-343(fp)
  20a754:	10803fcc 	andi	r2,r2,255
  20a758:	1080201c 	xori	r2,r2,128
  20a75c:	10bfe004 	addi	r2,r2,-128
  20a760:	10004326 	beq	r2,zero,20a870 <read_directory+0x180>
            	break;
            if (fno.fattrib & (AM_HID | AM_SYS))
  20a764:	e0bfaa03 	ldbu	r2,-344(fp)
  20a768:	10803fcc 	andi	r2,r2,255
  20a76c:	1080018c 	andi	r2,r2,6
  20a770:	10000126 	beq	r2,zero,20a778 <read_directory+0x88>
            	continue;
  20a774:	00003d06 	br	20a86c <read_directory+0x17c>
            int entry_type = 0;
  20a778:	e03fa515 	stw	zero,-364(fp)
            if (fno.fattrib & AM_DIR)
  20a77c:	e0bfaa03 	ldbu	r2,-344(fp)
  20a780:	10803fcc 	andi	r2,r2,255
  20a784:	1080040c 	andi	r2,r2,16
  20a788:	10000326 	beq	r2,zero,20a798 <read_directory+0xa8>
            { // a directory
            	entry_type = 2;
  20a78c:	00800084 	movi	r2,2
  20a790:	e0bfa515 	stw	r2,-364(fp)
  20a794:	00001206 	br	20a7e0 <read_directory+0xf0>
            }
            else
            {	// a file - check its a ROM or CAR file
                char *ext = get_filename_ext(fno.fname);
  20a798:	e0bfa804 	addi	r2,fp,-352
  20a79c:	10800244 	addi	r2,r2,9
  20a7a0:	1009883a 	mov	r4,r2
  20a7a4:	020a5c80 	call	20a5c8 <get_filename_ext>
  20a7a8:	e0bfa715 	stw	r2,-356(fp)
                if (strcmp(ext, "CAR") != 0 && strcmp(ext, "ROM") != 0) continue;
  20a7ac:	e13fa717 	ldw	r4,-356(fp)
  20a7b0:	01400874 	movhi	r5,33
  20a7b4:	29757e04 	addi	r5,r5,-10760
  20a7b8:	020bb3c0 	call	20bb3c <strcmp>
  20a7bc:	10000626 	beq	r2,zero,20a7d8 <read_directory+0xe8>
  20a7c0:	e13fa717 	ldw	r4,-356(fp)
  20a7c4:	01400874 	movhi	r5,33
  20a7c8:	29757f04 	addi	r5,r5,-10756
  20a7cc:	020bb3c0 	call	20bb3c <strcmp>
  20a7d0:	10000126 	beq	r2,zero,20a7d8 <read_directory+0xe8>
  20a7d4:	00002506 	br	20a86c <read_directory+0x17c>
                entry_type = 1;
  20a7d8:	00800044 	movi	r2,1
  20a7dc:	e0bfa515 	stw	r2,-364(fp)
            }
            // valid entry
            //printf("%s, %s\n", fno.fname, fno.lfname);
            // create a record
            entry.isDir = (entry_type == 2 ? 1 : 0);
  20a7e0:	e0bfa517 	ldw	r2,-364(fp)
  20a7e4:	108000a0 	cmpeqi	r2,r2,2
  20a7e8:	e0bff305 	stb	r2,-52(fp)
            strcpy(entry.filename, fno.fname);
  20a7ec:	e0bff304 	addi	r2,fp,-52
  20a7f0:	10c00044 	addi	r3,r2,1
  20a7f4:	e0bfa804 	addi	r2,fp,-352
  20a7f8:	10800244 	addi	r2,r2,9
  20a7fc:	1809883a 	mov	r4,r3
  20a800:	100b883a 	mov	r5,r2
  20a804:	020bb740 	call	20bb74 <strcpy>
            strncpy(entry.long_filename, fno.lfname, 31);
  20a808:	e0bff304 	addi	r2,fp,-52
  20a80c:	10c00384 	addi	r3,r2,14
  20a810:	e0bfa804 	addi	r2,fp,-352
  20a814:	10800584 	addi	r2,r2,22
  20a818:	1809883a 	mov	r4,r3
  20a81c:	100b883a 	mov	r5,r2
  20a820:	018007c4 	movi	r6,31
  20a824:	020bbf40 	call	20bbf4 <strncpy>
            entry.long_filename[31] = 0;
  20a828:	e03ffe45 	stb	zero,-7(fp)
            // copy to SRAM
            memcpy(&dst[num_dir_entries], &entry, sizeof(DIR_ENTRY));
  20a82c:	d0a0ce17 	ldw	r2,-31944(gp)
  20a830:	1009883a 	mov	r4,r2
  20a834:	01400b84 	movi	r5,46
  20a838:	020b50c0 	call	20b50c <__mulsi3>
  20a83c:	e0ffa617 	ldw	r3,-360(fp)
  20a840:	1885883a 	add	r2,r3,r2
  20a844:	1009883a 	mov	r4,r2
  20a848:	e0fff304 	addi	r3,fp,-52
  20a84c:	00800b84 	movi	r2,46
  20a850:	180b883a 	mov	r5,r3
  20a854:	100d883a 	mov	r6,r2
  20a858:	020b5340 	call	20b534 <memcpy>
            num_dir_entries++;
  20a85c:	d0a0ce17 	ldw	r2,-31944(gp)
  20a860:	10800044 	addi	r2,r2,1
  20a864:	d0a0ce15 	stw	r2,-31944(gp)
        }
  20a868:	003fb106 	br	20a730 <_gp+0xffff4b40>
  20a86c:	003fb006 	br	20a730 <_gp+0xffff4b40>
        qsort(dst, num_dir_entries, sizeof(DIR_ENTRY), entry_compare);
  20a870:	d0a0ce17 	ldw	r2,-31944(gp)
  20a874:	e13fa617 	ldw	r4,-360(fp)
  20a878:	100b883a 	mov	r5,r2
  20a87c:	01800b84 	movi	r6,46
  20a880:	01c00874 	movhi	r7,33
  20a884:	39e98a04 	addi	r7,r7,-23000
  20a888:	020b67c0 	call	20b67c <qsort>
    }
    return res;
  20a88c:	e0bfa417 	ldw	r2,-368(fp)
}
  20a890:	e037883a 	mov	sp,fp
  20a894:	dfc00117 	ldw	ra,4(sp)
  20a898:	df000017 	ldw	fp,0(sp)
  20a89c:	dec00204 	addi	sp,sp,8
  20a8a0:	f800283a 	ret

0020a8a4 <populate_cart_file_list>:

void populate_cart_file_list()
{
  20a8a4:	defff904 	addi	sp,sp,-28
  20a8a8:	dfc00615 	stw	ra,24(sp)
  20a8ac:	df000515 	stw	fp,20(sp)
  20a8b0:	df000504 	addi	fp,sp,20
	int i;
    DIR_ENTRY *dir_entries = (DIR_ENTRY *)EXT_SRAM_CONTROLLER_0_BASE;
  20a8b4:	00800434 	movhi	r2,16
  20a8b8:	e0bffd15 	stw	r2,-12(fp)
    unsigned char *cart_dir_mem_base = (unsigned char *)(CART_MEMORY_BASE + CART_DIR_ENTRIES);
  20a8bc:	00800874 	movhi	r2,33
  20a8c0:	108c0004 	addi	r2,r2,12288
  20a8c4:	e0bffe15 	stw	r2,-8(fp)

	for (i = 0; i < DIR_ENTRIES_PER_PAGE; i++)
  20a8c8:	e03ffb15 	stw	zero,-20(fp)
  20a8cc:	00002d06 	br	20a984 <populate_cart_file_list+0xe0>
	{
		int entry_type = 0;
  20a8d0:	e03ffc15 	stw	zero,-16(fp)
		if (dir_offset + i < num_dir_entries)
  20a8d4:	d0e0cf17 	ldw	r3,-31940(gp)
  20a8d8:	e0bffb17 	ldw	r2,-20(fp)
  20a8dc:	1887883a 	add	r3,r3,r2
  20a8e0:	d0a0ce17 	ldw	r2,-31944(gp)
  20a8e4:	18801e0e 	bge	r3,r2,20a960 <populate_cart_file_list+0xbc>
		{
			DIR_ENTRY *entry = &dir_entries[dir_offset + i];
  20a8e8:	d0e0cf17 	ldw	r3,-31940(gp)
  20a8ec:	e0bffb17 	ldw	r2,-20(fp)
  20a8f0:	1885883a 	add	r2,r3,r2
  20a8f4:	1009883a 	mov	r4,r2
  20a8f8:	01400b84 	movi	r5,46
  20a8fc:	020b50c0 	call	20b50c <__mulsi3>
  20a900:	e0fffd17 	ldw	r3,-12(fp)
  20a904:	1885883a 	add	r2,r3,r2
  20a908:	e0bfff15 	stw	r2,-4(fp)
			entry_type = entry->isDir ? 2 : 1;
  20a90c:	e0bfff17 	ldw	r2,-4(fp)
  20a910:	10800003 	ldbu	r2,0(r2)
  20a914:	10803fcc 	andi	r2,r2,255
  20a918:	1080201c 	xori	r2,r2,128
  20a91c:	10bfe004 	addi	r2,r2,-128
  20a920:	10000226 	beq	r2,zero,20a92c <populate_cart_file_list+0x88>
  20a924:	00800084 	movi	r2,2
  20a928:	00000106 	br	20a930 <populate_cart_file_list+0x8c>
  20a92c:	00800044 	movi	r2,1
  20a930:	e0bffc15 	stw	r2,-16(fp)
			strncpy(cart_dir_mem_base+(i*32)+1, entry->long_filename, 31);
  20a934:	e0bffb17 	ldw	r2,-20(fp)
  20a938:	1004917a 	slli	r2,r2,5
  20a93c:	10800044 	addi	r2,r2,1
  20a940:	e0fffe17 	ldw	r3,-8(fp)
  20a944:	1887883a 	add	r3,r3,r2
  20a948:	e0bfff17 	ldw	r2,-4(fp)
  20a94c:	10800384 	addi	r2,r2,14
  20a950:	1809883a 	mov	r4,r3
  20a954:	100b883a 	mov	r5,r2
  20a958:	018007c4 	movi	r6,31
  20a95c:	020bbf40 	call	20bbf4 <strncpy>
		}
		*(cart_dir_mem_base+(i*32)) = entry_type;
  20a960:	e0bffb17 	ldw	r2,-20(fp)
  20a964:	1004917a 	slli	r2,r2,5
  20a968:	e0fffe17 	ldw	r3,-8(fp)
  20a96c:	1885883a 	add	r2,r3,r2
  20a970:	e0fffc17 	ldw	r3,-16(fp)
  20a974:	10c00005 	stb	r3,0(r2)
{
	int i;
    DIR_ENTRY *dir_entries = (DIR_ENTRY *)EXT_SRAM_CONTROLLER_0_BASE;
    unsigned char *cart_dir_mem_base = (unsigned char *)(CART_MEMORY_BASE + CART_DIR_ENTRIES);

	for (i = 0; i < DIR_ENTRIES_PER_PAGE; i++)
  20a978:	e0bffb17 	ldw	r2,-20(fp)
  20a97c:	10800044 	addi	r2,r2,1
  20a980:	e0bffb15 	stw	r2,-20(fp)
  20a984:	e0bffb17 	ldw	r2,-20(fp)
  20a988:	10800510 	cmplti	r2,r2,20
  20a98c:	103fd01e 	bne	r2,zero,20a8d0 <_gp+0xffff4ce0>
			entry_type = entry->isDir ? 2 : 1;
			strncpy(cart_dir_mem_base+(i*32)+1, entry->long_filename, 31);
		}
		*(cart_dir_mem_base+(i*32)) = entry_type;
	}
}
  20a990:	e037883a 	mov	sp,fp
  20a994:	dfc00117 	ldw	ra,4(sp)
  20a998:	df000017 	ldw	fp,0(sp)
  20a99c:	dec00204 	addi	sp,sp,8
  20a9a0:	f800283a 	ret

0020a9a4 <set_cart_cmd_byte>:

void set_cart_cmd_byte(unsigned char byte) {
  20a9a4:	defffe04 	addi	sp,sp,-8
  20a9a8:	df000115 	stw	fp,4(sp)
  20a9ac:	df000104 	addi	fp,sp,4
  20a9b0:	2005883a 	mov	r2,r4
  20a9b4:	e0bfff05 	stb	r2,-4(fp)
	*(unsigned char *)(CART_MEMORY_BASE + CART_CMD_BYTE) = byte;
  20a9b8:	00800874 	movhi	r2,33
  20a9bc:	108bfc04 	addi	r2,r2,12272
  20a9c0:	e0ffff03 	ldbu	r3,-4(fp)
  20a9c4:	10c00005 	stb	r3,0(r2)
}
  20a9c8:	e037883a 	mov	sp,fp
  20a9cc:	df000017 	ldw	fp,0(sp)
  20a9d0:	dec00104 	addi	sp,sp,4
  20a9d4:	f800283a 	ret

0020a9d8 <set_cart_list_flag_byte>:

void set_cart_list_flag_byte(unsigned char byte) {
  20a9d8:	defffe04 	addi	sp,sp,-8
  20a9dc:	df000115 	stw	fp,4(sp)
  20a9e0:	df000104 	addi	fp,sp,4
  20a9e4:	2005883a 	mov	r2,r4
  20a9e8:	e0bfff05 	stb	r2,-4(fp)
	*(unsigned char *)(CART_MEMORY_BASE + CART_LIST_FLAG_BYTE) = byte;
  20a9ec:	00800874 	movhi	r2,33
  20a9f0:	108bfc44 	addi	r2,r2,12273
  20a9f4:	e0ffff03 	ldbu	r3,-4(fp)
  20a9f8:	10c00005 	stb	r3,0(r2)
}
  20a9fc:	e037883a 	mov	sp,fp
  20aa00:	df000017 	ldw	fp,0(sp)
  20aa04:	dec00104 	addi	sp,sp,4
  20aa08:	f800283a 	ret

0020aa0c <set_cart_error>:

void set_cart_error(char *errorStr) {
  20aa0c:	defffd04 	addi	sp,sp,-12
  20aa10:	dfc00215 	stw	ra,8(sp)
  20aa14:	df000115 	stw	fp,4(sp)
  20aa18:	df000104 	addi	fp,sp,4
  20aa1c:	e13fff15 	stw	r4,-4(fp)
	strncpy(CART_MEMORY_BASE + CART_ERROR_BUFFER, errorStr, 32);
  20aa20:	01000874 	movhi	r4,33
  20aa24:	210cc004 	addi	r4,r4,13056
  20aa28:	e17fff17 	ldw	r5,-4(fp)
  20aa2c:	01800804 	movi	r6,32
  20aa30:	020bbf40 	call	20bbf4 <strncpy>
	set_cart_cmd_byte(CART_CMD_ERROR);
  20aa34:	01000084 	movi	r4,2
  20aa38:	020a9a40 	call	20a9a4 <set_cart_cmd_byte>
}
  20aa3c:	e037883a 	mov	sp,fp
  20aa40:	dfc00117 	ldw	ra,4(sp)
  20aa44:	df000017 	ldw	fp,0(sp)
  20aa48:	dec00204 	addi	sp,sp,8
  20aa4c:	f800283a 	ret

0020aa50 <recieve_atari_byte>:

unsigned char recieve_atari_byte()
{
  20aa50:	defffe04 	addi	sp,sp,-8
  20aa54:	df000115 	stw	fp,4(sp)
  20aa58:	df000104 	addi	fp,sp,4
	unsigned char atari_ret = 0;
  20aa5c:	e03fff05 	stb	zero,-4(fp)
	while (!atari_ret)
  20aa60:	00000406 	br	20aa74 <recieve_atari_byte+0x24>
		atari_ret = IORD(ATARI_D500_BYTE_BASE, 0);
  20aa64:	00800874 	movhi	r2,33
  20aa68:	10941404 	addi	r2,r2,20560
  20aa6c:	10800037 	ldwio	r2,0(r2)
  20aa70:	e0bfff05 	stb	r2,-4(fp)
}

unsigned char recieve_atari_byte()
{
	unsigned char atari_ret = 0;
	while (!atari_ret)
  20aa74:	e0bfff03 	ldbu	r2,-4(fp)
  20aa78:	103ffa26 	beq	r2,zero,20aa64 <_gp+0xffff4e74>
		atari_ret = IORD(ATARI_D500_BYTE_BASE, 0);
	IOWR(RESET_D500_BASE, 0, 1);
  20aa7c:	00c00044 	movi	r3,1
  20aa80:	00800874 	movhi	r2,33
  20aa84:	10941004 	addi	r2,r2,20544
  20aa88:	10c00035 	stwio	r3,0(r2)
	IOWR(RESET_D500_BASE, 0, 0);
  20aa8c:	0007883a 	mov	r3,zero
  20aa90:	00800874 	movhi	r2,33
  20aa94:	10941004 	addi	r2,r2,20544
  20aa98:	10c00035 	stwio	r3,0(r2)
	return atari_ret;
  20aa9c:	e0bfff03 	ldbu	r2,-4(fp)
}
  20aaa0:	e037883a 	mov	sp,fp
  20aaa4:	df000017 	ldw	fp,0(sp)
  20aaa8:	dec00104 	addi	sp,sp,4
  20aaac:	f800283a 	ret

0020aab0 <atari_reboot_with_cart>:

void atari_reboot_with_cart(int cart_type)
{
  20aab0:	defffc04 	addi	sp,sp,-16
  20aab4:	dfc00315 	stw	ra,12(sp)
  20aab8:	df000215 	stw	fp,8(sp)
  20aabc:	df000204 	addi	fp,sp,8
  20aac0:	e13fff15 	stw	r4,-4(fp)
	set_cart_cmd_byte(CART_CMD_REBOOT);
  20aac4:	01003fc4 	movi	r4,255
  20aac8:	020a9a40 	call	20a9a4 <set_cart_cmd_byte>
	recieve_atari_byte();
  20aacc:	020aa500 	call	20aa50 <recieve_atari_byte>
	set_cart_cmd_byte(CART_CMD_IDLE);
  20aad0:	0009883a 	mov	r4,zero
  20aad4:	020a9a40 	call	20a9a4 <set_cart_cmd_byte>
	// wait 10ms to ensure the atari is running from ram before we switch the ROM
	int start = Systick; while (Systick < start + 10) {}
  20aad8:	d0a0cd17 	ldw	r2,-31948(gp)
  20aadc:	e0bffe15 	stw	r2,-8(fp)
  20aae0:	0001883a 	nop
  20aae4:	e0bffe17 	ldw	r2,-8(fp)
  20aae8:	10800284 	addi	r2,r2,10
  20aaec:	d0e0cd17 	ldw	r3,-31948(gp)
  20aaf0:	18bffc36 	bltu	r3,r2,20aae4 <_gp+0xffff4ef4>
	// swap the cart bus to SRAM
	IOWR(SEL_CARTRIDGE_TYPE_BASE, 0, cart_type);
  20aaf4:	00800874 	movhi	r2,33
  20aaf8:	10941804 	addi	r2,r2,20576
  20aafc:	e0ffff17 	ldw	r3,-4(fp)
  20ab00:	10c00035 	stwio	r3,0(r2)
}
  20ab04:	e037883a 	mov	sp,fp
  20ab08:	dfc00117 	ldw	ra,4(sp)
  20ab0c:	df000017 	ldw	fp,0(sp)
  20ab10:	dec00204 	addi	sp,sp,8
  20ab14:	f800283a 	ret

0020ab18 <load_cart>:

int load_cart(char *filename)
{
  20ab18:	deff7204 	addi	sp,sp,-568
  20ab1c:	dfc08d15 	stw	ra,564(sp)
  20ab20:	df008c15 	stw	fp,560(sp)
  20ab24:	df008c04 	addi	fp,sp,560
  20ab28:	e13fff15 	stw	r4,-4(fp)
	int i,cart_type = -1;	// default to file error
  20ab2c:	00bfffc4 	movi	r2,-1
  20ab30:	e0bf7515 	stw	r2,-556(fp)
	int car_file = 0;
  20ab34:	e03f7615 	stw	zero,-552(fp)
	if (strncmp(filename+strlen(filename)-4, ".CAR", 4) == 0)
  20ab38:	e13fff17 	ldw	r4,-4(fp)
  20ab3c:	020bb940 	call	20bb94 <strlen>
  20ab40:	10bfff04 	addi	r2,r2,-4
  20ab44:	e0ffff17 	ldw	r3,-4(fp)
  20ab48:	1885883a 	add	r2,r3,r2
  20ab4c:	1009883a 	mov	r4,r2
  20ab50:	01400874 	movhi	r5,33
  20ab54:	29758004 	addi	r5,r5,-10752
  20ab58:	01800104 	movi	r6,4
  20ab5c:	020bbb00 	call	20bbb0 <strncmp>
  20ab60:	1000021e 	bne	r2,zero,20ab6c <load_cart+0x54>
		car_file = 1;
  20ab64:	00800044 	movi	r2,1
  20ab68:	e0bf7615 	stw	r2,-552(fp)

	//printf("loading %s\n", filename);
	if (pf_open(filename) == FR_OK) {
  20ab6c:	e13fff17 	ldw	r4,-4(fp)
  20ab70:	02095cc0 	call	2095cc <pf_open>
  20ab74:	1001081e 	bne	r2,zero,20af98 <load_cart+0x480>
		cart_type = CART_TYPE_8K;	// default to 8K ROM
  20ab78:	00800044 	movi	r2,1
  20ab7c:	e0bf7515 	stw	r2,-556(fp)
		int start = Systick;
  20ab80:	d0a0cd17 	ldw	r2,-31948(gp)
  20ab84:	e0bf7b15 	stw	r2,-532(fp)
		int length = 0;
  20ab88:	e03f7715 	stw	zero,-548(fp)

		unsigned char *dst = (unsigned char *)EXT_SRAM_CONTROLLER_0_BASE;
  20ab8c:	00800434 	movhi	r2,16
  20ab90:	e0bf7c15 	stw	r2,-528(fp)
		unsigned int *dst32 = (unsigned int *)dst;
  20ab94:	e0bf7c17 	ldw	r2,-528(fp)
  20ab98:	e0bf7815 	stw	r2,-544(fp)
		unsigned char buf[512];	// for file read

		UINT numBytesRead;
		// always read file in 512 byte chunks, since the SPI code is optimised for that
		while (pf_read(buf, 512, &numBytesRead) == FR_OK) {
  20ab9c:	0000c706 	br	20aebc <load_cart+0x3a4>
			int bytesToCopy = numBytesRead;
  20aba0:	e0bf7e17 	ldw	r2,-520(fp)
  20aba4:	e0bf7915 	stw	r2,-540(fp)
			unsigned int *src32 = (unsigned int *)buf;
  20aba8:	e0bf7f04 	addi	r2,fp,-516
  20abac:	e0bf7a15 	stw	r2,-536(fp)
			if (car_file == 1 && (void*)dst32 == (void*)dst) {
  20abb0:	e0bf7617 	ldw	r2,-552(fp)
  20abb4:	10800058 	cmpnei	r2,r2,1
  20abb8:	1000a51e 	bne	r2,zero,20ae50 <load_cart+0x338>
  20abbc:	e0ff7817 	ldw	r3,-544(fp)
  20abc0:	e0bf7c17 	ldw	r2,-528(fp)
  20abc4:	1880a21e 	bne	r3,r2,20ae50 <load_cart+0x338>
				// read cartridge type from header
				int car_type = buf[7];
  20abc8:	e0bf80c3 	ldbu	r2,-509(fp)
  20abcc:	10803fcc 	andi	r2,r2,255
  20abd0:	e0bf7d15 	stw	r2,-524(fp)
				if (car_type == 1) cart_type = CART_TYPE_8K;
  20abd4:	e0bf7d17 	ldw	r2,-524(fp)
  20abd8:	10800058 	cmpnei	r2,r2,1
  20abdc:	1000031e 	bne	r2,zero,20abec <load_cart+0xd4>
  20abe0:	00800044 	movi	r2,1
  20abe4:	e0bf7515 	stw	r2,-556(fp)
  20abe8:	00009306 	br	20ae38 <load_cart+0x320>
				else if (car_type == 2) cart_type = CART_TYPE_16K;
  20abec:	e0bf7d17 	ldw	r2,-524(fp)
  20abf0:	10800098 	cmpnei	r2,r2,2
  20abf4:	1000031e 	bne	r2,zero,20ac04 <load_cart+0xec>
  20abf8:	00800084 	movi	r2,2
  20abfc:	e0bf7515 	stw	r2,-556(fp)
  20ac00:	00008d06 	br	20ae38 <load_cart+0x320>
				else if (car_type == 3) cart_type = CART_TYPE_OSS_16K_034M;
  20ac04:	e0bf7d17 	ldw	r2,-524(fp)
  20ac08:	108000d8 	cmpnei	r2,r2,3
  20ac0c:	1000031e 	bne	r2,zero,20ac1c <load_cart+0x104>
  20ac10:	00800684 	movi	r2,26
  20ac14:	e0bf7515 	stw	r2,-556(fp)
  20ac18:	00008706 	br	20ae38 <load_cart+0x320>
				else if (car_type == 8 || car_type == 22) cart_type = CART_TYPE_WILLIAMS_64K;
  20ac1c:	e0bf7d17 	ldw	r2,-524(fp)
  20ac20:	10800220 	cmpeqi	r2,r2,8
  20ac24:	1000031e 	bne	r2,zero,20ac34 <load_cart+0x11c>
  20ac28:	e0bf7d17 	ldw	r2,-524(fp)
  20ac2c:	10800598 	cmpnei	r2,r2,22
  20ac30:	1000031e 	bne	r2,zero,20ac40 <load_cart+0x128>
  20ac34:	00800644 	movi	r2,25
  20ac38:	e0bf7515 	stw	r2,-556(fp)
  20ac3c:	00007e06 	br	20ae38 <load_cart+0x320>
				else if (car_type == 9) cart_type =  CART_TYPE_EXPRESS_64K;
  20ac40:	e0bf7d17 	ldw	r2,-524(fp)
  20ac44:	10800258 	cmpnei	r2,r2,9
  20ac48:	1000031e 	bne	r2,zero,20ac58 <load_cart+0x140>
  20ac4c:	00800844 	movi	r2,33
  20ac50:	e0bf7515 	stw	r2,-556(fp)
  20ac54:	00007806 	br	20ae38 <load_cart+0x320>
				else if (car_type == 10) cart_type = CART_TYPE_DIAMOND_64K;
  20ac58:	e0bf7d17 	ldw	r2,-524(fp)
  20ac5c:	10800298 	cmpnei	r2,r2,10
  20ac60:	1000031e 	bne	r2,zero,20ac70 <load_cart+0x158>
  20ac64:	00800804 	movi	r2,32
  20ac68:	e0bf7515 	stw	r2,-556(fp)
  20ac6c:	00007206 	br	20ae38 <load_cart+0x320>
				else if (car_type == 11) cart_type =  CART_TYPE_SDX_64K;
  20ac70:	e0bf7d17 	ldw	r2,-524(fp)
  20ac74:	108002d8 	cmpnei	r2,r2,11
  20ac78:	1000031e 	bne	r2,zero,20ac88 <load_cart+0x170>
  20ac7c:	008007c4 	movi	r2,31
  20ac80:	e0bf7515 	stw	r2,-556(fp)
  20ac84:	00006c06 	br	20ae38 <load_cart+0x320>
				else if (car_type == 12) cart_type = CART_TYPE_XEGS_32K;
  20ac88:	e0bf7d17 	ldw	r2,-524(fp)
  20ac8c:	10800318 	cmpnei	r2,r2,12
  20ac90:	1000031e 	bne	r2,zero,20aca0 <load_cart+0x188>
  20ac94:	00800144 	movi	r2,5
  20ac98:	e0bf7515 	stw	r2,-556(fp)
  20ac9c:	00006606 	br	20ae38 <load_cart+0x320>
				else if (car_type == 13) cart_type = CART_TYPE_XEGS_64K;
  20aca0:	e0bf7d17 	ldw	r2,-524(fp)
  20aca4:	10800358 	cmpnei	r2,r2,13
  20aca8:	1000031e 	bne	r2,zero,20acb8 <load_cart+0x1a0>
  20acac:	00800184 	movi	r2,6
  20acb0:	e0bf7515 	stw	r2,-556(fp)
  20acb4:	00006006 	br	20ae38 <load_cart+0x320>
				else if (car_type == 14) cart_type = CART_TYPE_XEGS_128K;
  20acb8:	e0bf7d17 	ldw	r2,-524(fp)
  20acbc:	10800398 	cmpnei	r2,r2,14
  20acc0:	1000031e 	bne	r2,zero,20acd0 <load_cart+0x1b8>
  20acc4:	008001c4 	movi	r2,7
  20acc8:	e0bf7515 	stw	r2,-556(fp)
  20accc:	00005a06 	br	20ae38 <load_cart+0x320>
				else if (car_type == 15) cart_type = CART_TYPE_OSS_16K_TYPE_B;
  20acd0:	e0bf7d17 	ldw	r2,-524(fp)
  20acd4:	108003d8 	cmpnei	r2,r2,15
  20acd8:	1000031e 	bne	r2,zero,20ace8 <load_cart+0x1d0>
  20acdc:	00800704 	movi	r2,28
  20ace0:	e0bf7515 	stw	r2,-556(fp)
  20ace4:	00005406 	br	20ae38 <load_cart+0x320>
				else if (car_type == 18) cart_type = CART_TYPE_BOUNTY_BOB;
  20ace8:	e0bf7d17 	ldw	r2,-524(fp)
  20acec:	10800498 	cmpnei	r2,r2,18
  20acf0:	1000031e 	bne	r2,zero,20ad00 <load_cart+0x1e8>
  20acf4:	00800604 	movi	r2,24
  20acf8:	e0bf7515 	stw	r2,-556(fp)
  20acfc:	00004e06 	br	20ae38 <load_cart+0x320>
				else if (car_type >= 23 && car_type <= 25) cart_type = (car_type - 23) + CART_TYPE_XEGS_256K;
  20ad00:	e0bf7d17 	ldw	r2,-524(fp)
  20ad04:	108005d0 	cmplti	r2,r2,23
  20ad08:	1000071e 	bne	r2,zero,20ad28 <load_cart+0x210>
  20ad0c:	e0bf7d17 	ldw	r2,-524(fp)
  20ad10:	10800688 	cmpgei	r2,r2,26
  20ad14:	1000041e 	bne	r2,zero,20ad28 <load_cart+0x210>
  20ad18:	e0bf7d17 	ldw	r2,-524(fp)
  20ad1c:	10bffc44 	addi	r2,r2,-15
  20ad20:	e0bf7515 	stw	r2,-556(fp)
  20ad24:	00004406 	br	20ae38 <load_cart+0x320>
				else if (car_type >= 26 && car_type <= 32) cart_type = (car_type - 26) + CART_TYPE_MEGACART_16K;
  20ad28:	e0bf7d17 	ldw	r2,-524(fp)
  20ad2c:	10800690 	cmplti	r2,r2,26
  20ad30:	1000071e 	bne	r2,zero,20ad50 <load_cart+0x238>
  20ad34:	e0bf7d17 	ldw	r2,-524(fp)
  20ad38:	10800848 	cmpgei	r2,r2,33
  20ad3c:	1000041e 	bne	r2,zero,20ad50 <load_cart+0x238>
  20ad40:	e0bf7d17 	ldw	r2,-524(fp)
  20ad44:	10bffdc4 	addi	r2,r2,-9
  20ad48:	e0bf7515 	stw	r2,-556(fp)
  20ad4c:	00003a06 	br	20ae38 <load_cart+0x320>
				else if (car_type >= 33 && car_type <= 38) cart_type = (car_type - 33) + CART_TYPE_SW_XEGS_32K;
  20ad50:	e0bf7d17 	ldw	r2,-524(fp)
  20ad54:	10800850 	cmplti	r2,r2,33
  20ad58:	1000071e 	bne	r2,zero,20ad78 <load_cart+0x260>
  20ad5c:	e0bf7d17 	ldw	r2,-524(fp)
  20ad60:	108009c8 	cmpgei	r2,r2,39
  20ad64:	1000041e 	bne	r2,zero,20ad78 <load_cart+0x260>
  20ad68:	e0bf7d17 	ldw	r2,-524(fp)
  20ad6c:	10bffa84 	addi	r2,r2,-22
  20ad70:	e0bf7515 	stw	r2,-556(fp)
  20ad74:	00003006 	br	20ae38 <load_cart+0x320>
				else if (car_type == 40) cart_type = CART_TYPE_BLIZZARD_16K;
  20ad78:	e0bf7d17 	ldw	r2,-524(fp)
  20ad7c:	10800a18 	cmpnei	r2,r2,40
  20ad80:	1000031e 	bne	r2,zero,20ad90 <load_cart+0x278>
  20ad84:	008008c4 	movi	r2,35
  20ad88:	e0bf7515 	stw	r2,-556(fp)
  20ad8c:	00002a06 	br	20ae38 <load_cart+0x320>
				else if (car_type == 41) cart_type = CART_TYPE_ATARIMAX_1MBIT;
  20ad90:	e0bf7d17 	ldw	r2,-524(fp)
  20ad94:	10800a58 	cmpnei	r2,r2,41
  20ad98:	1000031e 	bne	r2,zero,20ada8 <load_cart+0x290>
  20ad9c:	008000c4 	movi	r2,3
  20ada0:	e0bf7515 	stw	r2,-556(fp)
  20ada4:	00002406 	br	20ae38 <load_cart+0x320>
				else if (car_type == 42) cart_type = CART_TYPE_ATARIMAX_8MBIT;
  20ada8:	e0bf7d17 	ldw	r2,-524(fp)
  20adac:	10800a98 	cmpnei	r2,r2,42
  20adb0:	1000031e 	bne	r2,zero,20adc0 <load_cart+0x2a8>
  20adb4:	00800104 	movi	r2,4
  20adb8:	e0bf7515 	stw	r2,-556(fp)
  20adbc:	00001e06 	br	20ae38 <load_cart+0x320>
				else if (car_type == 43) cart_type =  CART_TYPE_SDX_128K;
  20adc0:	e0bf7d17 	ldw	r2,-524(fp)
  20adc4:	10800ad8 	cmpnei	r2,r2,43
  20adc8:	1000031e 	bne	r2,zero,20add8 <load_cart+0x2c0>
  20adcc:	00800884 	movi	r2,34
  20add0:	e0bf7515 	stw	r2,-556(fp)
  20add4:	00001806 	br	20ae38 <load_cart+0x320>
				else if (car_type == 44) cart_type = CART_TYPE_OSS_8K;
  20add8:	e0bf7d17 	ldw	r2,-524(fp)
  20addc:	10800b18 	cmpnei	r2,r2,44
  20ade0:	1000031e 	bne	r2,zero,20adf0 <load_cart+0x2d8>
  20ade4:	00800744 	movi	r2,29
  20ade8:	e0bf7515 	stw	r2,-556(fp)
  20adec:	00001206 	br	20ae38 <load_cart+0x320>
				else if (car_type == 45) cart_type = CART_TYPE_OSS_16K_043M;
  20adf0:	e0bf7d17 	ldw	r2,-524(fp)
  20adf4:	10800b58 	cmpnei	r2,r2,45
  20adf8:	1000031e 	bne	r2,zero,20ae08 <load_cart+0x2f0>
  20adfc:	008006c4 	movi	r2,27
  20ae00:	e0bf7515 	stw	r2,-556(fp)
  20ae04:	00000c06 	br	20ae38 <load_cart+0x320>
				else if (car_type >= 54 && car_type <=56) cart_type = CART_TYPE_SIC;
  20ae08:	e0bf7d17 	ldw	r2,-524(fp)
  20ae0c:	10800d90 	cmplti	r2,r2,54
  20ae10:	1000061e 	bne	r2,zero,20ae2c <load_cart+0x314>
  20ae14:	e0bf7d17 	ldw	r2,-524(fp)
  20ae18:	10800e48 	cmpgei	r2,r2,57
  20ae1c:	1000031e 	bne	r2,zero,20ae2c <load_cart+0x314>
  20ae20:	00800784 	movi	r2,30
  20ae24:	e0bf7515 	stw	r2,-556(fp)
  20ae28:	00000306 	br	20ae38 <load_cart+0x320>
				else { cart_type = -2; break; }	// unsupported car type
  20ae2c:	00bfff84 	movi	r2,-2
  20ae30:	e0bf7515 	stw	r2,-556(fp)
  20ae34:	00002806 	br	20aed8 <load_cart+0x3c0>
				bytesToCopy -= 16;
  20ae38:	e0bf7917 	ldw	r2,-540(fp)
  20ae3c:	10bffc04 	addi	r2,r2,-16
  20ae40:	e0bf7915 	stw	r2,-540(fp)
				src32 += 4;
  20ae44:	e0bf7a17 	ldw	r2,-536(fp)
  20ae48:	10800404 	addi	r2,r2,16
  20ae4c:	e0bf7a15 	stw	r2,-536(fp)
			}
			for (i=0; i<bytesToCopy/4; i++)
  20ae50:	e03f7415 	stw	zero,-560(fp)
  20ae54:	00000b06 	br	20ae84 <load_cart+0x36c>
				*dst32++ = *src32++;
  20ae58:	e0bf7817 	ldw	r2,-544(fp)
  20ae5c:	10c00104 	addi	r3,r2,4
  20ae60:	e0ff7815 	stw	r3,-544(fp)
  20ae64:	e0ff7a17 	ldw	r3,-536(fp)
  20ae68:	19000104 	addi	r4,r3,4
  20ae6c:	e13f7a15 	stw	r4,-536(fp)
  20ae70:	18c00017 	ldw	r3,0(r3)
  20ae74:	10c00015 	stw	r3,0(r2)
				else if (car_type >= 54 && car_type <=56) cart_type = CART_TYPE_SIC;
				else { cart_type = -2; break; }	// unsupported car type
				bytesToCopy -= 16;
				src32 += 4;
			}
			for (i=0; i<bytesToCopy/4; i++)
  20ae78:	e0bf7417 	ldw	r2,-560(fp)
  20ae7c:	10800044 	addi	r2,r2,1
  20ae80:	e0bf7415 	stw	r2,-560(fp)
  20ae84:	e0bf7917 	ldw	r2,-540(fp)
  20ae88:	1000010e 	bge	r2,zero,20ae90 <load_cart+0x378>
  20ae8c:	108000c4 	addi	r2,r2,3
  20ae90:	1005d0ba 	srai	r2,r2,2
  20ae94:	e0ff7417 	ldw	r3,-560(fp)
  20ae98:	18bfef16 	blt	r3,r2,20ae58 <_gp+0xffff5268>
				*dst32++ = *src32++;
			length += bytesToCopy;
  20ae9c:	e0ff7717 	ldw	r3,-548(fp)
  20aea0:	e0bf7917 	ldw	r2,-540(fp)
  20aea4:	1885883a 	add	r2,r3,r2
  20aea8:	e0bf7715 	stw	r2,-548(fp)
			if (numBytesRead < 512)
  20aeac:	e0bf7e17 	ldw	r2,-520(fp)
  20aeb0:	10808028 	cmpgeui	r2,r2,512
  20aeb4:	1000011e 	bne	r2,zero,20aebc <load_cart+0x3a4>
				break;
  20aeb8:	00000706 	br	20aed8 <load_cart+0x3c0>
		unsigned int *dst32 = (unsigned int *)dst;
		unsigned char buf[512];	// for file read

		UINT numBytesRead;
		// always read file in 512 byte chunks, since the SPI code is optimised for that
		while (pf_read(buf, 512, &numBytesRead) == FR_OK) {
  20aebc:	e0ff7f04 	addi	r3,fp,-516
  20aec0:	e0bf7e04 	addi	r2,fp,-520
  20aec4:	1809883a 	mov	r4,r3
  20aec8:	01408004 	movi	r5,512
  20aecc:	100d883a 	mov	r6,r2
  20aed0:	02096dc0 	call	2096dc <pf_read>
  20aed4:	103f3226 	beq	r2,zero,20aba0 <_gp+0xffff4fb0>
			length += bytesToCopy;
			if (numBytesRead < 512)
				break;
		}

		if (car_file == 0) {
  20aed8:	e0bf7617 	ldw	r2,-552(fp)
  20aedc:	1000291e 	bne	r2,zero,20af84 <load_cart+0x46c>
			// not a CAR file, try to guess the type
			if (length == 16*1024) cart_type = CART_TYPE_16K;
  20aee0:	e0bf7717 	ldw	r2,-548(fp)
  20aee4:	10900018 	cmpnei	r2,r2,16384
  20aee8:	1000031e 	bne	r2,zero,20aef8 <load_cart+0x3e0>
  20aeec:	00800084 	movi	r2,2
  20aef0:	e0bf7515 	stw	r2,-556(fp)
  20aef4:	00002306 	br	20af84 <load_cart+0x46c>
			else if (length == 32*1024) cart_type = CART_TYPE_XEGS_32K;
  20aef8:	e0ff7717 	ldw	r3,-548(fp)
  20aefc:	00a00014 	movui	r2,32768
  20af00:	1880031e 	bne	r3,r2,20af10 <load_cart+0x3f8>
  20af04:	00800144 	movi	r2,5
  20af08:	e0bf7515 	stw	r2,-556(fp)
  20af0c:	00001d06 	br	20af84 <load_cart+0x46c>
			else if (length == 64*1024) cart_type = CART_TYPE_XEGS_64K;
  20af10:	e0ff7717 	ldw	r3,-548(fp)
  20af14:	00800074 	movhi	r2,1
  20af18:	1880031e 	bne	r3,r2,20af28 <load_cart+0x410>
  20af1c:	00800184 	movi	r2,6
  20af20:	e0bf7515 	stw	r2,-556(fp)
  20af24:	00001706 	br	20af84 <load_cart+0x46c>
			else if (length == 128*1024) cart_type = CART_TYPE_XEGS_128K;
  20af28:	e0ff7717 	ldw	r3,-548(fp)
  20af2c:	008000b4 	movhi	r2,2
  20af30:	1880031e 	bne	r3,r2,20af40 <load_cart+0x428>
  20af34:	008001c4 	movi	r2,7
  20af38:	e0bf7515 	stw	r2,-556(fp)
  20af3c:	00001106 	br	20af84 <load_cart+0x46c>
			else if (length == 256*1024) cart_type = CART_TYPE_SIC;
  20af40:	e0ff7717 	ldw	r3,-548(fp)
  20af44:	00800134 	movhi	r2,4
  20af48:	1880031e 	bne	r3,r2,20af58 <load_cart+0x440>
  20af4c:	00800784 	movi	r2,30
  20af50:	e0bf7515 	stw	r2,-556(fp)
  20af54:	00000b06 	br	20af84 <load_cart+0x46c>
			else if (length == 512*1024) cart_type = CART_TYPE_SIC;
  20af58:	e0ff7717 	ldw	r3,-548(fp)
  20af5c:	00800234 	movhi	r2,8
  20af60:	1880031e 	bne	r3,r2,20af70 <load_cart+0x458>
  20af64:	00800784 	movi	r2,30
  20af68:	e0bf7515 	stw	r2,-556(fp)
  20af6c:	00000506 	br	20af84 <load_cart+0x46c>
			else if (length == 1024*1024) cart_type = CART_TYPE_ATARIMAX_8MBIT;
  20af70:	e0ff7717 	ldw	r3,-548(fp)
  20af74:	00800434 	movhi	r2,16
  20af78:	1880021e 	bne	r3,r2,20af84 <load_cart+0x46c>
  20af7c:	00800104 	movi	r2,4
  20af80:	e0bf7515 	stw	r2,-556(fp)
		}

		if (length % 1024 != 0) {
  20af84:	e0bf7717 	ldw	r2,-548(fp)
  20af88:	1080ffcc 	andi	r2,r2,1023
  20af8c:	10000226 	beq	r2,zero,20af98 <load_cart+0x480>
			// if ROM length not a multiple of 1024 bytes, must be a bad file
			cart_type = -1;
  20af90:	00bfffc4 	movi	r2,-1
  20af94:	e0bf7515 	stw	r2,-556(fp)

		//printf("cart type=%d\n", cart_type);
		//printf("copied %d bytes to SRAM\n", length);
		//printf("took %d ms\n", (Systick - start));
	}
	return cart_type;
  20af98:	e0bf7517 	ldw	r2,-556(fp)
}
  20af9c:	e037883a 	mov	sp,fp
  20afa0:	dfc00117 	ldw	ra,4(sp)
  20afa4:	df000017 	ldw	fp,0(sp)
  20afa8:	dec00204 	addi	sp,sp,8
  20afac:	f800283a 	ret

0020afb0 <main>:

int main()
{
  20afb0:	deff2604 	addi	sp,sp,-872
  20afb4:	dfc0d915 	stw	ra,868(sp)
  20afb8:	df00d815 	stw	fp,864(sp)
  20afbc:	df00d804 	addi	fp,sp,864
	FATFS fs;
	int i;
	char path[256] = "";
  20afc0:	e03f3f15 	stw	zero,-772(fp)
  20afc4:	e0ff4004 	addi	r3,fp,-768
  20afc8:	00803f04 	movi	r2,252
  20afcc:	1809883a 	mov	r4,r3
  20afd0:	000b883a 	mov	r5,zero
  20afd4:	100d883a 	mov	r6,r2
  20afd8:	020b55c0 	call	20b55c <memset>

	/* Init timer system */
	alt_alarm_start(&alarm, 1, &TimerFunction, NULL);
  20afdc:	01000874 	movhi	r4,33
  20afe0:	2137d304 	addi	r4,r4,-8372
  20afe4:	01400044 	movi	r5,1
  20afe8:	01800874 	movhi	r6,33
  20afec:	31a94e04 	addi	r6,r6,-23240
  20aff0:	000f883a 	mov	r7,zero
  20aff4:	020bcd80 	call	20bcd8 <alt_alarm_start>

	IOWR(SEL_CARTRIDGE_TYPE_BASE, 0, CART_TYPE_BOOT);
  20aff8:	0007883a 	mov	r3,zero
  20affc:	00800874 	movhi	r2,33
  20b000:	10941804 	addi	r2,r2,20576
  20b004:	10c00035 	stwio	r3,0(r2)
	IOWR(RESET_D500_BASE, 0, 0);
  20b008:	0007883a 	mov	r3,zero
  20b00c:	00800874 	movhi	r2,33
  20b010:	10941004 	addi	r2,r2,20544
  20b014:	10c00035 	stwio	r3,0(r2)

	ffs_DiskIOInit();
  20b018:	020a1080 	call	20a108 <ffs_DiskIOInit>
	if (pf_mount(&fs) != FR_OK) {
  20b01c:	e0bf3404 	addi	r2,fp,-816
  20b020:	1009883a 	mov	r4,r2
  20b024:	02091d80 	call	2091d8 <pf_mount>
  20b028:	10000526 	beq	r2,zero,20b040 <main+0x90>
	//	printf("terminating");
		set_cart_error("No SD Card? Insert then reboot.");
  20b02c:	01000874 	movhi	r4,33
  20b030:	21358204 	addi	r4,r4,-10744
  20b034:	020aa0c0 	call	20aa0c <set_cart_error>
		return 0;
  20b038:	0005883a 	mov	r2,zero
  20b03c:	0000e906 	br	20b3e4 <main+0x434>
	}

	// check for a different boot image
	if (pf_open("_BOOT.ROM") == FR_OK) {
  20b040:	01000874 	movhi	r4,33
  20b044:	21358a04 	addi	r4,r4,-10712
  20b048:	02095cc0 	call	2095cc <pf_open>
  20b04c:	1000201e 	bne	r2,zero,20b0d0 <main+0x120>
		unsigned char buf[512];	// for file read
		unsigned int *dst32 = (unsigned int *)CART_MEMORY_BASE;
  20b050:	00800874 	movhi	r2,33
  20b054:	10880004 	addi	r2,r2,8192
  20b058:	e0bf2915 	stw	r2,-860(fp)
		UINT br;
		while (pf_read(buf, 512, &br) == FR_OK && br == 512)
  20b05c:	00001206 	br	20b0a8 <main+0xf8>
		{
			unsigned int *src32 = (unsigned int *)buf;
  20b060:	e0bf8004 	addi	r2,fp,-512
  20b064:	e0bf2a15 	stw	r2,-856(fp)
			for (i=0; i<512/4; i++)
  20b068:	e03f2815 	stw	zero,-864(fp)
  20b06c:	00000b06 	br	20b09c <main+0xec>
				*dst32++ = *src32++;
  20b070:	e0bf2917 	ldw	r2,-860(fp)
  20b074:	10c00104 	addi	r3,r2,4
  20b078:	e0ff2915 	stw	r3,-860(fp)
  20b07c:	e0ff2a17 	ldw	r3,-856(fp)
  20b080:	19000104 	addi	r4,r3,4
  20b084:	e13f2a15 	stw	r4,-856(fp)
  20b088:	18c00017 	ldw	r3,0(r3)
  20b08c:	10c00015 	stw	r3,0(r2)
		unsigned int *dst32 = (unsigned int *)CART_MEMORY_BASE;
		UINT br;
		while (pf_read(buf, 512, &br) == FR_OK && br == 512)
		{
			unsigned int *src32 = (unsigned int *)buf;
			for (i=0; i<512/4; i++)
  20b090:	e0bf2817 	ldw	r2,-864(fp)
  20b094:	10800044 	addi	r2,r2,1
  20b098:	e0bf2815 	stw	r2,-864(fp)
  20b09c:	e0bf2817 	ldw	r2,-864(fp)
  20b0a0:	10802010 	cmplti	r2,r2,128
  20b0a4:	103ff21e 	bne	r2,zero,20b070 <_gp+0xffff5480>
	// check for a different boot image
	if (pf_open("_BOOT.ROM") == FR_OK) {
		unsigned char buf[512];	// for file read
		unsigned int *dst32 = (unsigned int *)CART_MEMORY_BASE;
		UINT br;
		while (pf_read(buf, 512, &br) == FR_OK && br == 512)
  20b0a8:	e0ff8004 	addi	r3,fp,-512
  20b0ac:	e0bf7f04 	addi	r2,fp,-516
  20b0b0:	1809883a 	mov	r4,r3
  20b0b4:	01408004 	movi	r5,512
  20b0b8:	100d883a 	mov	r6,r2
  20b0bc:	02096dc0 	call	2096dc <pf_read>
  20b0c0:	1000031e 	bne	r2,zero,20b0d0 <main+0x120>
  20b0c4:	e0bf7f17 	ldw	r2,-516(fp)
  20b0c8:	10808020 	cmpeqi	r2,r2,512
  20b0cc:	103fe41e 	bne	r2,zero,20b060 <_gp+0xffff5470>
			for (i=0; i<512/4; i++)
				*dst32++ = *src32++;
		}
	}

	FRESULT res = read_directory(path);
  20b0d0:	e0bf3f04 	addi	r2,fp,-772
  20b0d4:	1009883a 	mov	r4,r2
  20b0d8:	020a6f00 	call	20a6f0 <read_directory>
  20b0dc:	e0bf2b15 	stw	r2,-852(fp)
	DIR_ENTRY *dir_entries = (DIR_ENTRY *)EXT_SRAM_CONTROLLER_0_BASE;
  20b0e0:	00800434 	movhi	r2,16
  20b0e4:	e0bf2f15 	stw	r2,-836(fp)
	// main loop
	while (1)
	{
		if (res != FR_OK) {
  20b0e8:	e0bf2b17 	ldw	r2,-852(fp)
  20b0ec:	10000426 	beq	r2,zero,20b100 <main+0x150>
			set_cart_error("Reading directory from SD card");
  20b0f0:	01000874 	movhi	r4,33
  20b0f4:	21358d04 	addi	r4,r4,-10700
  20b0f8:	020aa0c0 	call	20aa0c <set_cart_error>
			break;
  20b0fc:	0000b806 	br	20b3e0 <main+0x430>
		}
		populate_cart_file_list();
  20b100:	020a8a40 	call	20a8a4 <populate_cart_file_list>
		// tell the atari if there are pages above/below
		unsigned char list_flag = 0;
  20b104:	e03f2c05 	stb	zero,-848(fp)
		if (dir_offset > 0) list_flag |= LIST_FLAG_ABOVE;
  20b108:	d0a0cf17 	ldw	r2,-31940(gp)
  20b10c:	0080030e 	bge	zero,r2,20b11c <main+0x16c>
  20b110:	e0bf2c03 	ldbu	r2,-848(fp)
  20b114:	10800054 	ori	r2,r2,1
  20b118:	e0bf2c05 	stb	r2,-848(fp)
		if (dir_offset + DIR_ENTRIES_PER_PAGE < num_dir_entries) list_flag |= LIST_FLAG_BELOW;
  20b11c:	d0a0cf17 	ldw	r2,-31940(gp)
  20b120:	10c00504 	addi	r3,r2,20
  20b124:	d0a0ce17 	ldw	r2,-31944(gp)
  20b128:	1880030e 	bge	r3,r2,20b138 <main+0x188>
  20b12c:	e0bf2c03 	ldbu	r2,-848(fp)
  20b130:	10800094 	ori	r2,r2,2
  20b134:	e0bf2c05 	stb	r2,-848(fp)
		set_cart_list_flag_byte(list_flag);
  20b138:	e0bf2c03 	ldbu	r2,-848(fp)
  20b13c:	1009883a 	mov	r4,r2
  20b140:	020a9d80 	call	20a9d8 <set_cart_list_flag_byte>

		// tell the atari to redisplay directory
		set_cart_cmd_byte(CART_CMD_DISPLAY_DIR);
  20b144:	01000044 	movi	r4,1
  20b148:	020a9a40 	call	20a9a4 <set_cart_cmd_byte>
		recieve_atari_byte();
  20b14c:	020aa500 	call	20aa50 <recieve_atari_byte>
		set_cart_cmd_byte(CART_CMD_IDLE);
  20b150:	0009883a 	mov	r4,zero
  20b154:	020a9a40 	call	20a9a4 <set_cart_cmd_byte>

		// wait for a menu selection from atari
		unsigned char atari_ret = recieve_atari_byte();
  20b158:	020aa500 	call	20aa50 <recieve_atari_byte>
  20b15c:	e0bf3005 	stb	r2,-832(fp)
		if (atari_ret >=1 && atari_ret <=20) {
  20b160:	e0bf3003 	ldbu	r2,-832(fp)
  20b164:	10005b26 	beq	r2,zero,20b2d4 <main+0x324>
  20b168:	e0bf3003 	ldbu	r2,-832(fp)
  20b16c:	10800568 	cmpgeui	r2,r2,21
  20b170:	1000581e 	bne	r2,zero,20b2d4 <main+0x324>
			// item selected
			DIR_ENTRY *entry = &dir_entries[dir_offset + atari_ret-1];
  20b174:	e0ff3003 	ldbu	r3,-832(fp)
  20b178:	d0a0cf17 	ldw	r2,-31940(gp)
  20b17c:	1885883a 	add	r2,r3,r2
  20b180:	1009883a 	mov	r4,r2
  20b184:	01400b84 	movi	r5,46
  20b188:	020b50c0 	call	20b50c <__mulsi3>
  20b18c:	10bff484 	addi	r2,r2,-46
  20b190:	e0ff2f17 	ldw	r3,-836(fp)
  20b194:	1885883a 	add	r2,r3,r2
  20b198:	e0bf3115 	stw	r2,-828(fp)
			strcat(path, "/");
  20b19c:	e0bf3f04 	addi	r2,fp,-772
  20b1a0:	1009883a 	mov	r4,r2
  20b1a4:	020bb940 	call	20bb94 <strlen>
  20b1a8:	e0ff3f04 	addi	r3,fp,-772
  20b1ac:	1885883a 	add	r2,r3,r2
  20b1b0:	00c00bc4 	movi	r3,47
  20b1b4:	10c00005 	stb	r3,0(r2)
  20b1b8:	10000045 	stb	zero,1(r2)
			strcat(path, entry->filename);
  20b1bc:	e0bf3117 	ldw	r2,-828(fp)
  20b1c0:	10800044 	addi	r2,r2,1
  20b1c4:	e0ff3f04 	addi	r3,fp,-772
  20b1c8:	1809883a 	mov	r4,r3
  20b1cc:	100b883a 	mov	r5,r2
  20b1d0:	020bb0c0 	call	20bb0c <strcat>
			if (entry->isDir)
  20b1d4:	e0bf3117 	ldw	r2,-828(fp)
  20b1d8:	10800003 	ldbu	r2,0(r2)
  20b1dc:	10803fcc 	andi	r2,r2,255
  20b1e0:	1080201c 	xori	r2,r2,128
  20b1e4:	10bfe004 	addi	r2,r2,-128
  20b1e8:	10000526 	beq	r2,zero,20b200 <main+0x250>
			{	// directory selected
				res = read_directory(path);
  20b1ec:	e0bf3f04 	addi	r2,fp,-772
  20b1f0:	1009883a 	mov	r4,r2
  20b1f4:	020a6f00 	call	20a6f0 <read_directory>
  20b1f8:	e0bf2b15 	stw	r2,-852(fp)
		recieve_atari_byte();
		set_cart_cmd_byte(CART_CMD_IDLE);

		// wait for a menu selection from atari
		unsigned char atari_ret = recieve_atari_byte();
		if (atari_ret >=1 && atari_ret <=20) {
  20b1fc:	00007706 	br	20b3dc <main+0x42c>
			{	// directory selected
				res = read_directory(path);
			}
			else
			{	// file selected
				int cart_type = load_cart(path);
  20b200:	e0bf3f04 	addi	r2,fp,-772
  20b204:	1009883a 	mov	r4,r2
  20b208:	020ab180 	call	20ab18 <load_cart>
  20b20c:	e0bf3215 	stw	r2,-824(fp)
				if (cart_type > 0)
  20b210:	e0bf3217 	ldw	r2,-824(fp)
  20b214:	0080030e 	bge	zero,r2,20b224 <main+0x274>
				{
					atari_reboot_with_cart(cart_type);
  20b218:	e13f3217 	ldw	r4,-824(fp)
  20b21c:	020aab00 	call	20aab0 <atari_reboot_with_cart>
					break;
  20b220:	00006f06 	br	20b3e0 <main+0x430>
				}
				else
				{
					if (cart_type == -2)
  20b224:	e0bf3217 	ldw	r2,-824(fp)
  20b228:	10bfff98 	cmpnei	r2,r2,-2
  20b22c:	1000041e 	bne	r2,zero,20b240 <main+0x290>
						set_cart_error("Unsupported cartridge type");
  20b230:	01000874 	movhi	r4,33
  20b234:	21359504 	addi	r4,r4,-10668
  20b238:	020aa0c0 	call	20aa0c <set_cart_error>
  20b23c:	00000306 	br	20b24c <main+0x29c>
					else
						set_cart_error("Bad ROM/CAR file?");
  20b240:	01000874 	movhi	r4,33
  20b244:	21359c04 	addi	r4,r4,-10640
  20b248:	020aa0c0 	call	20aa0c <set_cart_error>
					recieve_atari_byte();
  20b24c:	020aa500 	call	20aa50 <recieve_atari_byte>
					set_cart_cmd_byte(CART_CMD_IDLE);
  20b250:	0009883a 	mov	r4,zero
  20b254:	020a9a40 	call	20a9a4 <set_cart_cmd_byte>
					// remove the filename from the path, so we get the current directory again when we loop
					int len = strlen(path);
  20b258:	e0bf3f04 	addi	r2,fp,-772
  20b25c:	1009883a 	mov	r4,r2
  20b260:	020bb940 	call	20bb94 <strlen>
  20b264:	e0bf2d15 	stw	r2,-844(fp)
					while (len && path[--len] != '/');
  20b268:	e0bf2d17 	ldw	r2,-844(fp)
  20b26c:	10000c26 	beq	r2,zero,20b2a0 <main+0x2f0>
  20b270:	e0bf2d17 	ldw	r2,-844(fp)
  20b274:	10bfffc4 	addi	r2,r2,-1
  20b278:	e0bf2d15 	stw	r2,-844(fp)
  20b27c:	e0ff3f04 	addi	r3,fp,-772
  20b280:	e0bf2d17 	ldw	r2,-844(fp)
  20b284:	1885883a 	add	r2,r3,r2
  20b288:	10800003 	ldbu	r2,0(r2)
  20b28c:	10803fcc 	andi	r2,r2,255
  20b290:	1080201c 	xori	r2,r2,128
  20b294:	10bfe004 	addi	r2,r2,-128
  20b298:	10800bd8 	cmpnei	r2,r2,47
  20b29c:	103ff21e 	bne	r2,zero,20b268 <_gp+0xffff5678>
					path[len] = 0;
  20b2a0:	e0ff3f04 	addi	r3,fp,-772
  20b2a4:	e0bf2d17 	ldw	r2,-844(fp)
  20b2a8:	1885883a 	add	r2,r3,r2
  20b2ac:	10000005 	stb	zero,0(r2)
					// we need to read the directory again, since the SRAM contents may have been overwritten
					int old_dir_offset = dir_offset;
  20b2b0:	d0a0cf17 	ldw	r2,-31940(gp)
  20b2b4:	e0bf3315 	stw	r2,-820(fp)
					res = read_directory(path);
  20b2b8:	e0bf3f04 	addi	r2,fp,-772
  20b2bc:	1009883a 	mov	r4,r2
  20b2c0:	020a6f00 	call	20a6f0 <read_directory>
  20b2c4:	e0bf2b15 	stw	r2,-852(fp)
					dir_offset = old_dir_offset;
  20b2c8:	e0bf3317 	ldw	r2,-820(fp)
  20b2cc:	d0a0cf15 	stw	r2,-31940(gp)
		recieve_atari_byte();
		set_cart_cmd_byte(CART_CMD_IDLE);

		// wait for a menu selection from atari
		unsigned char atari_ret = recieve_atari_byte();
		if (atari_ret >=1 && atari_ret <=20) {
  20b2d0:	00004206 	br	20b3dc <main+0x42c>
					res = read_directory(path);
					dir_offset = old_dir_offset;
				}
			}
		}
		else if (atari_ret == ATARI_CMD_DISABLE) {
  20b2d4:	e0bf3003 	ldbu	r2,-832(fp)
  20b2d8:	10801018 	cmpnei	r2,r2,64
  20b2dc:	1000031e 	bne	r2,zero,20b2ec <main+0x33c>
			// disable cartridge
			atari_reboot_with_cart(CART_TYPE_NONE);
  20b2e0:	01003fc4 	movi	r4,255
  20b2e4:	020aab00 	call	20aab0 <atari_reboot_with_cart>
			break;
  20b2e8:	00003d06 	br	20b3e0 <main+0x430>
		}
		else if (atari_ret == ATARI_CMD_NEXT_PAGE) {
  20b2ec:	e0bf3003 	ldbu	r2,-832(fp)
  20b2f0:	10802018 	cmpnei	r2,r2,128
  20b2f4:	1000081e 	bne	r2,zero,20b318 <main+0x368>
			// next page
			if (dir_offset + DIR_ENTRIES_PER_PAGE < num_dir_entries)
  20b2f8:	d0a0cf17 	ldw	r2,-31940(gp)
  20b2fc:	10c00504 	addi	r3,r2,20
  20b300:	d0a0ce17 	ldw	r2,-31944(gp)
  20b304:	1880350e 	bge	r3,r2,20b3dc <main+0x42c>
				dir_offset += DIR_ENTRIES_PER_PAGE;
  20b308:	d0a0cf17 	ldw	r2,-31940(gp)
  20b30c:	10800504 	addi	r2,r2,20
  20b310:	d0a0cf15 	stw	r2,-31940(gp)
		else if (atari_ret == ATARI_CMD_RESET) {
			// atari sends this cmd in reset key trap
			path[0] = 0;
			res = read_directory(path);
		}
	}
  20b314:	003f7406 	br	20b0e8 <_gp+0xffff54f8>
		else if (atari_ret == ATARI_CMD_NEXT_PAGE) {
			// next page
			if (dir_offset + DIR_ENTRIES_PER_PAGE < num_dir_entries)
				dir_offset += DIR_ENTRIES_PER_PAGE;
		}
		else if (atari_ret == ATARI_CMD_PREV_PAGE) {
  20b318:	e0bf3003 	ldbu	r2,-832(fp)
  20b31c:	10801fd8 	cmpnei	r2,r2,127
  20b320:	1000071e 	bne	r2,zero,20b340 <main+0x390>
			// prev page
			if (dir_offset >= DIR_ENTRIES_PER_PAGE)
  20b324:	d0a0cf17 	ldw	r2,-31940(gp)
  20b328:	10800510 	cmplti	r2,r2,20
  20b32c:	10002b1e 	bne	r2,zero,20b3dc <main+0x42c>
				dir_offset -= DIR_ENTRIES_PER_PAGE;
  20b330:	d0a0cf17 	ldw	r2,-31940(gp)
  20b334:	10bffb04 	addi	r2,r2,-20
  20b338:	d0a0cf15 	stw	r2,-31940(gp)
		else if (atari_ret == ATARI_CMD_RESET) {
			// atari sends this cmd in reset key trap
			path[0] = 0;
			res = read_directory(path);
		}
	}
  20b33c:	003f6a06 	br	20b0e8 <_gp+0xffff54f8>
		else if (atari_ret == ATARI_CMD_PREV_PAGE) {
			// prev page
			if (dir_offset >= DIR_ENTRIES_PER_PAGE)
				dir_offset -= DIR_ENTRIES_PER_PAGE;
		}
		else if (atari_ret == ATARI_CMD_UP_DIR) {
  20b340:	e0bf3003 	ldbu	r2,-832(fp)
  20b344:	10802058 	cmpnei	r2,r2,129
  20b348:	10001b1e 	bne	r2,zero,20b3b8 <main+0x408>
			// up a directory
			int len = strlen(path);
  20b34c:	e0bf3f04 	addi	r2,fp,-772
  20b350:	1009883a 	mov	r4,r2
  20b354:	020bb940 	call	20bb94 <strlen>
  20b358:	e0bf2e15 	stw	r2,-840(fp)
			while (len && path[--len] != '/');
  20b35c:	e0bf2e17 	ldw	r2,-840(fp)
  20b360:	10000c26 	beq	r2,zero,20b394 <main+0x3e4>
  20b364:	e0bf2e17 	ldw	r2,-840(fp)
  20b368:	10bfffc4 	addi	r2,r2,-1
  20b36c:	e0bf2e15 	stw	r2,-840(fp)
  20b370:	e0ff3f04 	addi	r3,fp,-772
  20b374:	e0bf2e17 	ldw	r2,-840(fp)
  20b378:	1885883a 	add	r2,r3,r2
  20b37c:	10800003 	ldbu	r2,0(r2)
  20b380:	10803fcc 	andi	r2,r2,255
  20b384:	1080201c 	xori	r2,r2,128
  20b388:	10bfe004 	addi	r2,r2,-128
  20b38c:	10800bd8 	cmpnei	r2,r2,47
  20b390:	103ff21e 	bne	r2,zero,20b35c <_gp+0xffff576c>
			path[len] = 0;
  20b394:	e0ff3f04 	addi	r3,fp,-772
  20b398:	e0bf2e17 	ldw	r2,-840(fp)
  20b39c:	1885883a 	add	r2,r3,r2
  20b3a0:	10000005 	stb	zero,0(r2)
			res = read_directory(path);
  20b3a4:	e0bf3f04 	addi	r2,fp,-772
  20b3a8:	1009883a 	mov	r4,r2
  20b3ac:	020a6f00 	call	20a6f0 <read_directory>
  20b3b0:	e0bf2b15 	stw	r2,-852(fp)
  20b3b4:	00000906 	br	20b3dc <main+0x42c>
		}
		else if (atari_ret == ATARI_CMD_RESET) {
  20b3b8:	e0bf3003 	ldbu	r2,-832(fp)
  20b3bc:	10802098 	cmpnei	r2,r2,130
  20b3c0:	1000061e 	bne	r2,zero,20b3dc <main+0x42c>
			// atari sends this cmd in reset key trap
			path[0] = 0;
  20b3c4:	e03f3f05 	stb	zero,-772(fp)
			res = read_directory(path);
  20b3c8:	e0bf3f04 	addi	r2,fp,-772
  20b3cc:	1009883a 	mov	r4,r2
  20b3d0:	020a6f00 	call	20a6f0 <read_directory>
  20b3d4:	e0bf2b15 	stw	r2,-852(fp)
		}
	}
  20b3d8:	003f4306 	br	20b0e8 <_gp+0xffff54f8>
  20b3dc:	003f4206 	br	20b0e8 <_gp+0xffff54f8>
	return 0;
  20b3e0:	0005883a 	mov	r2,zero
}
  20b3e4:	e037883a 	mov	sp,fp
  20b3e8:	dfc00117 	ldw	ra,4(sp)
  20b3ec:	df000017 	ldw	fp,0(sp)
  20b3f0:	dec00204 	addi	sp,sp,8
  20b3f4:	f800283a 	ret

0020b3f8 <udivmodsi4>:
  20b3f8:	2900182e 	bgeu	r5,r4,20b45c <udivmodsi4+0x64>
  20b3fc:	28001716 	blt	r5,zero,20b45c <udivmodsi4+0x64>
  20b400:	00800804 	movi	r2,32
  20b404:	00c00044 	movi	r3,1
  20b408:	00000206 	br	20b414 <udivmodsi4+0x1c>
  20b40c:	10001126 	beq	r2,zero,20b454 <udivmodsi4+0x5c>
  20b410:	28000516 	blt	r5,zero,20b428 <udivmodsi4+0x30>
  20b414:	294b883a 	add	r5,r5,r5
  20b418:	10bfffc4 	addi	r2,r2,-1
  20b41c:	18c7883a 	add	r3,r3,r3
  20b420:	293ffa36 	bltu	r5,r4,20b40c <_gp+0xffff581c>
  20b424:	18000b26 	beq	r3,zero,20b454 <udivmodsi4+0x5c>
  20b428:	0005883a 	mov	r2,zero
  20b42c:	21400236 	bltu	r4,r5,20b438 <udivmodsi4+0x40>
  20b430:	2149c83a 	sub	r4,r4,r5
  20b434:	10c4b03a 	or	r2,r2,r3
  20b438:	1806d07a 	srli	r3,r3,1
  20b43c:	280ad07a 	srli	r5,r5,1
  20b440:	183ffa1e 	bne	r3,zero,20b42c <_gp+0xffff583c>
  20b444:	3000011e 	bne	r6,zero,20b44c <udivmodsi4+0x54>
  20b448:	f800283a 	ret
  20b44c:	2005883a 	mov	r2,r4
  20b450:	f800283a 	ret
  20b454:	0005883a 	mov	r2,zero
  20b458:	003ffa06 	br	20b444 <_gp+0xffff5854>
  20b45c:	00c00044 	movi	r3,1
  20b460:	0005883a 	mov	r2,zero
  20b464:	003ff106 	br	20b42c <_gp+0xffff583c>

0020b468 <__divsi3>:
  20b468:	deffff04 	addi	sp,sp,-4
  20b46c:	dfc00015 	stw	ra,0(sp)
  20b470:	20000916 	blt	r4,zero,20b498 <__divsi3+0x30>
  20b474:	000f883a 	mov	r7,zero
  20b478:	28000a16 	blt	r5,zero,20b4a4 <__divsi3+0x3c>
  20b47c:	000d883a 	mov	r6,zero
  20b480:	020b3f80 	call	20b3f8 <udivmodsi4>
  20b484:	38000126 	beq	r7,zero,20b48c <__divsi3+0x24>
  20b488:	0085c83a 	sub	r2,zero,r2
  20b48c:	dfc00017 	ldw	ra,0(sp)
  20b490:	dec00104 	addi	sp,sp,4
  20b494:	f800283a 	ret
  20b498:	0109c83a 	sub	r4,zero,r4
  20b49c:	01c00044 	movi	r7,1
  20b4a0:	283ff60e 	bge	r5,zero,20b47c <_gp+0xffff588c>
  20b4a4:	014bc83a 	sub	r5,zero,r5
  20b4a8:	39c0005c 	xori	r7,r7,1
  20b4ac:	003ff306 	br	20b47c <_gp+0xffff588c>

0020b4b0 <__modsi3>:
  20b4b0:	20000316 	blt	r4,zero,20b4c0 <__modsi3+0x10>
  20b4b4:	28000c16 	blt	r5,zero,20b4e8 <__modsi3+0x38>
  20b4b8:	01800044 	movi	r6,1
  20b4bc:	020b3f81 	jmpi	20b3f8 <udivmodsi4>
  20b4c0:	deffff04 	addi	sp,sp,-4
  20b4c4:	dfc00015 	stw	ra,0(sp)
  20b4c8:	0109c83a 	sub	r4,zero,r4
  20b4cc:	28000916 	blt	r5,zero,20b4f4 <__modsi3+0x44>
  20b4d0:	01800044 	movi	r6,1
  20b4d4:	020b3f80 	call	20b3f8 <udivmodsi4>
  20b4d8:	0085c83a 	sub	r2,zero,r2
  20b4dc:	dfc00017 	ldw	ra,0(sp)
  20b4e0:	dec00104 	addi	sp,sp,4
  20b4e4:	f800283a 	ret
  20b4e8:	014bc83a 	sub	r5,zero,r5
  20b4ec:	01800044 	movi	r6,1
  20b4f0:	020b3f81 	jmpi	20b3f8 <udivmodsi4>
  20b4f4:	014bc83a 	sub	r5,zero,r5
  20b4f8:	003ff506 	br	20b4d0 <_gp+0xffff58e0>

0020b4fc <__udivsi3>:
  20b4fc:	000d883a 	mov	r6,zero
  20b500:	020b3f81 	jmpi	20b3f8 <udivmodsi4>

0020b504 <__umodsi3>:
  20b504:	01800044 	movi	r6,1
  20b508:	020b3f81 	jmpi	20b3f8 <udivmodsi4>

0020b50c <__mulsi3>:
  20b50c:	0005883a 	mov	r2,zero
  20b510:	20000726 	beq	r4,zero,20b530 <__mulsi3+0x24>
  20b514:	20c0004c 	andi	r3,r4,1
  20b518:	2008d07a 	srli	r4,r4,1
  20b51c:	18000126 	beq	r3,zero,20b524 <__mulsi3+0x18>
  20b520:	1145883a 	add	r2,r2,r5
  20b524:	294b883a 	add	r5,r5,r5
  20b528:	203ffa1e 	bne	r4,zero,20b514 <_gp+0xffff5924>
  20b52c:	f800283a 	ret
  20b530:	f800283a 	ret

0020b534 <memcpy>:
  20b534:	2005883a 	mov	r2,r4
  20b538:	0007883a 	mov	r3,zero
  20b53c:	19800626 	beq	r3,r6,20b558 <memcpy+0x24>
  20b540:	28c9883a 	add	r4,r5,r3
  20b544:	21c00003 	ldbu	r7,0(r4)
  20b548:	10c9883a 	add	r4,r2,r3
  20b54c:	18c00044 	addi	r3,r3,1
  20b550:	21c00005 	stb	r7,0(r4)
  20b554:	003ff906 	br	20b53c <_gp+0xffff594c>
  20b558:	f800283a 	ret

0020b55c <memset>:
  20b55c:	2005883a 	mov	r2,r4
  20b560:	2007883a 	mov	r3,r4
  20b564:	218d883a 	add	r6,r4,r6
  20b568:	19800326 	beq	r3,r6,20b578 <memset+0x1c>
  20b56c:	19400005 	stb	r5,0(r3)
  20b570:	18c00044 	addi	r3,r3,1
  20b574:	003ffc06 	br	20b568 <_gp+0xffff5978>
  20b578:	f800283a 	ret

0020b57c <swapfunc>:
  20b57c:	00800044 	movi	r2,1
  20b580:	11c00a16 	blt	r2,r7,20b5ac <swapfunc+0x30>
  20b584:	300cd0ba 	srli	r6,r6,2
  20b588:	28c00017 	ldw	r3,0(r5)
  20b58c:	20800017 	ldw	r2,0(r4)
  20b590:	31bfffc4 	addi	r6,r6,-1
  20b594:	20c00015 	stw	r3,0(r4)
  20b598:	28800015 	stw	r2,0(r5)
  20b59c:	21000104 	addi	r4,r4,4
  20b5a0:	29400104 	addi	r5,r5,4
  20b5a4:	01bff816 	blt	zero,r6,20b588 <_gp+0xffff5998>
  20b5a8:	f800283a 	ret
  20b5ac:	218d883a 	add	r6,r4,r6
  20b5b0:	28c00003 	ldbu	r3,0(r5)
  20b5b4:	20800003 	ldbu	r2,0(r4)
  20b5b8:	21000044 	addi	r4,r4,1
  20b5bc:	20ffffc5 	stb	r3,-1(r4)
  20b5c0:	28800005 	stb	r2,0(r5)
  20b5c4:	3105c83a 	sub	r2,r6,r4
  20b5c8:	29400044 	addi	r5,r5,1
  20b5cc:	00bff816 	blt	zero,r2,20b5b0 <_gp+0xffff59c0>
  20b5d0:	f800283a 	ret

0020b5d4 <med3>:
  20b5d4:	defffb04 	addi	sp,sp,-20
  20b5d8:	dcc00315 	stw	r19,12(sp)
  20b5dc:	dc800215 	stw	r18,8(sp)
  20b5e0:	dc400115 	stw	r17,4(sp)
  20b5e4:	2825883a 	mov	r18,r5
  20b5e8:	dc000015 	stw	r16,0(sp)
  20b5ec:	2027883a 	mov	r19,r4
  20b5f0:	3021883a 	mov	r16,r6
  20b5f4:	dfc00415 	stw	ra,16(sp)
  20b5f8:	3823883a 	mov	r17,r7
  20b5fc:	383ee83a 	callr	r7
  20b600:	9009883a 	mov	r4,r18
  20b604:	800b883a 	mov	r5,r16
  20b608:	10000a0e 	bge	r2,zero,20b634 <med3+0x60>
  20b60c:	883ee83a 	callr	r17
  20b610:	10000616 	blt	r2,zero,20b62c <med3+0x58>
  20b614:	9809883a 	mov	r4,r19
  20b618:	800b883a 	mov	r5,r16
  20b61c:	883ee83a 	callr	r17
  20b620:	10000e16 	blt	r2,zero,20b65c <med3+0x88>
  20b624:	9821883a 	mov	r16,r19
  20b628:	00000c06 	br	20b65c <med3+0x88>
  20b62c:	9021883a 	mov	r16,r18
  20b630:	00000a06 	br	20b65c <med3+0x88>
  20b634:	883ee83a 	callr	r17
  20b638:	00800616 	blt	zero,r2,20b654 <med3+0x80>
  20b63c:	9809883a 	mov	r4,r19
  20b640:	800b883a 	mov	r5,r16
  20b644:	883ee83a 	callr	r17
  20b648:	1000040e 	bge	r2,zero,20b65c <med3+0x88>
  20b64c:	9805883a 	mov	r2,r19
  20b650:	00000306 	br	20b660 <med3+0x8c>
  20b654:	9005883a 	mov	r2,r18
  20b658:	00000106 	br	20b660 <med3+0x8c>
  20b65c:	8005883a 	mov	r2,r16
  20b660:	dfc00417 	ldw	ra,16(sp)
  20b664:	dcc00317 	ldw	r19,12(sp)
  20b668:	dc800217 	ldw	r18,8(sp)
  20b66c:	dc400117 	ldw	r17,4(sp)
  20b670:	dc000017 	ldw	r16,0(sp)
  20b674:	dec00504 	addi	sp,sp,20
  20b678:	f800283a 	ret

0020b67c <qsort>:
  20b67c:	defff004 	addi	sp,sp,-64
  20b680:	308000cc 	andi	r2,r6,3
  20b684:	d8800115 	stw	r2,4(sp)
  20b688:	30800118 	cmpnei	r2,r6,4
  20b68c:	dd000a15 	stw	r20,40(sp)
  20b690:	dcc00915 	stw	r19,36(sp)
  20b694:	dc400715 	stw	r17,28(sp)
  20b698:	dc000615 	stw	r16,24(sp)
  20b69c:	dfc00f15 	stw	ra,60(sp)
  20b6a0:	df000e15 	stw	fp,56(sp)
  20b6a4:	ddc00d15 	stw	r23,52(sp)
  20b6a8:	dd800c15 	stw	r22,48(sp)
  20b6ac:	dd400b15 	stw	r21,44(sp)
  20b6b0:	dc800815 	stw	r18,32(sp)
  20b6b4:	2023883a 	mov	r17,r4
  20b6b8:	2827883a 	mov	r19,r5
  20b6bc:	3021883a 	mov	r16,r6
  20b6c0:	3829883a 	mov	r20,r7
  20b6c4:	d8800215 	stw	r2,8(sp)
  20b6c8:	888000cc 	andi	r2,r17,3
  20b6cc:	1000041e 	bne	r2,zero,20b6e0 <qsort+0x64>
  20b6d0:	d8800117 	ldw	r2,4(sp)
  20b6d4:	1000021e 	bne	r2,zero,20b6e0 <qsort+0x64>
  20b6d8:	dc800217 	ldw	r18,8(sp)
  20b6dc:	00000106 	br	20b6e4 <qsort+0x68>
  20b6e0:	04800084 	movi	r18,2
  20b6e4:	00800184 	movi	r2,6
  20b6e8:	8c2f883a 	add	r23,r17,r16
  20b6ec:	14c01b36 	bltu	r2,r19,20b75c <qsort+0xe0>
  20b6f0:	9809883a 	mov	r4,r19
  20b6f4:	800b883a 	mov	r5,r16
  20b6f8:	020b50c0 	call	20b50c <__mulsi3>
  20b6fc:	88ad883a 	add	r22,r17,r2
  20b700:	bd80e02e 	bgeu	r23,r22,20ba84 <qsort+0x408>
  20b704:	b827883a 	mov	r19,r23
  20b708:	8cc0122e 	bgeu	r17,r19,20b754 <qsort+0xd8>
  20b70c:	9c2bc83a 	sub	r21,r19,r16
  20b710:	a809883a 	mov	r4,r21
  20b714:	980b883a 	mov	r5,r19
  20b718:	a03ee83a 	callr	r20
  20b71c:	00800d0e 	bge	zero,r2,20b754 <qsort+0xd8>
  20b720:	9000051e 	bne	r18,zero,20b738 <qsort+0xbc>
  20b724:	a8c00017 	ldw	r3,0(r21)
  20b728:	98800017 	ldw	r2,0(r19)
  20b72c:	98c00015 	stw	r3,0(r19)
  20b730:	a8800015 	stw	r2,0(r21)
  20b734:	00000506 	br	20b74c <qsort+0xd0>
  20b738:	9809883a 	mov	r4,r19
  20b73c:	a80b883a 	mov	r5,r21
  20b740:	800d883a 	mov	r6,r16
  20b744:	900f883a 	mov	r7,r18
  20b748:	020b57c0 	call	20b57c <swapfunc>
  20b74c:	a827883a 	mov	r19,r21
  20b750:	003fed06 	br	20b708 <_gp+0xffff5b18>
  20b754:	bc2f883a 	add	r23,r23,r16
  20b758:	003fe906 	br	20b700 <_gp+0xffff5b10>
  20b75c:	9808d07a 	srli	r4,r19,1
  20b760:	800b883a 	mov	r5,r16
  20b764:	9d7fffc4 	addi	r21,r19,-1
  20b768:	020b50c0 	call	20b50c <__mulsi3>
  20b76c:	88ad883a 	add	r22,r17,r2
  20b770:	008001c4 	movi	r2,7
  20b774:	98802c26 	beq	r19,r2,20b828 <qsort+0x1ac>
  20b778:	a809883a 	mov	r4,r21
  20b77c:	800b883a 	mov	r5,r16
  20b780:	020b50c0 	call	20b50c <__mulsi3>
  20b784:	88b9883a 	add	fp,r17,r2
  20b788:	00800a04 	movi	r2,40
  20b78c:	14c01f2e 	bgeu	r2,r19,20b80c <qsort+0x190>
  20b790:	9808d0fa 	srli	r4,r19,3
  20b794:	800b883a 	mov	r5,r16
  20b798:	020b50c0 	call	20b50c <__mulsi3>
  20b79c:	1097883a 	add	r11,r2,r2
  20b7a0:	8acd883a 	add	r6,r17,r11
  20b7a4:	8809883a 	mov	r4,r17
  20b7a8:	888b883a 	add	r5,r17,r2
  20b7ac:	a00f883a 	mov	r7,r20
  20b7b0:	dac00415 	stw	r11,16(sp)
  20b7b4:	d8800315 	stw	r2,12(sp)
  20b7b8:	020b5d40 	call	20b5d4 <med3>
  20b7bc:	da000317 	ldw	r8,12(sp)
  20b7c0:	b00b883a 	mov	r5,r22
  20b7c4:	a00f883a 	mov	r7,r20
  20b7c8:	0215c83a 	sub	r10,zero,r8
  20b7cc:	b289883a 	add	r4,r22,r10
  20b7d0:	b20d883a 	add	r6,r22,r8
  20b7d4:	da800315 	stw	r10,12(sp)
  20b7d8:	d8800515 	stw	r2,20(sp)
  20b7dc:	020b5d40 	call	20b5d4 <med3>
  20b7e0:	dac00417 	ldw	r11,16(sp)
  20b7e4:	da800317 	ldw	r10,12(sp)
  20b7e8:	e00d883a 	mov	r6,fp
  20b7ec:	e2c9c83a 	sub	r4,fp,r11
  20b7f0:	e28b883a 	add	r5,fp,r10
  20b7f4:	a00f883a 	mov	r7,r20
  20b7f8:	102d883a 	mov	r22,r2
  20b7fc:	020b5d40 	call	20b5d4 <med3>
  20b800:	1039883a 	mov	fp,r2
  20b804:	da400517 	ldw	r9,20(sp)
  20b808:	00000106 	br	20b810 <qsort+0x194>
  20b80c:	8813883a 	mov	r9,r17
  20b810:	b00b883a 	mov	r5,r22
  20b814:	4809883a 	mov	r4,r9
  20b818:	e00d883a 	mov	r6,fp
  20b81c:	a00f883a 	mov	r7,r20
  20b820:	020b5d40 	call	20b5d4 <med3>
  20b824:	102d883a 	mov	r22,r2
  20b828:	9000051e 	bne	r18,zero,20b840 <qsort+0x1c4>
  20b82c:	b0c00017 	ldw	r3,0(r22)
  20b830:	88800017 	ldw	r2,0(r17)
  20b834:	88c00015 	stw	r3,0(r17)
  20b838:	b0800015 	stw	r2,0(r22)
  20b83c:	00000506 	br	20b854 <qsort+0x1d8>
  20b840:	8809883a 	mov	r4,r17
  20b844:	b00b883a 	mov	r5,r22
  20b848:	800d883a 	mov	r6,r16
  20b84c:	900f883a 	mov	r7,r18
  20b850:	020b57c0 	call	20b57c <swapfunc>
  20b854:	a809883a 	mov	r4,r21
  20b858:	800b883a 	mov	r5,r16
  20b85c:	ddc00015 	stw	r23,0(sp)
  20b860:	020b50c0 	call	20b50c <__mulsi3>
  20b864:	df000017 	ldw	fp,0(sp)
  20b868:	88af883a 	add	r23,r17,r2
  20b86c:	b82d883a 	mov	r22,r23
  20b870:	e02b883a 	mov	r21,fp
  20b874:	0007883a 	mov	r3,zero
  20b878:	bf001f36 	bltu	r23,fp,20b8f8 <qsort+0x27c>
  20b87c:	e009883a 	mov	r4,fp
  20b880:	880b883a 	mov	r5,r17
  20b884:	d8c00315 	stw	r3,12(sp)
  20b888:	a03ee83a 	callr	r20
  20b88c:	d8c00317 	ldw	r3,12(sp)
  20b890:	00801916 	blt	zero,r2,20b8f8 <qsort+0x27c>
  20b894:	10000d1e 	bne	r2,zero,20b8cc <qsort+0x250>
  20b898:	9000051e 	bne	r18,zero,20b8b0 <qsort+0x234>
  20b89c:	e1000017 	ldw	r4,0(fp)
  20b8a0:	a8800017 	ldw	r2,0(r21)
  20b8a4:	a9000015 	stw	r4,0(r21)
  20b8a8:	e0800015 	stw	r2,0(fp)
  20b8ac:	00000506 	br	20b8c4 <qsort+0x248>
  20b8b0:	a809883a 	mov	r4,r21
  20b8b4:	e00b883a 	mov	r5,fp
  20b8b8:	800d883a 	mov	r6,r16
  20b8bc:	900f883a 	mov	r7,r18
  20b8c0:	020b57c0 	call	20b57c <swapfunc>
  20b8c4:	ac2b883a 	add	r21,r21,r16
  20b8c8:	00c00044 	movi	r3,1
  20b8cc:	e439883a 	add	fp,fp,r16
  20b8d0:	003fe906 	br	20b878 <_gp+0xffff5c88>
  20b8d4:	b809883a 	mov	r4,r23
  20b8d8:	880b883a 	mov	r5,r17
  20b8dc:	d8c00315 	stw	r3,12(sp)
  20b8e0:	a03ee83a 	callr	r20
  20b8e4:	bc13c83a 	sub	r9,r23,r16
  20b8e8:	d8c00317 	ldw	r3,12(sp)
  20b8ec:	10001216 	blt	r2,zero,20b938 <qsort+0x2bc>
  20b8f0:	10000326 	beq	r2,zero,20b900 <qsort+0x284>
  20b8f4:	482f883a 	mov	r23,r9
  20b8f8:	bf3ff62e 	bgeu	r23,fp,20b8d4 <_gp+0xffff5ce4>
  20b8fc:	00001d06 	br	20b974 <qsort+0x2f8>
  20b900:	9000051e 	bne	r18,zero,20b918 <qsort+0x29c>
  20b904:	b1000017 	ldw	r4,0(r22)
  20b908:	b8800017 	ldw	r2,0(r23)
  20b90c:	b9000015 	stw	r4,0(r23)
  20b910:	b0800015 	stw	r2,0(r22)
  20b914:	00000506 	br	20b92c <qsort+0x2b0>
  20b918:	b809883a 	mov	r4,r23
  20b91c:	b00b883a 	mov	r5,r22
  20b920:	800d883a 	mov	r6,r16
  20b924:	900f883a 	mov	r7,r18
  20b928:	020b57c0 	call	20b57c <swapfunc>
  20b92c:	b42dc83a 	sub	r22,r22,r16
  20b930:	00c00044 	movi	r3,1
  20b934:	003fef06 	br	20b8f4 <_gp+0xffff5d04>
  20b938:	9000051e 	bne	r18,zero,20b950 <qsort+0x2d4>
  20b93c:	b9000017 	ldw	r4,0(r23)
  20b940:	e0800017 	ldw	r2,0(fp)
  20b944:	e1000015 	stw	r4,0(fp)
  20b948:	b8800015 	stw	r2,0(r23)
  20b94c:	00000506 	br	20b964 <qsort+0x2e8>
  20b950:	e009883a 	mov	r4,fp
  20b954:	b80b883a 	mov	r5,r23
  20b958:	800d883a 	mov	r6,r16
  20b95c:	900f883a 	mov	r7,r18
  20b960:	020b57c0 	call	20b57c <swapfunc>
  20b964:	e439883a 	add	fp,fp,r16
  20b968:	482f883a 	mov	r23,r9
  20b96c:	00c00044 	movi	r3,1
  20b970:	003fc106 	br	20b878 <_gp+0xffff5c88>
  20b974:	9809883a 	mov	r4,r19
  20b978:	800b883a 	mov	r5,r16
  20b97c:	18002526 	beq	r3,zero,20ba14 <qsort+0x398>
  20b980:	020b50c0 	call	20b50c <__mulsi3>
  20b984:	e553c83a 	sub	r9,fp,r21
  20b988:	ac4dc83a 	sub	r6,r21,r17
  20b98c:	88a7883a 	add	r19,r17,r2
  20b990:	4980010e 	bge	r9,r6,20b998 <qsort+0x31c>
  20b994:	480d883a 	mov	r6,r9
  20b998:	0180040e 	bge	zero,r6,20b9ac <qsort+0x330>
  20b99c:	8809883a 	mov	r4,r17
  20b9a0:	e18bc83a 	sub	r5,fp,r6
  20b9a4:	900f883a 	mov	r7,r18
  20b9a8:	020b57c0 	call	20b57c <swapfunc>
  20b9ac:	b5ebc83a 	sub	r21,r22,r23
  20b9b0:	9dadc83a 	sub	r22,r19,r22
  20b9b4:	b40dc83a 	sub	r6,r22,r16
  20b9b8:	a980012e 	bgeu	r21,r6,20b9c0 <qsort+0x344>
  20b9bc:	a80d883a 	mov	r6,r21
  20b9c0:	0180040e 	bge	zero,r6,20b9d4 <qsort+0x358>
  20b9c4:	e009883a 	mov	r4,fp
  20b9c8:	998bc83a 	sub	r5,r19,r6
  20b9cc:	900f883a 	mov	r7,r18
  20b9d0:	020b57c0 	call	20b57c <swapfunc>
  20b9d4:	8240082e 	bgeu	r16,r9,20b9f8 <qsort+0x37c>
  20b9d8:	4809883a 	mov	r4,r9
  20b9dc:	800b883a 	mov	r5,r16
  20b9e0:	020b4fc0 	call	20b4fc <__udivsi3>
  20b9e4:	8809883a 	mov	r4,r17
  20b9e8:	100b883a 	mov	r5,r2
  20b9ec:	800d883a 	mov	r6,r16
  20b9f0:	a00f883a 	mov	r7,r20
  20b9f4:	020b67c0 	call	20b67c <qsort>
  20b9f8:	8540222e 	bgeu	r16,r21,20ba84 <qsort+0x408>
  20b9fc:	a809883a 	mov	r4,r21
  20ba00:	800b883a 	mov	r5,r16
  20ba04:	020b4fc0 	call	20b4fc <__udivsi3>
  20ba08:	9d63c83a 	sub	r17,r19,r21
  20ba0c:	1027883a 	mov	r19,r2
  20ba10:	003f2d06 	br	20b6c8 <_gp+0xffff5ad8>
  20ba14:	020b50c0 	call	20b50c <__mulsi3>
  20ba18:	88ad883a 	add	r22,r17,r2
  20ba1c:	d8800017 	ldw	r2,0(sp)
  20ba20:	1580182e 	bgeu	r2,r22,20ba84 <qsort+0x408>
  20ba24:	1027883a 	mov	r19,r2
  20ba28:	8cc0122e 	bgeu	r17,r19,20ba74 <qsort+0x3f8>
  20ba2c:	9c2bc83a 	sub	r21,r19,r16
  20ba30:	a809883a 	mov	r4,r21
  20ba34:	980b883a 	mov	r5,r19
  20ba38:	a03ee83a 	callr	r20
  20ba3c:	00800d0e 	bge	zero,r2,20ba74 <qsort+0x3f8>
  20ba40:	9000051e 	bne	r18,zero,20ba58 <qsort+0x3dc>
  20ba44:	a8c00017 	ldw	r3,0(r21)
  20ba48:	98800017 	ldw	r2,0(r19)
  20ba4c:	98c00015 	stw	r3,0(r19)
  20ba50:	a8800015 	stw	r2,0(r21)
  20ba54:	00000506 	br	20ba6c <qsort+0x3f0>
  20ba58:	9809883a 	mov	r4,r19
  20ba5c:	a80b883a 	mov	r5,r21
  20ba60:	800d883a 	mov	r6,r16
  20ba64:	900f883a 	mov	r7,r18
  20ba68:	020b57c0 	call	20b57c <swapfunc>
  20ba6c:	a827883a 	mov	r19,r21
  20ba70:	003fed06 	br	20ba28 <_gp+0xffff5e38>
  20ba74:	d8800017 	ldw	r2,0(sp)
  20ba78:	1405883a 	add	r2,r2,r16
  20ba7c:	d8800015 	stw	r2,0(sp)
  20ba80:	003fe606 	br	20ba1c <_gp+0xffff5e2c>
  20ba84:	dfc00f17 	ldw	ra,60(sp)
  20ba88:	df000e17 	ldw	fp,56(sp)
  20ba8c:	ddc00d17 	ldw	r23,52(sp)
  20ba90:	dd800c17 	ldw	r22,48(sp)
  20ba94:	dd400b17 	ldw	r21,44(sp)
  20ba98:	dd000a17 	ldw	r20,40(sp)
  20ba9c:	dcc00917 	ldw	r19,36(sp)
  20baa0:	dc800817 	ldw	r18,32(sp)
  20baa4:	dc400717 	ldw	r17,28(sp)
  20baa8:	dc000617 	ldw	r16,24(sp)
  20baac:	dec01004 	addi	sp,sp,64
  20bab0:	f800283a 	ret

0020bab4 <strcasecmp>:
  20bab4:	00800874 	movhi	r2,33
  20bab8:	10b6fe04 	addi	r2,r2,-9224
  20babc:	11800017 	ldw	r6,0(r2)
  20bac0:	01c00044 	movi	r7,1
  20bac4:	20800003 	ldbu	r2,0(r4)
  20bac8:	3087883a 	add	r3,r6,r2
  20bacc:	18c00043 	ldbu	r3,1(r3)
  20bad0:	18c000cc 	andi	r3,r3,3
  20bad4:	19c0011e 	bne	r3,r7,20badc <strcasecmp+0x28>
  20bad8:	10800804 	addi	r2,r2,32
  20badc:	28c00003 	ldbu	r3,0(r5)
  20bae0:	30d1883a 	add	r8,r6,r3
  20bae4:	42000043 	ldbu	r8,1(r8)
  20bae8:	420000cc 	andi	r8,r8,3
  20baec:	41c0011e 	bne	r8,r7,20baf4 <strcasecmp+0x40>
  20baf0:	18c00804 	addi	r3,r3,32
  20baf4:	10c5c83a 	sub	r2,r2,r3
  20baf8:	1000031e 	bne	r2,zero,20bb08 <strcasecmp+0x54>
  20bafc:	21000044 	addi	r4,r4,1
  20bb00:	29400044 	addi	r5,r5,1
  20bb04:	183fef1e 	bne	r3,zero,20bac4 <_gp+0xffff5ed4>
  20bb08:	f800283a 	ret

0020bb0c <strcat>:
  20bb0c:	2005883a 	mov	r2,r4
  20bb10:	2007883a 	mov	r3,r4
  20bb14:	19000007 	ldb	r4,0(r3)
  20bb18:	20000226 	beq	r4,zero,20bb24 <strcat+0x18>
  20bb1c:	18c00044 	addi	r3,r3,1
  20bb20:	003ffc06 	br	20bb14 <_gp+0xffff5f24>
  20bb24:	29000007 	ldb	r4,0(r5)
  20bb28:	18c00044 	addi	r3,r3,1
  20bb2c:	29400044 	addi	r5,r5,1
  20bb30:	193fffc5 	stb	r4,-1(r3)
  20bb34:	203ffb1e 	bne	r4,zero,20bb24 <_gp+0xffff5f34>
  20bb38:	f800283a 	ret

0020bb3c <strcmp>:
  20bb3c:	20800003 	ldbu	r2,0(r4)
  20bb40:	10c03fcc 	andi	r3,r2,255
  20bb44:	18c0201c 	xori	r3,r3,128
  20bb48:	18ffe004 	addi	r3,r3,-128
  20bb4c:	18000526 	beq	r3,zero,20bb64 <strcmp+0x28>
  20bb50:	29800007 	ldb	r6,0(r5)
  20bb54:	1980031e 	bne	r3,r6,20bb64 <strcmp+0x28>
  20bb58:	21000044 	addi	r4,r4,1
  20bb5c:	29400044 	addi	r5,r5,1
  20bb60:	003ff606 	br	20bb3c <_gp+0xffff5f4c>
  20bb64:	28c00003 	ldbu	r3,0(r5)
  20bb68:	10803fcc 	andi	r2,r2,255
  20bb6c:	10c5c83a 	sub	r2,r2,r3
  20bb70:	f800283a 	ret

0020bb74 <strcpy>:
  20bb74:	2005883a 	mov	r2,r4
  20bb78:	2007883a 	mov	r3,r4
  20bb7c:	29000007 	ldb	r4,0(r5)
  20bb80:	18c00044 	addi	r3,r3,1
  20bb84:	29400044 	addi	r5,r5,1
  20bb88:	193fffc5 	stb	r4,-1(r3)
  20bb8c:	203ffb1e 	bne	r4,zero,20bb7c <_gp+0xffff5f8c>
  20bb90:	f800283a 	ret

0020bb94 <strlen>:
  20bb94:	2005883a 	mov	r2,r4
  20bb98:	10c00007 	ldb	r3,0(r2)
  20bb9c:	18000226 	beq	r3,zero,20bba8 <strlen+0x14>
  20bba0:	10800044 	addi	r2,r2,1
  20bba4:	003ffc06 	br	20bb98 <_gp+0xffff5fa8>
  20bba8:	1105c83a 	sub	r2,r2,r4
  20bbac:	f800283a 	ret

0020bbb0 <strncmp>:
  20bbb0:	30000e26 	beq	r6,zero,20bbec <strncmp+0x3c>
  20bbb4:	01c00044 	movi	r7,1
  20bbb8:	20800007 	ldb	r2,0(r4)
  20bbbc:	28c00007 	ldb	r3,0(r5)
  20bbc0:	10c0011e 	bne	r2,r3,20bbc8 <strncmp+0x18>
  20bbc4:	31c0041e 	bne	r6,r7,20bbd8 <strncmp+0x28>
  20bbc8:	20c00003 	ldbu	r3,0(r4)
  20bbcc:	28800003 	ldbu	r2,0(r5)
  20bbd0:	1885c83a 	sub	r2,r3,r2
  20bbd4:	f800283a 	ret
  20bbd8:	31bfffc4 	addi	r6,r6,-1
  20bbdc:	103ffa26 	beq	r2,zero,20bbc8 <_gp+0xffff5fd8>
  20bbe0:	21000044 	addi	r4,r4,1
  20bbe4:	29400044 	addi	r5,r5,1
  20bbe8:	003ff306 	br	20bbb8 <_gp+0xffff5fc8>
  20bbec:	0005883a 	mov	r2,zero
  20bbf0:	f800283a 	ret

0020bbf4 <strncpy>:
  20bbf4:	2005883a 	mov	r2,r4
  20bbf8:	200f883a 	mov	r7,r4
  20bbfc:	3807883a 	mov	r3,r7
  20bc00:	30000626 	beq	r6,zero,20bc1c <strncpy+0x28>
  20bc04:	29000007 	ldb	r4,0(r5)
  20bc08:	31bfffc4 	addi	r6,r6,-1
  20bc0c:	18c00044 	addi	r3,r3,1
  20bc10:	39000005 	stb	r4,0(r7)
  20bc14:	29400044 	addi	r5,r5,1
  20bc18:	2000021e 	bne	r4,zero,20bc24 <strncpy+0x30>
  20bc1c:	198d883a 	add	r6,r3,r6
  20bc20:	00000206 	br	20bc2c <strncpy+0x38>
  20bc24:	180f883a 	mov	r7,r3
  20bc28:	003ff406 	br	20bbfc <_gp+0xffff600c>
  20bc2c:	19800326 	beq	r3,r6,20bc3c <strncpy+0x48>
  20bc30:	18000005 	stb	zero,0(r3)
  20bc34:	18c00044 	addi	r3,r3,1
  20bc38:	003ffc06 	br	20bc2c <_gp+0xffff603c>
  20bc3c:	f800283a 	ret

0020bc40 <strrchr>:
  20bc40:	defffd04 	addi	sp,sp,-12
  20bc44:	dc400115 	stw	r17,4(sp)
  20bc48:	dfc00215 	stw	ra,8(sp)
  20bc4c:	dc000015 	stw	r16,0(sp)
  20bc50:	2823883a 	mov	r17,r5
  20bc54:	28000926 	beq	r5,zero,20bc7c <strrchr+0x3c>
  20bc58:	2007883a 	mov	r3,r4
  20bc5c:	0021883a 	mov	r16,zero
  20bc60:	1809883a 	mov	r4,r3
  20bc64:	880b883a 	mov	r5,r17
  20bc68:	020bca80 	call	20bca8 <strchr>
  20bc6c:	10000826 	beq	r2,zero,20bc90 <strrchr+0x50>
  20bc70:	10c00044 	addi	r3,r2,1
  20bc74:	1021883a 	mov	r16,r2
  20bc78:	003ff906 	br	20bc60 <_gp+0xffff6070>
  20bc7c:	dfc00217 	ldw	ra,8(sp)
  20bc80:	dc400117 	ldw	r17,4(sp)
  20bc84:	dc000017 	ldw	r16,0(sp)
  20bc88:	dec00304 	addi	sp,sp,12
  20bc8c:	020bca81 	jmpi	20bca8 <strchr>
  20bc90:	8005883a 	mov	r2,r16
  20bc94:	dfc00217 	ldw	ra,8(sp)
  20bc98:	dc400117 	ldw	r17,4(sp)
  20bc9c:	dc000017 	ldw	r16,0(sp)
  20bca0:	dec00304 	addi	sp,sp,12
  20bca4:	f800283a 	ret

0020bca8 <strchr>:
  20bca8:	28c03fcc 	andi	r3,r5,255
  20bcac:	20800003 	ldbu	r2,0(r4)
  20bcb0:	10000526 	beq	r2,zero,20bcc8 <strchr+0x20>
  20bcb4:	10c00226 	beq	r2,r3,20bcc0 <strchr+0x18>
  20bcb8:	21000044 	addi	r4,r4,1
  20bcbc:	003ffb06 	br	20bcac <_gp+0xffff60bc>
  20bcc0:	2005883a 	mov	r2,r4
  20bcc4:	f800283a 	ret
  20bcc8:	29403fcc 	andi	r5,r5,255
  20bccc:	283ffc26 	beq	r5,zero,20bcc0 <_gp+0xffff60d0>
  20bcd0:	0005883a 	mov	r2,zero
  20bcd4:	f800283a 	ret

0020bcd8 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  20bcd8:	defff504 	addi	sp,sp,-44
  20bcdc:	df000a15 	stw	fp,40(sp)
  20bce0:	df000a04 	addi	fp,sp,40
  20bce4:	e13ffc15 	stw	r4,-16(fp)
  20bce8:	e17ffd15 	stw	r5,-12(fp)
  20bcec:	e1bffe15 	stw	r6,-8(fp)
  20bcf0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  20bcf4:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  20bcf8:	00800874 	movhi	r2,33
  20bcfc:	10b7cf04 	addi	r2,r2,-8388
  20bd00:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
  20bd04:	10003f26 	beq	r2,zero,20be04 <alt_alarm_start+0x12c>
  {
    if (alarm)
  20bd08:	e0bffc17 	ldw	r2,-16(fp)
  20bd0c:	10003b26 	beq	r2,zero,20bdfc <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
  20bd10:	e0bffc17 	ldw	r2,-16(fp)
  20bd14:	e0fffe17 	ldw	r3,-8(fp)
  20bd18:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  20bd1c:	e0bffc17 	ldw	r2,-16(fp)
  20bd20:	e0ffff17 	ldw	r3,-4(fp)
  20bd24:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  20bd28:	0005303a 	rdctl	r2,status
  20bd2c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20bd30:	e0fff817 	ldw	r3,-32(fp)
  20bd34:	00bfff84 	movi	r2,-2
  20bd38:	1884703a 	and	r2,r3,r2
  20bd3c:	1001703a 	wrctl	status,r2
  
  return context;
  20bd40:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
  20bd44:	e0bff715 	stw	r2,-36(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  20bd48:	00800874 	movhi	r2,33
  20bd4c:	10b7d004 	addi	r2,r2,-8384
  20bd50:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
  20bd54:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  20bd58:	e0fffd17 	ldw	r3,-12(fp)
  20bd5c:	e0bff617 	ldw	r2,-40(fp)
  20bd60:	1885883a 	add	r2,r3,r2
  20bd64:	10c00044 	addi	r3,r2,1
  20bd68:	e0bffc17 	ldw	r2,-16(fp)
  20bd6c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  20bd70:	e0bffc17 	ldw	r2,-16(fp)
  20bd74:	10c00217 	ldw	r3,8(r2)
  20bd78:	e0bff617 	ldw	r2,-40(fp)
  20bd7c:	1880042e 	bgeu	r3,r2,20bd90 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
  20bd80:	e0bffc17 	ldw	r2,-16(fp)
  20bd84:	00c00044 	movi	r3,1
  20bd88:	10c00405 	stb	r3,16(r2)
  20bd8c:	00000206 	br	20bd98 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
  20bd90:	e0bffc17 	ldw	r2,-16(fp)
  20bd94:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  20bd98:	e0bffc17 	ldw	r2,-16(fp)
  20bd9c:	00c00874 	movhi	r3,33
  20bda0:	18f6ff04 	addi	r3,r3,-9220
  20bda4:	e0fff915 	stw	r3,-28(fp)
  20bda8:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  20bdac:	e0bffa17 	ldw	r2,-24(fp)
  20bdb0:	e0fff917 	ldw	r3,-28(fp)
  20bdb4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  20bdb8:	e0bff917 	ldw	r2,-28(fp)
  20bdbc:	10c00017 	ldw	r3,0(r2)
  20bdc0:	e0bffa17 	ldw	r2,-24(fp)
  20bdc4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  20bdc8:	e0bff917 	ldw	r2,-28(fp)
  20bdcc:	10800017 	ldw	r2,0(r2)
  20bdd0:	e0fffa17 	ldw	r3,-24(fp)
  20bdd4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  20bdd8:	e0bff917 	ldw	r2,-28(fp)
  20bddc:	e0fffa17 	ldw	r3,-24(fp)
  20bde0:	10c00015 	stw	r3,0(r2)
  20bde4:	e0bff717 	ldw	r2,-36(fp)
  20bde8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  20bdec:	e0bffb17 	ldw	r2,-20(fp)
  20bdf0:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  20bdf4:	0005883a 	mov	r2,zero
  20bdf8:	00000306 	br	20be08 <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
  20bdfc:	00bffa84 	movi	r2,-22
  20be00:	00000106 	br	20be08 <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
  20be04:	00bfde84 	movi	r2,-134
  }
}
  20be08:	e037883a 	mov	sp,fp
  20be0c:	df000017 	ldw	fp,0(sp)
  20be10:	dec00104 	addi	sp,sp,4
  20be14:	f800283a 	ret

0020be18 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  20be18:	defffc04 	addi	sp,sp,-16
  20be1c:	df000315 	stw	fp,12(sp)
  20be20:	df000304 	addi	fp,sp,12
  20be24:	e13ffd15 	stw	r4,-12(fp)
  20be28:	e17ffe15 	stw	r5,-8(fp)
  20be2c:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  20be30:	e0fffe17 	ldw	r3,-8(fp)
  20be34:	e0bffd17 	ldw	r2,-12(fp)
  20be38:	18800c26 	beq	r3,r2,20be6c <alt_load_section+0x54>
  {
    while( to != end )
  20be3c:	00000806 	br	20be60 <alt_load_section+0x48>
    {
      *to++ = *from++;
  20be40:	e0bffe17 	ldw	r2,-8(fp)
  20be44:	10c00104 	addi	r3,r2,4
  20be48:	e0fffe15 	stw	r3,-8(fp)
  20be4c:	e0fffd17 	ldw	r3,-12(fp)
  20be50:	19000104 	addi	r4,r3,4
  20be54:	e13ffd15 	stw	r4,-12(fp)
  20be58:	18c00017 	ldw	r3,0(r3)
  20be5c:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  20be60:	e0fffe17 	ldw	r3,-8(fp)
  20be64:	e0bfff17 	ldw	r2,-4(fp)
  20be68:	18bff51e 	bne	r3,r2,20be40 <_gp+0xffff6250>
    {
      *to++ = *from++;
    }
  }
}
  20be6c:	e037883a 	mov	sp,fp
  20be70:	df000017 	ldw	fp,0(sp)
  20be74:	dec00104 	addi	sp,sp,4
  20be78:	f800283a 	ret

0020be7c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  20be7c:	defffe04 	addi	sp,sp,-8
  20be80:	dfc00115 	stw	ra,4(sp)
  20be84:	df000015 	stw	fp,0(sp)
  20be88:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  20be8c:	01000874 	movhi	r4,33
  20be90:	21370a04 	addi	r4,r4,-9176
  20be94:	01400874 	movhi	r5,33
  20be98:	29764f04 	addi	r5,r5,-9924
  20be9c:	01800874 	movhi	r6,33
  20bea0:	31b70a04 	addi	r6,r6,-9176
  20bea4:	020be180 	call	20be18 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  20bea8:	01000874 	movhi	r4,33
  20beac:	21200804 	addi	r4,r4,-32736
  20beb0:	01400874 	movhi	r5,33
  20beb4:	29600804 	addi	r5,r5,-32736
  20beb8:	01800874 	movhi	r6,33
  20bebc:	31a06f04 	addi	r6,r6,-32324
  20bec0:	020be180 	call	20be18 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  20bec4:	01000874 	movhi	r4,33
  20bec8:	21355d04 	addi	r4,r4,-10892
  20becc:	01400874 	movhi	r5,33
  20bed0:	29755d04 	addi	r5,r5,-10892
  20bed4:	01800874 	movhi	r6,33
  20bed8:	31b64f04 	addi	r6,r6,-9924
  20bedc:	020be180 	call	20be18 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  20bee0:	020c61c0 	call	20c61c <alt_dcache_flush_all>
  alt_icache_flush_all();
  20bee4:	020c80c0 	call	20c80c <alt_icache_flush_all>
}
  20bee8:	e037883a 	mov	sp,fp
  20beec:	dfc00117 	ldw	ra,4(sp)
  20bef0:	df000017 	ldw	fp,0(sp)
  20bef4:	dec00204 	addi	sp,sp,8
  20bef8:	f800283a 	ret

0020befc <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  20befc:	defffd04 	addi	sp,sp,-12
  20bf00:	dfc00215 	stw	ra,8(sp)
  20bf04:	df000115 	stw	fp,4(sp)
  20bf08:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  20bf0c:	0009883a 	mov	r4,zero
  20bf10:	020c1480 	call	20c148 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  20bf14:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  20bf18:	020c17c0 	call	20c17c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  20bf1c:	01000874 	movhi	r4,33
  20bf20:	21364204 	addi	r4,r4,-9976
  20bf24:	01400874 	movhi	r5,33
  20bf28:	29764204 	addi	r5,r5,-9976
  20bf2c:	01800874 	movhi	r6,33
  20bf30:	31b64204 	addi	r6,r6,-9976
  20bf34:	020cbd00 	call	20cbd0 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  20bf38:	020c7540 	call	20c754 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  20bf3c:	01000874 	movhi	r4,33
  20bf40:	2131ec04 	addi	r4,r4,-14416
  20bf44:	020d2000 	call	20d200 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  20bf48:	d120d017 	ldw	r4,-31936(gp)
  20bf4c:	d0e0d117 	ldw	r3,-31932(gp)
  20bf50:	d0a0d217 	ldw	r2,-31928(gp)
  20bf54:	180b883a 	mov	r5,r3
  20bf58:	100d883a 	mov	r6,r2
  20bf5c:	020afb00 	call	20afb0 <main>
  20bf60:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  20bf64:	01000044 	movi	r4,1
  20bf68:	020c54c0 	call	20c54c <close>
  exit (result);
  20bf6c:	e13fff17 	ldw	r4,-4(fp)
  20bf70:	020d2140 	call	20d214 <exit>

0020bf74 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  20bf74:	defffa04 	addi	sp,sp,-24
  20bf78:	df000515 	stw	fp,20(sp)
  20bf7c:	df000504 	addi	fp,sp,20
  20bf80:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  20bf84:	0005303a 	rdctl	r2,status
  20bf88:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20bf8c:	e0fffc17 	ldw	r3,-16(fp)
  20bf90:	00bfff84 	movi	r2,-2
  20bf94:	1884703a 	and	r2,r3,r2
  20bf98:	1001703a 	wrctl	status,r2
  
  return context;
  20bf9c:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  20bfa0:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  20bfa4:	e0bfff17 	ldw	r2,-4(fp)
  20bfa8:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  20bfac:	e0bffd17 	ldw	r2,-12(fp)
  20bfb0:	10800017 	ldw	r2,0(r2)
  20bfb4:	e0fffd17 	ldw	r3,-12(fp)
  20bfb8:	18c00117 	ldw	r3,4(r3)
  20bfbc:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  20bfc0:	e0bffd17 	ldw	r2,-12(fp)
  20bfc4:	10800117 	ldw	r2,4(r2)
  20bfc8:	e0fffd17 	ldw	r3,-12(fp)
  20bfcc:	18c00017 	ldw	r3,0(r3)
  20bfd0:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  20bfd4:	e0bffd17 	ldw	r2,-12(fp)
  20bfd8:	e0fffd17 	ldw	r3,-12(fp)
  20bfdc:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  20bfe0:	e0bffd17 	ldw	r2,-12(fp)
  20bfe4:	e0fffd17 	ldw	r3,-12(fp)
  20bfe8:	10c00015 	stw	r3,0(r2)
  20bfec:	e0bffb17 	ldw	r2,-20(fp)
  20bff0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  20bff4:	e0bffe17 	ldw	r2,-8(fp)
  20bff8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  20bffc:	e037883a 	mov	sp,fp
  20c000:	df000017 	ldw	fp,0(sp)
  20c004:	dec00104 	addi	sp,sp,4
  20c008:	f800283a 	ret

0020c00c <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  20c00c:	defffb04 	addi	sp,sp,-20
  20c010:	dfc00415 	stw	ra,16(sp)
  20c014:	df000315 	stw	fp,12(sp)
  20c018:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  20c01c:	d0a00317 	ldw	r2,-32756(gp)
  20c020:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  20c024:	d0a0d417 	ldw	r2,-31920(gp)
  20c028:	10800044 	addi	r2,r2,1
  20c02c:	d0a0d415 	stw	r2,-31920(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  20c030:	00002e06 	br	20c0ec <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  20c034:	e0bffd17 	ldw	r2,-12(fp)
  20c038:	10800017 	ldw	r2,0(r2)
  20c03c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  20c040:	e0bffd17 	ldw	r2,-12(fp)
  20c044:	10800403 	ldbu	r2,16(r2)
  20c048:	10803fcc 	andi	r2,r2,255
  20c04c:	10000426 	beq	r2,zero,20c060 <alt_tick+0x54>
  20c050:	d0a0d417 	ldw	r2,-31920(gp)
  20c054:	1000021e 	bne	r2,zero,20c060 <alt_tick+0x54>
    {
      alarm->rollover = 0;
  20c058:	e0bffd17 	ldw	r2,-12(fp)
  20c05c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  20c060:	e0bffd17 	ldw	r2,-12(fp)
  20c064:	10800217 	ldw	r2,8(r2)
  20c068:	d0e0d417 	ldw	r3,-31920(gp)
  20c06c:	18801d36 	bltu	r3,r2,20c0e4 <alt_tick+0xd8>
  20c070:	e0bffd17 	ldw	r2,-12(fp)
  20c074:	10800403 	ldbu	r2,16(r2)
  20c078:	10803fcc 	andi	r2,r2,255
  20c07c:	1000191e 	bne	r2,zero,20c0e4 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  20c080:	e0bffd17 	ldw	r2,-12(fp)
  20c084:	10800317 	ldw	r2,12(r2)
  20c088:	e0fffd17 	ldw	r3,-12(fp)
  20c08c:	18c00517 	ldw	r3,20(r3)
  20c090:	1809883a 	mov	r4,r3
  20c094:	103ee83a 	callr	r2
  20c098:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  20c09c:	e0bfff17 	ldw	r2,-4(fp)
  20c0a0:	1000031e 	bne	r2,zero,20c0b0 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  20c0a4:	e13ffd17 	ldw	r4,-12(fp)
  20c0a8:	020bf740 	call	20bf74 <alt_alarm_stop>
  20c0ac:	00000d06 	br	20c0e4 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  20c0b0:	e0bffd17 	ldw	r2,-12(fp)
  20c0b4:	10c00217 	ldw	r3,8(r2)
  20c0b8:	e0bfff17 	ldw	r2,-4(fp)
  20c0bc:	1887883a 	add	r3,r3,r2
  20c0c0:	e0bffd17 	ldw	r2,-12(fp)
  20c0c4:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  20c0c8:	e0bffd17 	ldw	r2,-12(fp)
  20c0cc:	10c00217 	ldw	r3,8(r2)
  20c0d0:	d0a0d417 	ldw	r2,-31920(gp)
  20c0d4:	1880032e 	bgeu	r3,r2,20c0e4 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  20c0d8:	e0bffd17 	ldw	r2,-12(fp)
  20c0dc:	00c00044 	movi	r3,1
  20c0e0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  20c0e4:	e0bffe17 	ldw	r2,-8(fp)
  20c0e8:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  20c0ec:	e0fffd17 	ldw	r3,-12(fp)
  20c0f0:	d0a00304 	addi	r2,gp,-32756
  20c0f4:	18bfcf1e 	bne	r3,r2,20c034 <_gp+0xffff6444>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  20c0f8:	0001883a 	nop
}
  20c0fc:	e037883a 	mov	sp,fp
  20c100:	dfc00117 	ldw	ra,4(sp)
  20c104:	df000017 	ldw	fp,0(sp)
  20c108:	dec00204 	addi	sp,sp,8
  20c10c:	f800283a 	ret

0020c110 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  20c110:	defffd04 	addi	sp,sp,-12
  20c114:	dfc00215 	stw	ra,8(sp)
  20c118:	df000115 	stw	fp,4(sp)
  20c11c:	df000104 	addi	fp,sp,4
  20c120:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  20c124:	e13fff17 	ldw	r4,-4(fp)
  20c128:	01400874 	movhi	r5,33
  20c12c:	29770304 	addi	r5,r5,-9204
  20c130:	020c6b40 	call	20c6b4 <alt_dev_llist_insert>
}
  20c134:	e037883a 	mov	sp,fp
  20c138:	dfc00117 	ldw	ra,4(sp)
  20c13c:	df000017 	ldw	fp,0(sp)
  20c140:	dec00204 	addi	sp,sp,8
  20c144:	f800283a 	ret

0020c148 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  20c148:	defffd04 	addi	sp,sp,-12
  20c14c:	dfc00215 	stw	ra,8(sp)
  20c150:	df000115 	stw	fp,4(sp)
  20c154:	df000104 	addi	fp,sp,4
  20c158:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
  20c15c:	020cf680 	call	20cf68 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  20c160:	00800044 	movi	r2,1
  20c164:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  20c168:	e037883a 	mov	sp,fp
  20c16c:	dfc00117 	ldw	ra,4(sp)
  20c170:	df000017 	ldw	fp,0(sp)
  20c174:	dec00204 	addi	sp,sp,8
  20c178:	f800283a 	ret

0020c17c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  20c17c:	defffe04 	addi	sp,sp,-8
  20c180:	dfc00115 	stw	ra,4(sp)
  20c184:	df000015 	stw	fp,0(sp)
  20c188:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
  20c18c:	01000874 	movhi	r4,33
  20c190:	21140804 	addi	r4,r4,20512
  20c194:	000b883a 	mov	r5,zero
  20c198:	01800044 	movi	r6,1
  20c19c:	01c0fa04 	movi	r7,1000
  20c1a0:	020c4740 	call	20c474 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
  20c1a4:	01000874 	movhi	r4,33
  20c1a8:	21364f04 	addi	r4,r4,-9924
  20c1ac:	020c1100 	call	20c110 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_2466, sysid_2466);
  20c1b0:	0001883a 	nop
}
  20c1b4:	e037883a 	mov	sp,fp
  20c1b8:	dfc00117 	ldw	ra,4(sp)
  20c1bc:	df000017 	ldw	fp,0(sp)
  20c1c0:	dec00204 	addi	sp,sp,8
  20c1c4:	f800283a 	ret

0020c1c8 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  20c1c8:	defffa04 	addi	sp,sp,-24
  20c1cc:	dfc00515 	stw	ra,20(sp)
  20c1d0:	df000415 	stw	fp,16(sp)
  20c1d4:	df000404 	addi	fp,sp,16
  20c1d8:	e13ffd15 	stw	r4,-12(fp)
  20c1dc:	e17ffe15 	stw	r5,-8(fp)
  20c1e0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  20c1e4:	e0bffd17 	ldw	r2,-12(fp)
  20c1e8:	10800017 	ldw	r2,0(r2)
  20c1ec:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  20c1f0:	e0bffc17 	ldw	r2,-16(fp)
  20c1f4:	10c00a04 	addi	r3,r2,40
  20c1f8:	e0bffd17 	ldw	r2,-12(fp)
  20c1fc:	10800217 	ldw	r2,8(r2)
  20c200:	1809883a 	mov	r4,r3
  20c204:	e17ffe17 	ldw	r5,-8(fp)
  20c208:	e1bfff17 	ldw	r6,-4(fp)
  20c20c:	100f883a 	mov	r7,r2
  20c210:	020c2880 	call	20c288 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  20c214:	e037883a 	mov	sp,fp
  20c218:	dfc00117 	ldw	ra,4(sp)
  20c21c:	df000017 	ldw	fp,0(sp)
  20c220:	dec00204 	addi	sp,sp,8
  20c224:	f800283a 	ret

0020c228 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  20c228:	defffa04 	addi	sp,sp,-24
  20c22c:	dfc00515 	stw	ra,20(sp)
  20c230:	df000415 	stw	fp,16(sp)
  20c234:	df000404 	addi	fp,sp,16
  20c238:	e13ffd15 	stw	r4,-12(fp)
  20c23c:	e17ffe15 	stw	r5,-8(fp)
  20c240:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  20c244:	e0bffd17 	ldw	r2,-12(fp)
  20c248:	10800017 	ldw	r2,0(r2)
  20c24c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  20c250:	e0bffc17 	ldw	r2,-16(fp)
  20c254:	10c00a04 	addi	r3,r2,40
  20c258:	e0bffd17 	ldw	r2,-12(fp)
  20c25c:	10800217 	ldw	r2,8(r2)
  20c260:	1809883a 	mov	r4,r3
  20c264:	e17ffe17 	ldw	r5,-8(fp)
  20c268:	e1bfff17 	ldw	r6,-4(fp)
  20c26c:	100f883a 	mov	r7,r2
  20c270:	020c36c0 	call	20c36c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  20c274:	e037883a 	mov	sp,fp
  20c278:	dfc00117 	ldw	ra,4(sp)
  20c27c:	df000017 	ldw	fp,0(sp)
  20c280:	dec00204 	addi	sp,sp,8
  20c284:	f800283a 	ret

0020c288 <altera_avalon_jtag_uart_read>:
 */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
  20c288:	defff704 	addi	sp,sp,-36
  20c28c:	df000815 	stw	fp,32(sp)
  20c290:	df000804 	addi	fp,sp,32
  20c294:	e13ffc15 	stw	r4,-16(fp)
  20c298:	e17ffd15 	stw	r5,-12(fp)
  20c29c:	e1bffe15 	stw	r6,-8(fp)
  20c2a0:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
  20c2a4:	e0bffc17 	ldw	r2,-16(fp)
  20c2a8:	10800017 	ldw	r2,0(r2)
  20c2ac:	e0bff915 	stw	r2,-28(fp)

  char * ptr = buffer;
  20c2b0:	e0bffd17 	ldw	r2,-12(fp)
  20c2b4:	e0bff815 	stw	r2,-32(fp)
  char * end = buffer + space;
  20c2b8:	e0bffe17 	ldw	r2,-8(fp)
  20c2bc:	e0fffd17 	ldw	r3,-12(fp)
  20c2c0:	1885883a 	add	r2,r3,r2
  20c2c4:	e0bffa15 	stw	r2,-24(fp)

  while (ptr < end)
  20c2c8:	00001406 	br	20c31c <altera_avalon_jtag_uart_read+0x94>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  20c2cc:	e0bff917 	ldw	r2,-28(fp)
  20c2d0:	10800037 	ldwio	r2,0(r2)
  20c2d4:	e0bffb15 	stw	r2,-20(fp)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
  20c2d8:	e0bffb17 	ldw	r2,-20(fp)
  20c2dc:	10a0000c 	andi	r2,r2,32768
  20c2e0:	10000626 	beq	r2,zero,20c2fc <altera_avalon_jtag_uart_read+0x74>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  20c2e4:	e0bff817 	ldw	r2,-32(fp)
  20c2e8:	10c00044 	addi	r3,r2,1
  20c2ec:	e0fff815 	stw	r3,-32(fp)
  20c2f0:	e0fffb17 	ldw	r3,-20(fp)
  20c2f4:	10c00005 	stb	r3,0(r2)
  20c2f8:	00000806 	br	20c31c <altera_avalon_jtag_uart_read+0x94>
    else if (ptr != buffer)
  20c2fc:	e0fff817 	ldw	r3,-32(fp)
  20c300:	e0bffd17 	ldw	r2,-12(fp)
  20c304:	18800126 	beq	r3,r2,20c30c <altera_avalon_jtag_uart_read+0x84>
      break;
  20c308:	00000706 	br	20c328 <altera_avalon_jtag_uart_read+0xa0>
    else if(flags & O_NONBLOCK)
  20c30c:	e0bfff17 	ldw	r2,-4(fp)
  20c310:	1090000c 	andi	r2,r2,16384
  20c314:	10000126 	beq	r2,zero,20c31c <altera_avalon_jtag_uart_read+0x94>
      break;   
  20c318:	00000306 	br	20c328 <altera_avalon_jtag_uart_read+0xa0>
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
  20c31c:	e0fff817 	ldw	r3,-32(fp)
  20c320:	e0bffa17 	ldw	r2,-24(fp)
  20c324:	18bfe936 	bltu	r3,r2,20c2cc <_gp+0xffff66dc>
    else if(flags & O_NONBLOCK)
      break;   
    
  }

  if (ptr != buffer)
  20c328:	e0fff817 	ldw	r3,-32(fp)
  20c32c:	e0bffd17 	ldw	r2,-12(fp)
  20c330:	18800426 	beq	r3,r2,20c344 <altera_avalon_jtag_uart_read+0xbc>
    return ptr - buffer;
  20c334:	e0fff817 	ldw	r3,-32(fp)
  20c338:	e0bffd17 	ldw	r2,-12(fp)
  20c33c:	1885c83a 	sub	r2,r3,r2
  20c340:	00000606 	br	20c35c <altera_avalon_jtag_uart_read+0xd4>
  else if (flags & O_NONBLOCK)
  20c344:	e0bfff17 	ldw	r2,-4(fp)
  20c348:	1090000c 	andi	r2,r2,16384
  20c34c:	10000226 	beq	r2,zero,20c358 <altera_avalon_jtag_uart_read+0xd0>
    return -EWOULDBLOCK;
  20c350:	00bffd44 	movi	r2,-11
  20c354:	00000106 	br	20c35c <altera_avalon_jtag_uart_read+0xd4>
  else
    return -EIO;
  20c358:	00bffec4 	movi	r2,-5
}
  20c35c:	e037883a 	mov	sp,fp
  20c360:	df000017 	ldw	fp,0(sp)
  20c364:	dec00104 	addi	sp,sp,4
  20c368:	f800283a 	ret

0020c36c <altera_avalon_jtag_uart_write>:
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  20c36c:	defff904 	addi	sp,sp,-28
  20c370:	df000615 	stw	fp,24(sp)
  20c374:	df000604 	addi	fp,sp,24
  20c378:	e13ffc15 	stw	r4,-16(fp)
  20c37c:	e17ffd15 	stw	r5,-12(fp)
  20c380:	e1bffe15 	stw	r6,-8(fp)
  20c384:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
  20c388:	e0bffc17 	ldw	r2,-16(fp)
  20c38c:	10800017 	ldw	r2,0(r2)
  20c390:	e0bffa15 	stw	r2,-24(fp)

  const char * end = ptr + count;
  20c394:	e0bffe17 	ldw	r2,-8(fp)
  20c398:	e0fffd17 	ldw	r3,-12(fp)
  20c39c:	1885883a 	add	r2,r3,r2
  20c3a0:	e0bffb15 	stw	r2,-20(fp)

  while (ptr < end)
  20c3a4:	00000e06 	br	20c3e0 <altera_avalon_jtag_uart_write+0x74>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  20c3a8:	e0bffa17 	ldw	r2,-24(fp)
  20c3ac:	10800104 	addi	r2,r2,4
  20c3b0:	10800037 	ldwio	r2,0(r2)
  20c3b4:	10bfffec 	andhi	r2,r2,65535
  20c3b8:	10000926 	beq	r2,zero,20c3e0 <altera_avalon_jtag_uart_write+0x74>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
  20c3bc:	e0fffa17 	ldw	r3,-24(fp)
  20c3c0:	e0bffd17 	ldw	r2,-12(fp)
  20c3c4:	11000044 	addi	r4,r2,1
  20c3c8:	e13ffd15 	stw	r4,-12(fp)
  20c3cc:	10800003 	ldbu	r2,0(r2)
  20c3d0:	10803fcc 	andi	r2,r2,255
  20c3d4:	1080201c 	xori	r2,r2,128
  20c3d8:	10bfe004 	addi	r2,r2,-128
  20c3dc:	18800035 	stwio	r2,0(r3)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
  20c3e0:	e0fffd17 	ldw	r3,-12(fp)
  20c3e4:	e0bffb17 	ldw	r2,-20(fp)
  20c3e8:	18bfef36 	bltu	r3,r2,20c3a8 <_gp+0xffff67b8>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
  20c3ec:	e0bffe17 	ldw	r2,-8(fp)
}
  20c3f0:	e037883a 	mov	sp,fp
  20c3f4:	df000017 	ldw	fp,0(sp)
  20c3f8:	dec00104 	addi	sp,sp,4
  20c3fc:	f800283a 	ret

0020c400 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
  20c400:	defffa04 	addi	sp,sp,-24
  20c404:	dfc00515 	stw	ra,20(sp)
  20c408:	df000415 	stw	fp,16(sp)
  20c40c:	df000404 	addi	fp,sp,16
  20c410:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
  20c414:	0007883a 	mov	r3,zero
  20c418:	e0bfff17 	ldw	r2,-4(fp)
  20c41c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
  20c420:	e0bfff17 	ldw	r2,-4(fp)
  20c424:	10800104 	addi	r2,r2,4
  20c428:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  20c42c:	0005303a 	rdctl	r2,status
  20c430:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20c434:	e0fffd17 	ldw	r3,-12(fp)
  20c438:	00bfff84 	movi	r2,-2
  20c43c:	1884703a 	and	r2,r3,r2
  20c440:	1001703a 	wrctl	status,r2
  
  return context;
  20c444:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  20c448:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
  20c44c:	020c00c0 	call	20c00c <alt_tick>
  20c450:	e0bffc17 	ldw	r2,-16(fp)
  20c454:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  20c458:	e0bffe17 	ldw	r2,-8(fp)
  20c45c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
  20c460:	e037883a 	mov	sp,fp
  20c464:	dfc00117 	ldw	ra,4(sp)
  20c468:	df000017 	ldw	fp,0(sp)
  20c46c:	dec00204 	addi	sp,sp,8
  20c470:	f800283a 	ret

0020c474 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
  20c474:	defff804 	addi	sp,sp,-32
  20c478:	dfc00715 	stw	ra,28(sp)
  20c47c:	df000615 	stw	fp,24(sp)
  20c480:	df000604 	addi	fp,sp,24
  20c484:	e13ffc15 	stw	r4,-16(fp)
  20c488:	e17ffd15 	stw	r5,-12(fp)
  20c48c:	e1bffe15 	stw	r6,-8(fp)
  20c490:	e1ffff15 	stw	r7,-4(fp)
  20c494:	e0bfff17 	ldw	r2,-4(fp)
  20c498:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
  20c49c:	00800874 	movhi	r2,33
  20c4a0:	10b7cf04 	addi	r2,r2,-8388
  20c4a4:	10800017 	ldw	r2,0(r2)
  20c4a8:	1000041e 	bne	r2,zero,20c4bc <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
  20c4ac:	00800874 	movhi	r2,33
  20c4b0:	10b7cf04 	addi	r2,r2,-8388
  20c4b4:	e0fffb17 	ldw	r3,-20(fp)
  20c4b8:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
  20c4bc:	e0bffc17 	ldw	r2,-16(fp)
  20c4c0:	10800104 	addi	r2,r2,4
  20c4c4:	00c001c4 	movi	r3,7
  20c4c8:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
  20c4cc:	d8000015 	stw	zero,0(sp)
  20c4d0:	e13ffd17 	ldw	r4,-12(fp)
  20c4d4:	e17ffe17 	ldw	r5,-8(fp)
  20c4d8:	01800874 	movhi	r6,33
  20c4dc:	31b10004 	addi	r6,r6,-15360
  20c4e0:	e1fffc17 	ldw	r7,-16(fp)
  20c4e4:	020c8280 	call	20c828 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
  20c4e8:	e037883a 	mov	sp,fp
  20c4ec:	dfc00117 	ldw	ra,4(sp)
  20c4f0:	df000017 	ldw	fp,0(sp)
  20c4f4:	dec00204 	addi	sp,sp,8
  20c4f8:	f800283a 	ret

0020c4fc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  20c4fc:	defffe04 	addi	sp,sp,-8
  20c500:	dfc00115 	stw	ra,4(sp)
  20c504:	df000015 	stw	fp,0(sp)
  20c508:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  20c50c:	00800874 	movhi	r2,33
  20c510:	10b70604 	addi	r2,r2,-9192
  20c514:	10800017 	ldw	r2,0(r2)
  20c518:	10000526 	beq	r2,zero,20c530 <alt_get_errno+0x34>
  20c51c:	00800874 	movhi	r2,33
  20c520:	10b70604 	addi	r2,r2,-9192
  20c524:	10800017 	ldw	r2,0(r2)
  20c528:	103ee83a 	callr	r2
  20c52c:	00000206 	br	20c538 <alt_get_errno+0x3c>
  20c530:	00800874 	movhi	r2,33
  20c534:	10b7d204 	addi	r2,r2,-8376
}
  20c538:	e037883a 	mov	sp,fp
  20c53c:	dfc00117 	ldw	ra,4(sp)
  20c540:	df000017 	ldw	fp,0(sp)
  20c544:	dec00204 	addi	sp,sp,8
  20c548:	f800283a 	ret

0020c54c <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  20c54c:	defffb04 	addi	sp,sp,-20
  20c550:	dfc00415 	stw	ra,16(sp)
  20c554:	df000315 	stw	fp,12(sp)
  20c558:	df000304 	addi	fp,sp,12
  20c55c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  20c560:	e0bfff17 	ldw	r2,-4(fp)
  20c564:	10000816 	blt	r2,zero,20c588 <close+0x3c>
  20c568:	e13fff17 	ldw	r4,-4(fp)
  20c56c:	01400304 	movi	r5,12
  20c570:	020b50c0 	call	20b50c <__mulsi3>
  20c574:	1007883a 	mov	r3,r2
  20c578:	00800874 	movhi	r2,33
  20c57c:	10b66404 	addi	r2,r2,-9840
  20c580:	1885883a 	add	r2,r3,r2
  20c584:	00000106 	br	20c58c <close+0x40>
  20c588:	0005883a 	mov	r2,zero
  20c58c:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  20c590:	e0bffd17 	ldw	r2,-12(fp)
  20c594:	10001826 	beq	r2,zero,20c5f8 <close+0xac>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  20c598:	e0bffd17 	ldw	r2,-12(fp)
  20c59c:	10800017 	ldw	r2,0(r2)
  20c5a0:	10800417 	ldw	r2,16(r2)
  20c5a4:	10000626 	beq	r2,zero,20c5c0 <close+0x74>
  20c5a8:	e0bffd17 	ldw	r2,-12(fp)
  20c5ac:	10800017 	ldw	r2,0(r2)
  20c5b0:	10800417 	ldw	r2,16(r2)
  20c5b4:	e13ffd17 	ldw	r4,-12(fp)
  20c5b8:	103ee83a 	callr	r2
  20c5bc:	00000106 	br	20c5c4 <close+0x78>
  20c5c0:	0005883a 	mov	r2,zero
  20c5c4:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  20c5c8:	e13fff17 	ldw	r4,-4(fp)
  20c5cc:	020cee80 	call	20cee8 <alt_release_fd>
    if (rval < 0)
  20c5d0:	e0bffe17 	ldw	r2,-8(fp)
  20c5d4:	1000060e 	bge	r2,zero,20c5f0 <close+0xa4>
    {
      ALT_ERRNO = -rval;
  20c5d8:	020c4fc0 	call	20c4fc <alt_get_errno>
  20c5dc:	e0fffe17 	ldw	r3,-8(fp)
  20c5e0:	00c7c83a 	sub	r3,zero,r3
  20c5e4:	10c00015 	stw	r3,0(r2)
      return -1;
  20c5e8:	00bfffc4 	movi	r2,-1
  20c5ec:	00000606 	br	20c608 <close+0xbc>
    }
    return 0;
  20c5f0:	0005883a 	mov	r2,zero
  20c5f4:	00000406 	br	20c608 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  20c5f8:	020c4fc0 	call	20c4fc <alt_get_errno>
  20c5fc:	00c01444 	movi	r3,81
  20c600:	10c00015 	stw	r3,0(r2)
    return -1;
  20c604:	00bfffc4 	movi	r2,-1
  }
}
  20c608:	e037883a 	mov	sp,fp
  20c60c:	dfc00117 	ldw	ra,4(sp)
  20c610:	df000017 	ldw	fp,0(sp)
  20c614:	dec00204 	addi	sp,sp,8
  20c618:	f800283a 	ret

0020c61c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  20c61c:	deffff04 	addi	sp,sp,-4
  20c620:	df000015 	stw	fp,0(sp)
  20c624:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  20c628:	e037883a 	mov	sp,fp
  20c62c:	df000017 	ldw	fp,0(sp)
  20c630:	dec00104 	addi	sp,sp,4
  20c634:	f800283a 	ret

0020c638 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  20c638:	defffc04 	addi	sp,sp,-16
  20c63c:	df000315 	stw	fp,12(sp)
  20c640:	df000304 	addi	fp,sp,12
  20c644:	e13ffd15 	stw	r4,-12(fp)
  20c648:	e17ffe15 	stw	r5,-8(fp)
  20c64c:	e1bfff15 	stw	r6,-4(fp)
  return len;
  20c650:	e0bfff17 	ldw	r2,-4(fp)
}
  20c654:	e037883a 	mov	sp,fp
  20c658:	df000017 	ldw	fp,0(sp)
  20c65c:	dec00104 	addi	sp,sp,4
  20c660:	f800283a 	ret

0020c664 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  20c664:	defffe04 	addi	sp,sp,-8
  20c668:	dfc00115 	stw	ra,4(sp)
  20c66c:	df000015 	stw	fp,0(sp)
  20c670:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  20c674:	00800874 	movhi	r2,33
  20c678:	10b70604 	addi	r2,r2,-9192
  20c67c:	10800017 	ldw	r2,0(r2)
  20c680:	10000526 	beq	r2,zero,20c698 <alt_get_errno+0x34>
  20c684:	00800874 	movhi	r2,33
  20c688:	10b70604 	addi	r2,r2,-9192
  20c68c:	10800017 	ldw	r2,0(r2)
  20c690:	103ee83a 	callr	r2
  20c694:	00000206 	br	20c6a0 <alt_get_errno+0x3c>
  20c698:	00800874 	movhi	r2,33
  20c69c:	10b7d204 	addi	r2,r2,-8376
}
  20c6a0:	e037883a 	mov	sp,fp
  20c6a4:	dfc00117 	ldw	ra,4(sp)
  20c6a8:	df000017 	ldw	fp,0(sp)
  20c6ac:	dec00204 	addi	sp,sp,8
  20c6b0:	f800283a 	ret

0020c6b4 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  20c6b4:	defffa04 	addi	sp,sp,-24
  20c6b8:	dfc00515 	stw	ra,20(sp)
  20c6bc:	df000415 	stw	fp,16(sp)
  20c6c0:	df000404 	addi	fp,sp,16
  20c6c4:	e13ffe15 	stw	r4,-8(fp)
  20c6c8:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  20c6cc:	e0bffe17 	ldw	r2,-8(fp)
  20c6d0:	10000326 	beq	r2,zero,20c6e0 <alt_dev_llist_insert+0x2c>
  20c6d4:	e0bffe17 	ldw	r2,-8(fp)
  20c6d8:	10800217 	ldw	r2,8(r2)
  20c6dc:	1000051e 	bne	r2,zero,20c6f4 <alt_dev_llist_insert+0x40>
  {
    ALT_ERRNO = EINVAL;
  20c6e0:	020c6640 	call	20c664 <alt_get_errno>
  20c6e4:	00c00584 	movi	r3,22
  20c6e8:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  20c6ec:	00bffa84 	movi	r2,-22
  20c6f0:	00001306 	br	20c740 <alt_dev_llist_insert+0x8c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  20c6f4:	e0bffe17 	ldw	r2,-8(fp)
  20c6f8:	e0ffff17 	ldw	r3,-4(fp)
  20c6fc:	e0fffc15 	stw	r3,-16(fp)
  20c700:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  20c704:	e0bffd17 	ldw	r2,-12(fp)
  20c708:	e0fffc17 	ldw	r3,-16(fp)
  20c70c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  20c710:	e0bffc17 	ldw	r2,-16(fp)
  20c714:	10c00017 	ldw	r3,0(r2)
  20c718:	e0bffd17 	ldw	r2,-12(fp)
  20c71c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  20c720:	e0bffc17 	ldw	r2,-16(fp)
  20c724:	10800017 	ldw	r2,0(r2)
  20c728:	e0fffd17 	ldw	r3,-12(fp)
  20c72c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  20c730:	e0bffc17 	ldw	r2,-16(fp)
  20c734:	e0fffd17 	ldw	r3,-12(fp)
  20c738:	10c00015 	stw	r3,0(r2)

  return 0;  
  20c73c:	0005883a 	mov	r2,zero
}
  20c740:	e037883a 	mov	sp,fp
  20c744:	dfc00117 	ldw	ra,4(sp)
  20c748:	df000017 	ldw	fp,0(sp)
  20c74c:	dec00204 	addi	sp,sp,8
  20c750:	f800283a 	ret

0020c754 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  20c754:	defffd04 	addi	sp,sp,-12
  20c758:	dfc00215 	stw	ra,8(sp)
  20c75c:	df000115 	stw	fp,4(sp)
  20c760:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  20c764:	00800874 	movhi	r2,33
  20c768:	10b55c04 	addi	r2,r2,-10896
  20c76c:	e0bfff15 	stw	r2,-4(fp)
  20c770:	00000606 	br	20c78c <_do_ctors+0x38>
        (*ctor) (); 
  20c774:	e0bfff17 	ldw	r2,-4(fp)
  20c778:	10800017 	ldw	r2,0(r2)
  20c77c:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  20c780:	e0bfff17 	ldw	r2,-4(fp)
  20c784:	10bfff04 	addi	r2,r2,-4
  20c788:	e0bfff15 	stw	r2,-4(fp)
  20c78c:	e0ffff17 	ldw	r3,-4(fp)
  20c790:	00800874 	movhi	r2,33
  20c794:	10b55d04 	addi	r2,r2,-10892
  20c798:	18bff62e 	bgeu	r3,r2,20c774 <_gp+0xffff6b84>
        (*ctor) (); 
}
  20c79c:	e037883a 	mov	sp,fp
  20c7a0:	dfc00117 	ldw	ra,4(sp)
  20c7a4:	df000017 	ldw	fp,0(sp)
  20c7a8:	dec00204 	addi	sp,sp,8
  20c7ac:	f800283a 	ret

0020c7b0 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  20c7b0:	defffd04 	addi	sp,sp,-12
  20c7b4:	dfc00215 	stw	ra,8(sp)
  20c7b8:	df000115 	stw	fp,4(sp)
  20c7bc:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  20c7c0:	00800874 	movhi	r2,33
  20c7c4:	10b55c04 	addi	r2,r2,-10896
  20c7c8:	e0bfff15 	stw	r2,-4(fp)
  20c7cc:	00000606 	br	20c7e8 <_do_dtors+0x38>
        (*dtor) (); 
  20c7d0:	e0bfff17 	ldw	r2,-4(fp)
  20c7d4:	10800017 	ldw	r2,0(r2)
  20c7d8:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  20c7dc:	e0bfff17 	ldw	r2,-4(fp)
  20c7e0:	10bfff04 	addi	r2,r2,-4
  20c7e4:	e0bfff15 	stw	r2,-4(fp)
  20c7e8:	e0ffff17 	ldw	r3,-4(fp)
  20c7ec:	00800874 	movhi	r2,33
  20c7f0:	10b55d04 	addi	r2,r2,-10892
  20c7f4:	18bff62e 	bgeu	r3,r2,20c7d0 <_gp+0xffff6be0>
        (*dtor) (); 
}
  20c7f8:	e037883a 	mov	sp,fp
  20c7fc:	dfc00117 	ldw	ra,4(sp)
  20c800:	df000017 	ldw	fp,0(sp)
  20c804:	dec00204 	addi	sp,sp,8
  20c808:	f800283a 	ret

0020c80c <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  20c80c:	deffff04 	addi	sp,sp,-4
  20c810:	df000015 	stw	fp,0(sp)
  20c814:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
  20c818:	e037883a 	mov	sp,fp
  20c81c:	df000017 	ldw	fp,0(sp)
  20c820:	dec00104 	addi	sp,sp,4
  20c824:	f800283a 	ret

0020c828 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  20c828:	defff904 	addi	sp,sp,-28
  20c82c:	dfc00615 	stw	ra,24(sp)
  20c830:	df000515 	stw	fp,20(sp)
  20c834:	df000504 	addi	fp,sp,20
  20c838:	e13ffc15 	stw	r4,-16(fp)
  20c83c:	e17ffd15 	stw	r5,-12(fp)
  20c840:	e1bffe15 	stw	r6,-8(fp)
  20c844:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  20c848:	e0800217 	ldw	r2,8(fp)
  20c84c:	d8800015 	stw	r2,0(sp)
  20c850:	e13ffc17 	ldw	r4,-16(fp)
  20c854:	e17ffd17 	ldw	r5,-12(fp)
  20c858:	e1bffe17 	ldw	r6,-8(fp)
  20c85c:	e1ffff17 	ldw	r7,-4(fp)
  20c860:	020ca000 	call	20ca00 <alt_iic_isr_register>
}  
  20c864:	e037883a 	mov	sp,fp
  20c868:	dfc00117 	ldw	ra,4(sp)
  20c86c:	df000017 	ldw	fp,0(sp)
  20c870:	dec00204 	addi	sp,sp,8
  20c874:	f800283a 	ret

0020c878 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  20c878:	defff904 	addi	sp,sp,-28
  20c87c:	df000615 	stw	fp,24(sp)
  20c880:	df000604 	addi	fp,sp,24
  20c884:	e13ffe15 	stw	r4,-8(fp)
  20c888:	e17fff15 	stw	r5,-4(fp)
  20c88c:	e0bfff17 	ldw	r2,-4(fp)
  20c890:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  20c894:	0005303a 	rdctl	r2,status
  20c898:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20c89c:	e0fffb17 	ldw	r3,-20(fp)
  20c8a0:	00bfff84 	movi	r2,-2
  20c8a4:	1884703a 	and	r2,r3,r2
  20c8a8:	1001703a 	wrctl	status,r2
  
  return context;
  20c8ac:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  20c8b0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  20c8b4:	e0bffa17 	ldw	r2,-24(fp)
  20c8b8:	00c00044 	movi	r3,1
  20c8bc:	1884983a 	sll	r2,r3,r2
  20c8c0:	1007883a 	mov	r3,r2
  20c8c4:	00800874 	movhi	r2,33
  20c8c8:	10b7d104 	addi	r2,r2,-8380
  20c8cc:	10800017 	ldw	r2,0(r2)
  20c8d0:	1886b03a 	or	r3,r3,r2
  20c8d4:	00800874 	movhi	r2,33
  20c8d8:	10b7d104 	addi	r2,r2,-8380
  20c8dc:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  20c8e0:	00800874 	movhi	r2,33
  20c8e4:	10b7d104 	addi	r2,r2,-8380
  20c8e8:	10800017 	ldw	r2,0(r2)
  20c8ec:	100170fa 	wrctl	ienable,r2
  20c8f0:	e0bffc17 	ldw	r2,-16(fp)
  20c8f4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  20c8f8:	e0bffd17 	ldw	r2,-12(fp)
  20c8fc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  20c900:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
  20c904:	e037883a 	mov	sp,fp
  20c908:	df000017 	ldw	fp,0(sp)
  20c90c:	dec00104 	addi	sp,sp,4
  20c910:	f800283a 	ret

0020c914 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  20c914:	defff904 	addi	sp,sp,-28
  20c918:	df000615 	stw	fp,24(sp)
  20c91c:	df000604 	addi	fp,sp,24
  20c920:	e13ffe15 	stw	r4,-8(fp)
  20c924:	e17fff15 	stw	r5,-4(fp)
  20c928:	e0bfff17 	ldw	r2,-4(fp)
  20c92c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  20c930:	0005303a 	rdctl	r2,status
  20c934:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20c938:	e0fffb17 	ldw	r3,-20(fp)
  20c93c:	00bfff84 	movi	r2,-2
  20c940:	1884703a 	and	r2,r3,r2
  20c944:	1001703a 	wrctl	status,r2
  
  return context;
  20c948:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  20c94c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  20c950:	e0bffa17 	ldw	r2,-24(fp)
  20c954:	00c00044 	movi	r3,1
  20c958:	1884983a 	sll	r2,r3,r2
  20c95c:	0084303a 	nor	r2,zero,r2
  20c960:	1007883a 	mov	r3,r2
  20c964:	00800874 	movhi	r2,33
  20c968:	10b7d104 	addi	r2,r2,-8380
  20c96c:	10800017 	ldw	r2,0(r2)
  20c970:	1886703a 	and	r3,r3,r2
  20c974:	00800874 	movhi	r2,33
  20c978:	10b7d104 	addi	r2,r2,-8380
  20c97c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  20c980:	00800874 	movhi	r2,33
  20c984:	10b7d104 	addi	r2,r2,-8380
  20c988:	10800017 	ldw	r2,0(r2)
  20c98c:	100170fa 	wrctl	ienable,r2
  20c990:	e0bffc17 	ldw	r2,-16(fp)
  20c994:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  20c998:	e0bffd17 	ldw	r2,-12(fp)
  20c99c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  20c9a0:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
  20c9a4:	e037883a 	mov	sp,fp
  20c9a8:	df000017 	ldw	fp,0(sp)
  20c9ac:	dec00104 	addi	sp,sp,4
  20c9b0:	f800283a 	ret

0020c9b4 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  20c9b4:	defffc04 	addi	sp,sp,-16
  20c9b8:	df000315 	stw	fp,12(sp)
  20c9bc:	df000304 	addi	fp,sp,12
  20c9c0:	e13ffe15 	stw	r4,-8(fp)
  20c9c4:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  20c9c8:	000530fa 	rdctl	r2,ienable
  20c9cc:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  20c9d0:	e0bfff17 	ldw	r2,-4(fp)
  20c9d4:	00c00044 	movi	r3,1
  20c9d8:	1884983a 	sll	r2,r3,r2
  20c9dc:	1007883a 	mov	r3,r2
  20c9e0:	e0bffd17 	ldw	r2,-12(fp)
  20c9e4:	1884703a 	and	r2,r3,r2
  20c9e8:	1004c03a 	cmpne	r2,r2,zero
  20c9ec:	10803fcc 	andi	r2,r2,255
}
  20c9f0:	e037883a 	mov	sp,fp
  20c9f4:	df000017 	ldw	fp,0(sp)
  20c9f8:	dec00104 	addi	sp,sp,4
  20c9fc:	f800283a 	ret

0020ca00 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  20ca00:	defff504 	addi	sp,sp,-44
  20ca04:	dfc00a15 	stw	ra,40(sp)
  20ca08:	df000915 	stw	fp,36(sp)
  20ca0c:	df000904 	addi	fp,sp,36
  20ca10:	e13ffc15 	stw	r4,-16(fp)
  20ca14:	e17ffd15 	stw	r5,-12(fp)
  20ca18:	e1bffe15 	stw	r6,-8(fp)
  20ca1c:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  20ca20:	00bffa84 	movi	r2,-22
  20ca24:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  20ca28:	e0bffd17 	ldw	r2,-12(fp)
  20ca2c:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  20ca30:	e0bff817 	ldw	r2,-32(fp)
  20ca34:	10800808 	cmpgei	r2,r2,32
  20ca38:	1000271e 	bne	r2,zero,20cad8 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  20ca3c:	0005303a 	rdctl	r2,status
  20ca40:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  20ca44:	e0fffa17 	ldw	r3,-24(fp)
  20ca48:	00bfff84 	movi	r2,-2
  20ca4c:	1884703a 	and	r2,r3,r2
  20ca50:	1001703a 	wrctl	status,r2
  
  return context;
  20ca54:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  20ca58:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
  20ca5c:	00c00874 	movhi	r3,33
  20ca60:	18f7d904 	addi	r3,r3,-8348
  20ca64:	e0bff817 	ldw	r2,-32(fp)
  20ca68:	100490fa 	slli	r2,r2,3
  20ca6c:	1885883a 	add	r2,r3,r2
  20ca70:	e0fffe17 	ldw	r3,-8(fp)
  20ca74:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  20ca78:	00c00874 	movhi	r3,33
  20ca7c:	18f7d904 	addi	r3,r3,-8348
  20ca80:	e0bff817 	ldw	r2,-32(fp)
  20ca84:	100490fa 	slli	r2,r2,3
  20ca88:	1885883a 	add	r2,r3,r2
  20ca8c:	10800104 	addi	r2,r2,4
  20ca90:	e0ffff17 	ldw	r3,-4(fp)
  20ca94:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  20ca98:	e0bffe17 	ldw	r2,-8(fp)
  20ca9c:	10000526 	beq	r2,zero,20cab4 <alt_iic_isr_register+0xb4>
  20caa0:	e0bff817 	ldw	r2,-32(fp)
  20caa4:	e13ffc17 	ldw	r4,-16(fp)
  20caa8:	100b883a 	mov	r5,r2
  20caac:	020c8780 	call	20c878 <alt_ic_irq_enable>
  20cab0:	00000406 	br	20cac4 <alt_iic_isr_register+0xc4>
  20cab4:	e0bff817 	ldw	r2,-32(fp)
  20cab8:	e13ffc17 	ldw	r4,-16(fp)
  20cabc:	100b883a 	mov	r5,r2
  20cac0:	020c9140 	call	20c914 <alt_ic_irq_disable>
  20cac4:	e0bff715 	stw	r2,-36(fp)
  20cac8:	e0bff917 	ldw	r2,-28(fp)
  20cacc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  20cad0:	e0bffb17 	ldw	r2,-20(fp)
  20cad4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  20cad8:	e0bff717 	ldw	r2,-36(fp)
}
  20cadc:	e037883a 	mov	sp,fp
  20cae0:	dfc00117 	ldw	ra,4(sp)
  20cae4:	df000017 	ldw	fp,0(sp)
  20cae8:	dec00204 	addi	sp,sp,8
  20caec:	f800283a 	ret

0020caf0 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  20caf0:	defff804 	addi	sp,sp,-32
  20caf4:	dfc00715 	stw	ra,28(sp)
  20caf8:	df000615 	stw	fp,24(sp)
  20cafc:	dc000515 	stw	r16,20(sp)
  20cb00:	df000604 	addi	fp,sp,24
  20cb04:	e13ffb15 	stw	r4,-20(fp)
  20cb08:	e17ffc15 	stw	r5,-16(fp)
  20cb0c:	e1bffd15 	stw	r6,-12(fp)
  20cb10:	e1fffe15 	stw	r7,-8(fp)
  int old;

  old = open (name, flags, mode);
  20cb14:	e13ffc17 	ldw	r4,-16(fp)
  20cb18:	e17ffd17 	ldw	r5,-12(fp)
  20cb1c:	e1bffe17 	ldw	r6,-8(fp)
  20cb20:	020cd8c0 	call	20cd8c <open>
  20cb24:	e0bffa15 	stw	r2,-24(fp)

  if (old >= 0)
  20cb28:	e0bffa17 	ldw	r2,-24(fp)
  20cb2c:	10002216 	blt	r2,zero,20cbb8 <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
  20cb30:	04000874 	movhi	r16,33
  20cb34:	84366404 	addi	r16,r16,-9840
  20cb38:	e0bffa17 	ldw	r2,-24(fp)
  20cb3c:	1009883a 	mov	r4,r2
  20cb40:	01400304 	movi	r5,12
  20cb44:	020b50c0 	call	20b50c <__mulsi3>
  20cb48:	8085883a 	add	r2,r16,r2
  20cb4c:	10c00017 	ldw	r3,0(r2)
  20cb50:	e0bffb17 	ldw	r2,-20(fp)
  20cb54:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  20cb58:	04000874 	movhi	r16,33
  20cb5c:	84366404 	addi	r16,r16,-9840
  20cb60:	e0bffa17 	ldw	r2,-24(fp)
  20cb64:	1009883a 	mov	r4,r2
  20cb68:	01400304 	movi	r5,12
  20cb6c:	020b50c0 	call	20b50c <__mulsi3>
  20cb70:	8085883a 	add	r2,r16,r2
  20cb74:	10800104 	addi	r2,r2,4
  20cb78:	10c00017 	ldw	r3,0(r2)
  20cb7c:	e0bffb17 	ldw	r2,-20(fp)
  20cb80:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  20cb84:	04000874 	movhi	r16,33
  20cb88:	84366404 	addi	r16,r16,-9840
  20cb8c:	e0bffa17 	ldw	r2,-24(fp)
  20cb90:	1009883a 	mov	r4,r2
  20cb94:	01400304 	movi	r5,12
  20cb98:	020b50c0 	call	20b50c <__mulsi3>
  20cb9c:	8085883a 	add	r2,r16,r2
  20cba0:	10800204 	addi	r2,r2,8
  20cba4:	10c00017 	ldw	r3,0(r2)
  20cba8:	e0bffb17 	ldw	r2,-20(fp)
  20cbac:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  20cbb0:	e13ffa17 	ldw	r4,-24(fp)
  20cbb4:	020cee80 	call	20cee8 <alt_release_fd>
  }
} 
  20cbb8:	e6ffff04 	addi	sp,fp,-4
  20cbbc:	dfc00217 	ldw	ra,8(sp)
  20cbc0:	df000117 	ldw	fp,4(sp)
  20cbc4:	dc000017 	ldw	r16,0(sp)
  20cbc8:	dec00304 	addi	sp,sp,12
  20cbcc:	f800283a 	ret

0020cbd0 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  20cbd0:	defffb04 	addi	sp,sp,-20
  20cbd4:	dfc00415 	stw	ra,16(sp)
  20cbd8:	df000315 	stw	fp,12(sp)
  20cbdc:	df000304 	addi	fp,sp,12
  20cbe0:	e13ffd15 	stw	r4,-12(fp)
  20cbe4:	e17ffe15 	stw	r5,-8(fp)
  20cbe8:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  20cbec:	01000874 	movhi	r4,33
  20cbf0:	21366704 	addi	r4,r4,-9828
  20cbf4:	e17ffd17 	ldw	r5,-12(fp)
  20cbf8:	01800044 	movi	r6,1
  20cbfc:	01c07fc4 	movi	r7,511
  20cc00:	020caf00 	call	20caf0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  20cc04:	01000874 	movhi	r4,33
  20cc08:	21366404 	addi	r4,r4,-9840
  20cc0c:	e17ffe17 	ldw	r5,-8(fp)
  20cc10:	000d883a 	mov	r6,zero
  20cc14:	01c07fc4 	movi	r7,511
  20cc18:	020caf00 	call	20caf0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  20cc1c:	01000874 	movhi	r4,33
  20cc20:	21366a04 	addi	r4,r4,-9816
  20cc24:	e17fff17 	ldw	r5,-4(fp)
  20cc28:	01800044 	movi	r6,1
  20cc2c:	01c07fc4 	movi	r7,511
  20cc30:	020caf00 	call	20caf0 <alt_open_fd>
}  
  20cc34:	e037883a 	mov	sp,fp
  20cc38:	dfc00117 	ldw	ra,4(sp)
  20cc3c:	df000017 	ldw	fp,0(sp)
  20cc40:	dec00204 	addi	sp,sp,8
  20cc44:	f800283a 	ret

0020cc48 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  20cc48:	defffe04 	addi	sp,sp,-8
  20cc4c:	dfc00115 	stw	ra,4(sp)
  20cc50:	df000015 	stw	fp,0(sp)
  20cc54:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  20cc58:	00800874 	movhi	r2,33
  20cc5c:	10b70604 	addi	r2,r2,-9192
  20cc60:	10800017 	ldw	r2,0(r2)
  20cc64:	10000526 	beq	r2,zero,20cc7c <alt_get_errno+0x34>
  20cc68:	00800874 	movhi	r2,33
  20cc6c:	10b70604 	addi	r2,r2,-9192
  20cc70:	10800017 	ldw	r2,0(r2)
  20cc74:	103ee83a 	callr	r2
  20cc78:	00000206 	br	20cc84 <alt_get_errno+0x3c>
  20cc7c:	00800874 	movhi	r2,33
  20cc80:	10b7d204 	addi	r2,r2,-8376
}
  20cc84:	e037883a 	mov	sp,fp
  20cc88:	dfc00117 	ldw	ra,4(sp)
  20cc8c:	df000017 	ldw	fp,0(sp)
  20cc90:	dec00204 	addi	sp,sp,8
  20cc94:	f800283a 	ret

0020cc98 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  20cc98:	defffb04 	addi	sp,sp,-20
  20cc9c:	dfc00415 	stw	ra,16(sp)
  20cca0:	df000315 	stw	fp,12(sp)
  20cca4:	dc000215 	stw	r16,8(sp)
  20cca8:	df000304 	addi	fp,sp,12
  20ccac:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  20ccb0:	e0bffe17 	ldw	r2,-8(fp)
  20ccb4:	10800217 	ldw	r2,8(r2)
  20ccb8:	10d00034 	orhi	r3,r2,16384
  20ccbc:	e0bffe17 	ldw	r2,-8(fp)
  20ccc0:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  20ccc4:	e03ffd15 	stw	zero,-12(fp)
  20ccc8:	00002306 	br	20cd58 <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  20cccc:	04000874 	movhi	r16,33
  20ccd0:	84366404 	addi	r16,r16,-9840
  20ccd4:	e0bffd17 	ldw	r2,-12(fp)
  20ccd8:	1009883a 	mov	r4,r2
  20ccdc:	01400304 	movi	r5,12
  20cce0:	020b50c0 	call	20b50c <__mulsi3>
  20cce4:	8085883a 	add	r2,r16,r2
  20cce8:	10c00017 	ldw	r3,0(r2)
  20ccec:	e0bffe17 	ldw	r2,-8(fp)
  20ccf0:	10800017 	ldw	r2,0(r2)
  20ccf4:	1880151e 	bne	r3,r2,20cd4c <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  20ccf8:	04000874 	movhi	r16,33
  20ccfc:	84366404 	addi	r16,r16,-9840
  20cd00:	e0bffd17 	ldw	r2,-12(fp)
  20cd04:	1009883a 	mov	r4,r2
  20cd08:	01400304 	movi	r5,12
  20cd0c:	020b50c0 	call	20b50c <__mulsi3>
  20cd10:	8085883a 	add	r2,r16,r2
  20cd14:	10800204 	addi	r2,r2,8
  20cd18:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  20cd1c:	10000b0e 	bge	r2,zero,20cd4c <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  20cd20:	e13ffd17 	ldw	r4,-12(fp)
  20cd24:	01400304 	movi	r5,12
  20cd28:	020b50c0 	call	20b50c <__mulsi3>
  20cd2c:	1007883a 	mov	r3,r2
  20cd30:	00800874 	movhi	r2,33
  20cd34:	10b66404 	addi	r2,r2,-9840
  20cd38:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  20cd3c:	e0bffe17 	ldw	r2,-8(fp)
  20cd40:	18800226 	beq	r3,r2,20cd4c <alt_file_locked+0xb4>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  20cd44:	00bffcc4 	movi	r2,-13
  20cd48:	00000a06 	br	20cd74 <alt_file_locked+0xdc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  20cd4c:	e0bffd17 	ldw	r2,-12(fp)
  20cd50:	10800044 	addi	r2,r2,1
  20cd54:	e0bffd15 	stw	r2,-12(fp)
  20cd58:	00800874 	movhi	r2,33
  20cd5c:	10b70504 	addi	r2,r2,-9196
  20cd60:	10800017 	ldw	r2,0(r2)
  20cd64:	1007883a 	mov	r3,r2
  20cd68:	e0bffd17 	ldw	r2,-12(fp)
  20cd6c:	18bfd72e 	bgeu	r3,r2,20cccc <_gp+0xffff70dc>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  20cd70:	0005883a 	mov	r2,zero
}
  20cd74:	e6ffff04 	addi	sp,fp,-4
  20cd78:	dfc00217 	ldw	ra,8(sp)
  20cd7c:	df000117 	ldw	fp,4(sp)
  20cd80:	dc000017 	ldw	r16,0(sp)
  20cd84:	dec00304 	addi	sp,sp,12
  20cd88:	f800283a 	ret

0020cd8c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  20cd8c:	defff604 	addi	sp,sp,-40
  20cd90:	dfc00915 	stw	ra,36(sp)
  20cd94:	df000815 	stw	fp,32(sp)
  20cd98:	df000804 	addi	fp,sp,32
  20cd9c:	e13ffd15 	stw	r4,-12(fp)
  20cda0:	e17ffe15 	stw	r5,-8(fp)
  20cda4:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  20cda8:	00bfffc4 	movi	r2,-1
  20cdac:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  20cdb0:	00bffb44 	movi	r2,-19
  20cdb4:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  20cdb8:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  20cdbc:	e13ffd17 	ldw	r4,-12(fp)
  20cdc0:	01400874 	movhi	r5,33
  20cdc4:	29770304 	addi	r5,r5,-9204
  20cdc8:	020cf880 	call	20cf88 <alt_find_dev>
  20cdcc:	e0bff815 	stw	r2,-32(fp)
  20cdd0:	e0bff817 	ldw	r2,-32(fp)
  20cdd4:	1000051e 	bne	r2,zero,20cdec <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  20cdd8:	e13ffd17 	ldw	r4,-12(fp)
  20cddc:	020d0180 	call	20d018 <alt_find_file>
  20cde0:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  20cde4:	00800044 	movi	r2,1
  20cde8:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  20cdec:	e0bff817 	ldw	r2,-32(fp)
  20cdf0:	10002b26 	beq	r2,zero,20cea0 <open+0x114>
  {
    if ((index = alt_get_fd (dev)) < 0)
  20cdf4:	e13ff817 	ldw	r4,-32(fp)
  20cdf8:	020d12c0 	call	20d12c <alt_get_fd>
  20cdfc:	e0bff915 	stw	r2,-28(fp)
  20ce00:	e0bff917 	ldw	r2,-28(fp)
  20ce04:	1000030e 	bge	r2,zero,20ce14 <open+0x88>
    {
      status = index;
  20ce08:	e0bff917 	ldw	r2,-28(fp)
  20ce0c:	e0bffa15 	stw	r2,-24(fp)
  20ce10:	00002506 	br	20cea8 <open+0x11c>
    }
    else
    {
      fd = &alt_fd_list[index];
  20ce14:	e13ff917 	ldw	r4,-28(fp)
  20ce18:	01400304 	movi	r5,12
  20ce1c:	020b50c0 	call	20b50c <__mulsi3>
  20ce20:	1007883a 	mov	r3,r2
  20ce24:	00800874 	movhi	r2,33
  20ce28:	10b66404 	addi	r2,r2,-9840
  20ce2c:	1885883a 	add	r2,r3,r2
  20ce30:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  20ce34:	e0fffe17 	ldw	r3,-8(fp)
  20ce38:	00900034 	movhi	r2,16384
  20ce3c:	10bfffc4 	addi	r2,r2,-1
  20ce40:	1886703a 	and	r3,r3,r2
  20ce44:	e0bffc17 	ldw	r2,-16(fp)
  20ce48:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  20ce4c:	e0bffb17 	ldw	r2,-20(fp)
  20ce50:	1000051e 	bne	r2,zero,20ce68 <open+0xdc>
  20ce54:	e13ffc17 	ldw	r4,-16(fp)
  20ce58:	020cc980 	call	20cc98 <alt_file_locked>
  20ce5c:	e0bffa15 	stw	r2,-24(fp)
  20ce60:	e0bffa17 	ldw	r2,-24(fp)
  20ce64:	10001016 	blt	r2,zero,20cea8 <open+0x11c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  20ce68:	e0bff817 	ldw	r2,-32(fp)
  20ce6c:	10800317 	ldw	r2,12(r2)
  20ce70:	10000826 	beq	r2,zero,20ce94 <open+0x108>
  20ce74:	e0bff817 	ldw	r2,-32(fp)
  20ce78:	10800317 	ldw	r2,12(r2)
  20ce7c:	e13ffc17 	ldw	r4,-16(fp)
  20ce80:	e17ffd17 	ldw	r5,-12(fp)
  20ce84:	e1bffe17 	ldw	r6,-8(fp)
  20ce88:	e1ffff17 	ldw	r7,-4(fp)
  20ce8c:	103ee83a 	callr	r2
  20ce90:	00000106 	br	20ce98 <open+0x10c>
  20ce94:	0005883a 	mov	r2,zero
  20ce98:	e0bffa15 	stw	r2,-24(fp)
  20ce9c:	00000206 	br	20cea8 <open+0x11c>
      }
    }
  }
  else
  {
    status = -ENODEV;
  20cea0:	00bffb44 	movi	r2,-19
  20cea4:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  20cea8:	e0bffa17 	ldw	r2,-24(fp)
  20ceac:	1000080e 	bge	r2,zero,20ced0 <open+0x144>
  {
    alt_release_fd (index);  
  20ceb0:	e13ff917 	ldw	r4,-28(fp)
  20ceb4:	020cee80 	call	20cee8 <alt_release_fd>
    ALT_ERRNO = -status;
  20ceb8:	020cc480 	call	20cc48 <alt_get_errno>
  20cebc:	e0fffa17 	ldw	r3,-24(fp)
  20cec0:	00c7c83a 	sub	r3,zero,r3
  20cec4:	10c00015 	stw	r3,0(r2)
    return -1;
  20cec8:	00bfffc4 	movi	r2,-1
  20cecc:	00000106 	br	20ced4 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
  20ced0:	e0bff917 	ldw	r2,-28(fp)
}
  20ced4:	e037883a 	mov	sp,fp
  20ced8:	dfc00117 	ldw	ra,4(sp)
  20cedc:	df000017 	ldw	fp,0(sp)
  20cee0:	dec00204 	addi	sp,sp,8
  20cee4:	f800283a 	ret

0020cee8 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  20cee8:	defffc04 	addi	sp,sp,-16
  20ceec:	dfc00315 	stw	ra,12(sp)
  20cef0:	df000215 	stw	fp,8(sp)
  20cef4:	dc000115 	stw	r16,4(sp)
  20cef8:	df000204 	addi	fp,sp,8
  20cefc:	e13ffe15 	stw	r4,-8(fp)
  if (fd > 2)
  20cf00:	e0bffe17 	ldw	r2,-8(fp)
  20cf04:	108000d0 	cmplti	r2,r2,3
  20cf08:	1000111e 	bne	r2,zero,20cf50 <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
  20cf0c:	04000874 	movhi	r16,33
  20cf10:	84366404 	addi	r16,r16,-9840
  20cf14:	e0bffe17 	ldw	r2,-8(fp)
  20cf18:	1009883a 	mov	r4,r2
  20cf1c:	01400304 	movi	r5,12
  20cf20:	020b50c0 	call	20b50c <__mulsi3>
  20cf24:	8085883a 	add	r2,r16,r2
  20cf28:	10800204 	addi	r2,r2,8
  20cf2c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  20cf30:	04000874 	movhi	r16,33
  20cf34:	84366404 	addi	r16,r16,-9840
  20cf38:	e0bffe17 	ldw	r2,-8(fp)
  20cf3c:	1009883a 	mov	r4,r2
  20cf40:	01400304 	movi	r5,12
  20cf44:	020b50c0 	call	20b50c <__mulsi3>
  20cf48:	8085883a 	add	r2,r16,r2
  20cf4c:	10000015 	stw	zero,0(r2)
  }
}
  20cf50:	e6ffff04 	addi	sp,fp,-4
  20cf54:	dfc00217 	ldw	ra,8(sp)
  20cf58:	df000117 	ldw	fp,4(sp)
  20cf5c:	dc000017 	ldw	r16,0(sp)
  20cf60:	dec00304 	addi	sp,sp,12
  20cf64:	f800283a 	ret

0020cf68 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
  20cf68:	deffff04 	addi	sp,sp,-4
  20cf6c:	df000015 	stw	fp,0(sp)
  20cf70:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  20cf74:	000170fa 	wrctl	ienable,zero
}
  20cf78:	e037883a 	mov	sp,fp
  20cf7c:	df000017 	ldw	fp,0(sp)
  20cf80:	dec00104 	addi	sp,sp,4
  20cf84:	f800283a 	ret

0020cf88 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  20cf88:	defffa04 	addi	sp,sp,-24
  20cf8c:	dfc00515 	stw	ra,20(sp)
  20cf90:	df000415 	stw	fp,16(sp)
  20cf94:	df000404 	addi	fp,sp,16
  20cf98:	e13ffe15 	stw	r4,-8(fp)
  20cf9c:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  20cfa0:	e0bfff17 	ldw	r2,-4(fp)
  20cfa4:	10800017 	ldw	r2,0(r2)
  20cfa8:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  20cfac:	e13ffe17 	ldw	r4,-8(fp)
  20cfb0:	020bb940 	call	20bb94 <strlen>
  20cfb4:	10800044 	addi	r2,r2,1
  20cfb8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  20cfbc:	00000d06 	br	20cff4 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  20cfc0:	e0bffc17 	ldw	r2,-16(fp)
  20cfc4:	10c00217 	ldw	r3,8(r2)
  20cfc8:	e0bffd17 	ldw	r2,-12(fp)
  20cfcc:	1809883a 	mov	r4,r3
  20cfd0:	e17ffe17 	ldw	r5,-8(fp)
  20cfd4:	100d883a 	mov	r6,r2
  20cfd8:	020d2340 	call	20d234 <memcmp>
  20cfdc:	1000021e 	bne	r2,zero,20cfe8 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  20cfe0:	e0bffc17 	ldw	r2,-16(fp)
  20cfe4:	00000706 	br	20d004 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  20cfe8:	e0bffc17 	ldw	r2,-16(fp)
  20cfec:	10800017 	ldw	r2,0(r2)
  20cff0:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  20cff4:	e0fffc17 	ldw	r3,-16(fp)
  20cff8:	e0bfff17 	ldw	r2,-4(fp)
  20cffc:	18bff01e 	bne	r3,r2,20cfc0 <_gp+0xffff73d0>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  20d000:	0005883a 	mov	r2,zero
}
  20d004:	e037883a 	mov	sp,fp
  20d008:	dfc00117 	ldw	ra,4(sp)
  20d00c:	df000017 	ldw	fp,0(sp)
  20d010:	dec00204 	addi	sp,sp,8
  20d014:	f800283a 	ret

0020d018 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  20d018:	defffb04 	addi	sp,sp,-20
  20d01c:	dfc00415 	stw	ra,16(sp)
  20d020:	df000315 	stw	fp,12(sp)
  20d024:	df000304 	addi	fp,sp,12
  20d028:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  20d02c:	00800874 	movhi	r2,33
  20d030:	10b70104 	addi	r2,r2,-9212
  20d034:	10800017 	ldw	r2,0(r2)
  20d038:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  20d03c:	00003106 	br	20d104 <alt_find_file+0xec>
  {
    len = strlen(next->name);
  20d040:	e0bffd17 	ldw	r2,-12(fp)
  20d044:	10800217 	ldw	r2,8(r2)
  20d048:	1009883a 	mov	r4,r2
  20d04c:	020bb940 	call	20bb94 <strlen>
  20d050:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  20d054:	e0bffd17 	ldw	r2,-12(fp)
  20d058:	10c00217 	ldw	r3,8(r2)
  20d05c:	e0bffe17 	ldw	r2,-8(fp)
  20d060:	10bfffc4 	addi	r2,r2,-1
  20d064:	1885883a 	add	r2,r3,r2
  20d068:	10800003 	ldbu	r2,0(r2)
  20d06c:	10803fcc 	andi	r2,r2,255
  20d070:	1080201c 	xori	r2,r2,128
  20d074:	10bfe004 	addi	r2,r2,-128
  20d078:	10800bd8 	cmpnei	r2,r2,47
  20d07c:	1000031e 	bne	r2,zero,20d08c <alt_find_file+0x74>
    {
      len -= 1;
  20d080:	e0bffe17 	ldw	r2,-8(fp)
  20d084:	10bfffc4 	addi	r2,r2,-1
  20d088:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  20d08c:	e0bffe17 	ldw	r2,-8(fp)
  20d090:	e0ffff17 	ldw	r3,-4(fp)
  20d094:	1885883a 	add	r2,r3,r2
  20d098:	10800003 	ldbu	r2,0(r2)
  20d09c:	10803fcc 	andi	r2,r2,255
  20d0a0:	1080201c 	xori	r2,r2,128
  20d0a4:	10bfe004 	addi	r2,r2,-128
  20d0a8:	10800be0 	cmpeqi	r2,r2,47
  20d0ac:	1000081e 	bne	r2,zero,20d0d0 <alt_find_file+0xb8>
  20d0b0:	e0bffe17 	ldw	r2,-8(fp)
  20d0b4:	e0ffff17 	ldw	r3,-4(fp)
  20d0b8:	1885883a 	add	r2,r3,r2
  20d0bc:	10800003 	ldbu	r2,0(r2)
  20d0c0:	10803fcc 	andi	r2,r2,255
  20d0c4:	1080201c 	xori	r2,r2,128
  20d0c8:	10bfe004 	addi	r2,r2,-128
  20d0cc:	10000a1e 	bne	r2,zero,20d0f8 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
  20d0d0:	e0bffd17 	ldw	r2,-12(fp)
  20d0d4:	10c00217 	ldw	r3,8(r2)
  20d0d8:	e0bffe17 	ldw	r2,-8(fp)
  20d0dc:	1809883a 	mov	r4,r3
  20d0e0:	e17fff17 	ldw	r5,-4(fp)
  20d0e4:	100d883a 	mov	r6,r2
  20d0e8:	020d2340 	call	20d234 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  20d0ec:	1000021e 	bne	r2,zero,20d0f8 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  20d0f0:	e0bffd17 	ldw	r2,-12(fp)
  20d0f4:	00000806 	br	20d118 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
  20d0f8:	e0bffd17 	ldw	r2,-12(fp)
  20d0fc:	10800017 	ldw	r2,0(r2)
  20d100:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  20d104:	e0fffd17 	ldw	r3,-12(fp)
  20d108:	00800874 	movhi	r2,33
  20d10c:	10b70104 	addi	r2,r2,-9212
  20d110:	18bfcb1e 	bne	r3,r2,20d040 <_gp+0xffff7450>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  20d114:	0005883a 	mov	r2,zero
}
  20d118:	e037883a 	mov	sp,fp
  20d11c:	dfc00117 	ldw	ra,4(sp)
  20d120:	df000017 	ldw	fp,0(sp)
  20d124:	dec00204 	addi	sp,sp,8
  20d128:	f800283a 	ret

0020d12c <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  20d12c:	defffa04 	addi	sp,sp,-24
  20d130:	dfc00515 	stw	ra,20(sp)
  20d134:	df000415 	stw	fp,16(sp)
  20d138:	dc000315 	stw	r16,12(sp)
  20d13c:	df000404 	addi	fp,sp,16
  20d140:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
  20d144:	00bffa04 	movi	r2,-24
  20d148:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  20d14c:	e03ffc15 	stw	zero,-16(fp)
  20d150:	00002106 	br	20d1d8 <alt_get_fd+0xac>
  {
    if (!alt_fd_list[i].dev)
  20d154:	04000874 	movhi	r16,33
  20d158:	84366404 	addi	r16,r16,-9840
  20d15c:	e0bffc17 	ldw	r2,-16(fp)
  20d160:	1009883a 	mov	r4,r2
  20d164:	01400304 	movi	r5,12
  20d168:	020b50c0 	call	20b50c <__mulsi3>
  20d16c:	8085883a 	add	r2,r16,r2
  20d170:	10800017 	ldw	r2,0(r2)
  20d174:	1000151e 	bne	r2,zero,20d1cc <alt_get_fd+0xa0>
    {
      alt_fd_list[i].dev = dev;
  20d178:	04000874 	movhi	r16,33
  20d17c:	84366404 	addi	r16,r16,-9840
  20d180:	e0bffc17 	ldw	r2,-16(fp)
  20d184:	1009883a 	mov	r4,r2
  20d188:	01400304 	movi	r5,12
  20d18c:	020b50c0 	call	20b50c <__mulsi3>
  20d190:	8085883a 	add	r2,r16,r2
  20d194:	e0fffe17 	ldw	r3,-8(fp)
  20d198:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  20d19c:	00800874 	movhi	r2,33
  20d1a0:	10b70504 	addi	r2,r2,-9196
  20d1a4:	10c00017 	ldw	r3,0(r2)
  20d1a8:	e0bffc17 	ldw	r2,-16(fp)
  20d1ac:	1880040e 	bge	r3,r2,20d1c0 <alt_get_fd+0x94>
      {
        alt_max_fd = i;
  20d1b0:	00800874 	movhi	r2,33
  20d1b4:	10b70504 	addi	r2,r2,-9196
  20d1b8:	e0fffc17 	ldw	r3,-16(fp)
  20d1bc:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
  20d1c0:	e0bffc17 	ldw	r2,-16(fp)
  20d1c4:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
  20d1c8:	00000606 	br	20d1e4 <alt_get_fd+0xb8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  20d1cc:	e0bffc17 	ldw	r2,-16(fp)
  20d1d0:	10800044 	addi	r2,r2,1
  20d1d4:	e0bffc15 	stw	r2,-16(fp)
  20d1d8:	e0bffc17 	ldw	r2,-16(fp)
  20d1dc:	10800810 	cmplti	r2,r2,32
  20d1e0:	103fdc1e 	bne	r2,zero,20d154 <_gp+0xffff7564>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  20d1e4:	e0bffd17 	ldw	r2,-12(fp)
}
  20d1e8:	e6ffff04 	addi	sp,fp,-4
  20d1ec:	dfc00217 	ldw	ra,8(sp)
  20d1f0:	df000117 	ldw	fp,4(sp)
  20d1f4:	dc000017 	ldw	r16,0(sp)
  20d1f8:	dec00304 	addi	sp,sp,12
  20d1fc:	f800283a 	ret

0020d200 <atexit>:
  20d200:	200b883a 	mov	r5,r4
  20d204:	000d883a 	mov	r6,zero
  20d208:	0009883a 	mov	r4,zero
  20d20c:	000f883a 	mov	r7,zero
  20d210:	020d2641 	jmpi	20d264 <__register_exitproc>

0020d214 <exit>:
  20d214:	defffe04 	addi	sp,sp,-8
  20d218:	000b883a 	mov	r5,zero
  20d21c:	dc000015 	stw	r16,0(sp)
  20d220:	dfc00115 	stw	ra,4(sp)
  20d224:	2021883a 	mov	r16,r4
  20d228:	020d3a80 	call	20d3a8 <__call_exitprocs>
  20d22c:	8009883a 	mov	r4,r16
  20d230:	020d5400 	call	20d540 <_exit>

0020d234 <memcmp>:
  20d234:	218d883a 	add	r6,r4,r6
  20d238:	21800826 	beq	r4,r6,20d25c <memcmp+0x28>
  20d23c:	20c00003 	ldbu	r3,0(r4)
  20d240:	28800003 	ldbu	r2,0(r5)
  20d244:	18800226 	beq	r3,r2,20d250 <memcmp+0x1c>
  20d248:	1885c83a 	sub	r2,r3,r2
  20d24c:	f800283a 	ret
  20d250:	21000044 	addi	r4,r4,1
  20d254:	29400044 	addi	r5,r5,1
  20d258:	003ff706 	br	20d238 <_gp+0xffff7648>
  20d25c:	0005883a 	mov	r2,zero
  20d260:	f800283a 	ret

0020d264 <__register_exitproc>:
  20d264:	defff904 	addi	sp,sp,-28
  20d268:	00800874 	movhi	r2,33
  20d26c:	10b70804 	addi	r2,r2,-9184
  20d270:	dc400115 	stw	r17,4(sp)
  20d274:	14400017 	ldw	r17,0(r2)
  20d278:	dc000015 	stw	r16,0(sp)
  20d27c:	dd400515 	stw	r21,20(sp)
  20d280:	8c000c17 	ldw	r16,48(r17)
  20d284:	dd000415 	stw	r20,16(sp)
  20d288:	dcc00315 	stw	r19,12(sp)
  20d28c:	dc800215 	stw	r18,8(sp)
  20d290:	dfc00615 	stw	ra,24(sp)
  20d294:	2025883a 	mov	r18,r4
  20d298:	2827883a 	mov	r19,r5
  20d29c:	302b883a 	mov	r21,r6
  20d2a0:	3829883a 	mov	r20,r7
  20d2a4:	8000021e 	bne	r16,zero,20d2b0 <__register_exitproc+0x4c>
  20d2a8:	8c000d04 	addi	r16,r17,52
  20d2ac:	8c000c15 	stw	r16,48(r17)
  20d2b0:	80800117 	ldw	r2,4(r16)
  20d2b4:	00c007c4 	movi	r3,31
  20d2b8:	18800d0e 	bge	r3,r2,20d2f0 <__register_exitproc+0x8c>
  20d2bc:	00800034 	movhi	r2,0
  20d2c0:	10800004 	addi	r2,r2,0
  20d2c4:	1000021e 	bne	r2,zero,20d2d0 <__register_exitproc+0x6c>
  20d2c8:	00bfffc4 	movi	r2,-1
  20d2cc:	00002d06 	br	20d384 <__register_exitproc+0x120>
  20d2d0:	01002304 	movi	r4,140
  20d2d4:	00000000 	call	0 <__alt_mem_ext_sram_controller_0-0x100000>
  20d2d8:	1021883a 	mov	r16,r2
  20d2dc:	103ffa26 	beq	r2,zero,20d2c8 <_gp+0xffff76d8>
  20d2e0:	10000115 	stw	zero,4(r2)
  20d2e4:	88800c17 	ldw	r2,48(r17)
  20d2e8:	80800015 	stw	r2,0(r16)
  20d2ec:	8c000c15 	stw	r16,48(r17)
  20d2f0:	90001b26 	beq	r18,zero,20d360 <__register_exitproc+0xfc>
  20d2f4:	80802217 	ldw	r2,136(r16)
  20d2f8:	1000091e 	bne	r2,zero,20d320 <__register_exitproc+0xbc>
  20d2fc:	00800034 	movhi	r2,0
  20d300:	10800004 	addi	r2,r2,0
  20d304:	103ff026 	beq	r2,zero,20d2c8 <_gp+0xffff76d8>
  20d308:	01004204 	movi	r4,264
  20d30c:	103ee83a 	callr	r2
  20d310:	103fed26 	beq	r2,zero,20d2c8 <_gp+0xffff76d8>
  20d314:	10004015 	stw	zero,256(r2)
  20d318:	10004115 	stw	zero,260(r2)
  20d31c:	80802215 	stw	r2,136(r16)
  20d320:	80c00117 	ldw	r3,4(r16)
  20d324:	01400044 	movi	r5,1
  20d328:	18c9883a 	add	r4,r3,r3
  20d32c:	2109883a 	add	r4,r4,r4
  20d330:	1109883a 	add	r4,r2,r4
  20d334:	25400015 	stw	r21,0(r4)
  20d338:	28c6983a 	sll	r3,r5,r3
  20d33c:	11404017 	ldw	r5,256(r2)
  20d340:	28cab03a 	or	r5,r5,r3
  20d344:	11404015 	stw	r5,256(r2)
  20d348:	25002015 	stw	r20,128(r4)
  20d34c:	01000084 	movi	r4,2
  20d350:	9100031e 	bne	r18,r4,20d360 <__register_exitproc+0xfc>
  20d354:	11004117 	ldw	r4,260(r2)
  20d358:	20c6b03a 	or	r3,r4,r3
  20d35c:	10c04115 	stw	r3,260(r2)
  20d360:	80800117 	ldw	r2,4(r16)
  20d364:	10c00044 	addi	r3,r2,1
  20d368:	10800084 	addi	r2,r2,2
  20d36c:	1085883a 	add	r2,r2,r2
  20d370:	1085883a 	add	r2,r2,r2
  20d374:	80c00115 	stw	r3,4(r16)
  20d378:	80a1883a 	add	r16,r16,r2
  20d37c:	84c00015 	stw	r19,0(r16)
  20d380:	0005883a 	mov	r2,zero
  20d384:	dfc00617 	ldw	ra,24(sp)
  20d388:	dd400517 	ldw	r21,20(sp)
  20d38c:	dd000417 	ldw	r20,16(sp)
  20d390:	dcc00317 	ldw	r19,12(sp)
  20d394:	dc800217 	ldw	r18,8(sp)
  20d398:	dc400117 	ldw	r17,4(sp)
  20d39c:	dc000017 	ldw	r16,0(sp)
  20d3a0:	dec00704 	addi	sp,sp,28
  20d3a4:	f800283a 	ret

0020d3a8 <__call_exitprocs>:
  20d3a8:	00800874 	movhi	r2,33
  20d3ac:	10b70804 	addi	r2,r2,-9184
  20d3b0:	10800017 	ldw	r2,0(r2)
  20d3b4:	defff304 	addi	sp,sp,-52
  20d3b8:	ddc00a15 	stw	r23,40(sp)
  20d3bc:	d8800015 	stw	r2,0(sp)
  20d3c0:	10800c04 	addi	r2,r2,48
  20d3c4:	dc800515 	stw	r18,20(sp)
  20d3c8:	dfc00c15 	stw	ra,48(sp)
  20d3cc:	df000b15 	stw	fp,44(sp)
  20d3d0:	dd800915 	stw	r22,36(sp)
  20d3d4:	dd400815 	stw	r21,32(sp)
  20d3d8:	dd000715 	stw	r20,28(sp)
  20d3dc:	dcc00615 	stw	r19,24(sp)
  20d3e0:	dc400415 	stw	r17,16(sp)
  20d3e4:	dc000315 	stw	r16,12(sp)
  20d3e8:	d9000115 	stw	r4,4(sp)
  20d3ec:	2825883a 	mov	r18,r5
  20d3f0:	d8800215 	stw	r2,8(sp)
  20d3f4:	05c00034 	movhi	r23,0
  20d3f8:	bdc00004 	addi	r23,r23,0
  20d3fc:	d8800017 	ldw	r2,0(sp)
  20d400:	dc000217 	ldw	r16,8(sp)
  20d404:	14c00c17 	ldw	r19,48(r2)
  20d408:	98004126 	beq	r19,zero,20d510 <__call_exitprocs+0x168>
  20d40c:	9c400117 	ldw	r17,4(r19)
  20d410:	9d002217 	ldw	r20,136(r19)
  20d414:	8d7fffc4 	addi	r21,r17,-1
  20d418:	8c400044 	addi	r17,r17,1
  20d41c:	ad4f883a 	add	r7,r21,r21
  20d420:	8c63883a 	add	r17,r17,r17
  20d424:	39cf883a 	add	r7,r7,r7
  20d428:	8c63883a 	add	r17,r17,r17
  20d42c:	a1ed883a 	add	r22,r20,r7
  20d430:	9c63883a 	add	r17,r19,r17
  20d434:	a8002616 	blt	r21,zero,20d4d0 <__call_exitprocs+0x128>
  20d438:	90000326 	beq	r18,zero,20d448 <__call_exitprocs+0xa0>
  20d43c:	a0002026 	beq	r20,zero,20d4c0 <__call_exitprocs+0x118>
  20d440:	b1002017 	ldw	r4,128(r22)
  20d444:	24801e1e 	bne	r4,r18,20d4c0 <__call_exitprocs+0x118>
  20d448:	99000117 	ldw	r4,4(r19)
  20d44c:	8a000017 	ldw	r8,0(r17)
  20d450:	213fffc4 	addi	r4,r4,-1
  20d454:	a900021e 	bne	r21,r4,20d460 <__call_exitprocs+0xb8>
  20d458:	9d400115 	stw	r21,4(r19)
  20d45c:	00000106 	br	20d464 <__call_exitprocs+0xbc>
  20d460:	88000015 	stw	zero,0(r17)
  20d464:	40001626 	beq	r8,zero,20d4c0 <__call_exitprocs+0x118>
  20d468:	9f000117 	ldw	fp,4(r19)
  20d46c:	a0000526 	beq	r20,zero,20d484 <__call_exitprocs+0xdc>
  20d470:	00800044 	movi	r2,1
  20d474:	1548983a 	sll	r4,r2,r21
  20d478:	a1404017 	ldw	r5,256(r20)
  20d47c:	214a703a 	and	r5,r4,r5
  20d480:	2800021e 	bne	r5,zero,20d48c <__call_exitprocs+0xe4>
  20d484:	403ee83a 	callr	r8
  20d488:	00000906 	br	20d4b0 <__call_exitprocs+0x108>
  20d48c:	a1404117 	ldw	r5,260(r20)
  20d490:	2148703a 	and	r4,r4,r5
  20d494:	2000041e 	bne	r4,zero,20d4a8 <__call_exitprocs+0x100>
  20d498:	d9000117 	ldw	r4,4(sp)
  20d49c:	b1400017 	ldw	r5,0(r22)
  20d4a0:	403ee83a 	callr	r8
  20d4a4:	00000206 	br	20d4b0 <__call_exitprocs+0x108>
  20d4a8:	b1000017 	ldw	r4,0(r22)
  20d4ac:	403ee83a 	callr	r8
  20d4b0:	99000117 	ldw	r4,4(r19)
  20d4b4:	e13fd11e 	bne	fp,r4,20d3fc <_gp+0xffff780c>
  20d4b8:	81000017 	ldw	r4,0(r16)
  20d4bc:	24ffcf1e 	bne	r4,r19,20d3fc <_gp+0xffff780c>
  20d4c0:	ad7fffc4 	addi	r21,r21,-1
  20d4c4:	b5bfff04 	addi	r22,r22,-4
  20d4c8:	8c7fff04 	addi	r17,r17,-4
  20d4cc:	003fd906 	br	20d434 <_gp+0xffff7844>
  20d4d0:	b8000f26 	beq	r23,zero,20d510 <__call_exitprocs+0x168>
  20d4d4:	99000117 	ldw	r4,4(r19)
  20d4d8:	98c00017 	ldw	r3,0(r19)
  20d4dc:	2000091e 	bne	r4,zero,20d504 <__call_exitprocs+0x15c>
  20d4e0:	18000826 	beq	r3,zero,20d504 <__call_exitprocs+0x15c>
  20d4e4:	80c00015 	stw	r3,0(r16)
  20d4e8:	a0000226 	beq	r20,zero,20d4f4 <__call_exitprocs+0x14c>
  20d4ec:	a009883a 	mov	r4,r20
  20d4f0:	00000000 	call	0 <__alt_mem_ext_sram_controller_0-0x100000>
  20d4f4:	9809883a 	mov	r4,r19
  20d4f8:	00000000 	call	0 <__alt_mem_ext_sram_controller_0-0x100000>
  20d4fc:	84c00017 	ldw	r19,0(r16)
  20d500:	003fc106 	br	20d408 <_gp+0xffff7818>
  20d504:	9821883a 	mov	r16,r19
  20d508:	1827883a 	mov	r19,r3
  20d50c:	003fbe06 	br	20d408 <_gp+0xffff7818>
  20d510:	dfc00c17 	ldw	ra,48(sp)
  20d514:	df000b17 	ldw	fp,44(sp)
  20d518:	ddc00a17 	ldw	r23,40(sp)
  20d51c:	dd800917 	ldw	r22,36(sp)
  20d520:	dd400817 	ldw	r21,32(sp)
  20d524:	dd000717 	ldw	r20,28(sp)
  20d528:	dcc00617 	ldw	r19,24(sp)
  20d52c:	dc800517 	ldw	r18,20(sp)
  20d530:	dc400417 	ldw	r17,16(sp)
  20d534:	dc000317 	ldw	r16,12(sp)
  20d538:	dec00d04 	addi	sp,sp,52
  20d53c:	f800283a 	ret

0020d540 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  20d540:	defffd04 	addi	sp,sp,-12
  20d544:	df000215 	stw	fp,8(sp)
  20d548:	df000204 	addi	fp,sp,8
  20d54c:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  20d550:	0001883a 	nop
  20d554:	e0bfff17 	ldw	r2,-4(fp)
  20d558:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
  20d55c:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  20d560:	10000226 	beq	r2,zero,20d56c <_exit+0x2c>
    ALT_SIM_FAIL();
  20d564:	002af070 	cmpltui	zero,zero,43969
  20d568:	00000106 	br	20d570 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
  20d56c:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  20d570:	003fff06 	br	20d570 <_gp+0xffff7980>
